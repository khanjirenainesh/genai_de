table_name : MRCHR_RESPONSES
solution : Detect anomalies such as negative facings and category facings, inconsistent datetime formats, and potential out-of-stock discrepancies. Correct data entry errors and ensure all datetime fields use a consistent format.
snowflake query : 
SELECT 
    *
FROM 
    MRCHR_RESPONSES
WHERE 
    FACINGS < 0 OR
    CATEGORYFACINGS < 0 OR
    TRY_TO_TIMESTAMP(FETCHEDDATETIME) IS NULL OR 
    TRY_TO_TIMESTAMP(AZUREDATETIME) IS NULL OR 
    TRY_TO_TIMESTAMP(CDL_DATETIME) IS NULL OR
    (OUTOFSTOCK = 'No' AND STOCKCOUNT = 0);
========================================================================================================================================

table_name : SDL_CSL_DAILYSALES_UNDELIVERED
solution : Check for missing or null values in the critical columns and ensure referential integrity. Validate data types and ranges.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_CSL_DAILYSALES_UNDELIVERED
WHERE 
    distcode IS NULL OR 
    salinvno IS NULL OR 
    salinvdate IS NULL OR 
    saldlvdate IS NULL OR 
    salinvmode IS NULL OR 
    salinvtype IS NULL OR 
    salgrossamt IS NULL OR 
    salspldiscamt IS NULL OR 
    salschdiscamt IS NULL OR 
    salcashdiscamt IS NULL OR 
    saldbdiscamt IS NULL OR 
    saltaxamt IS NULL OR 
    salwdsamt IS NULL OR 
    saldbadjamt IS NULL OR 
    salcradjamt IS NULL OR 
    salonaccountamt IS NULL OR 
    salmktretamt IS NULL OR 
    salreplaceamt IS NULL OR 
    salotherchargesamt IS NULL OR 
    salinvleveldiscamt IS NULL OR 
    saltotdedn IS NULL OR 
    saltotaddn IS NULL OR 
    salroundoffamt IS NULL OR 
    salnetamt IS NULL OR 
    lcnid IS NULL OR 
    lcncode IS NULL OR 
    salesmancode IS NULL OR 
    salesmanname IS NULL OR 
    salesroutecode IS NULL OR 
    salesroutename IS NULL OR 
    rtrid IS NULL OR 
    rtrcode IS NULL OR 
    rtrname IS NULL OR 
    vechname IS NULL OR 
    dlvboyname IS NULL OR 
    deliveryroutecode IS NULL OR 
    deliveryroutename IS NULL OR 
    prdcode IS NULL OR 
    prdbatcde IS NULL OR 
    prdqty IS NULL OR 
    prdselratebeforetax IS NULL OR 
    prdselrateaftertax IS NULL OR 
    prdfreeqty IS NULL OR 
    prdgrossamt IS NULL OR 
    prdspldiscamt IS NULL OR 
    prdschdiscamt IS NULL OR 
    prdcashdiscamt IS NULL OR 
    prddbdiscamt IS NULL OR 
    prdtaxamt IS NULL OR 
    prdnetamt IS NULL OR 
    uploadflag IS NULL OR 
    salinvlinecount IS NULL OR 
    salinvlvldiscper IS NULL OR 
    billstatus IS NULL OR 
    uploadeddate IS NULL OR 
    syncid IS NULL OR 
    createddate IS NULL OR 
    mrp IS NULL OR 
    nrvalue IS NULL OR 
    run_id IS NULL OR 
    crt_dttm IS NULL OR 
    file_name IS NULL OR 
    salgrossamt < 0 OR 
    salnetamt < 0 OR 
    prdqty < 0 OR 
    prdselratebeforetax < 0 OR 
    prdselrateaftertax < 0 OR 
    prdgrossamt < 0 OR 
    prdnetamt < 0;
========================================================================================================================================

table_name: SDL_LA_GT_SALES_ORDER_FACT  
solution: Check for mismatched data types, missing values, and inconsistent data entries. Ensure data integrity by validating and cleansing data.  
snowflake query:  
SELECT *  
FROM SDL_LA_GT_SALES_ORDER_FACT  
WHERE  
  (TRY_CAST(CAST(crt_dttm AS STRING) AS TIMESTAMP_NTZ) IS NULL AND crt_dttm IS NOT NULL) OR  
  (saleunit IS NULL OR   
   orderid IS NULL OR   
   orderdate IS NULL OR   
   customer_id IS NULL OR   
   customer_name IS NULL OR   
   city IS NULL OR   
   region IS NULL OR   
   saledistrict IS NULL OR   
   saleoffice IS NULL OR   
   salegroup IS NULL OR   
   customertype IS NULL OR   
   storetype IS NULL OR   
   saletype IS NULL OR   
   salesemployee IS NULL OR   
   salename IS NULL OR   
   productid IS NULL OR   
   productname IS NULL OR   
   megabrand IS NULL OR   
   brand IS NULL OR   
   baseproduct IS NULL OR   
   variant IS NULL OR   
   putup IS NULL OR   
   priceref IS NULL OR   
   backlog IS NULL OR   
   qty IS NULL OR   
   subamt1 IS NULL OR   
   discount IS NULL OR   
   subamt2 IS NULL OR   
   discountbtline IS NULL OR   
   totalbeforevat IS NULL OR   
   total IS NULL OR   
   no IS NULL OR   
   canceled IS NULL OR   
   documentid IS NULL OR   
   return_reason IS NULL OR   
   promotioncode IS NULL OR   
   avgdiscount IS NULL OR   
   ordertype IS NULL OR   
   approverstatus IS NULL OR   
   pricelevel IS NULL OR   
   deliverydate IS NULL OR   
   ordertime IS NULL OR   
   shipto IS NULL OR   
   billto IS NULL OR   
   deliveryrouteid IS NULL OR   
   approved_date IS NULL OR   
   approved_time IS NULL OR   
   paymenttype IS NULL OR   
   filename IS NULL OR   
   run_id IS NULL OR   
   crt_dttm IS NULL) OR  
  (canceled NOT IN ('Y', 'N')) OR  
  (NOT TRY_CAST(qty AS NUMBER) > 0) OR  
  (NOT TRY_CAST(subamt1 AS NUMBER) > 0) OR  
  (NOT TRY_CAST(discount AS NUMBER) >= 0) OR  
  (NOT TRY_CAST(subamt2 AS NUMBER) >= 0) OR  
  (NOT TRY_CAST(discountbtline AS NUMBER) <= 0) OR  
  (NOT TRY_CAST(totalbeforevat AS NUMBER) >= 0) OR  
  (NOT TRY_CAST(total AS NUMBER) >= 0) OR  
  (totalbeforevat + discountbtline != total) OR  
  (TRIM(custome...

The query is truncated due to length constraints, but it should include all conditions for checking data consistency, type mismatch, and logical errors in the dataset. Ensure that each condition is adjusted to reflect realistic constraints and business rules specific to the dataset.
========================================================================================================================================

sql
table_name: SDL_MDS_PH_DISTRIBUTOR_PRODUCT
solution: Validate that 'distcode_id' should not be negative, ensure 'promostartperiod' is before 'promoendperiod', and check for missing 'enterusername'.
snowflake query: 
SELECT * 
FROM SDL_MDS_PH_DISTRIBUTOR_PRODUCT 
WHERE distcode_id < 0 
   OR promostartperiod > promoendperiod 
   OR enterusername IS NULL;
========================================================================================================================================

Certainly! Below is the solution following your specified format:

**Table Name:** SDL_MDS_PH_LAV_CUSTOMER  
**Solution:** Identify and handle anomalies such as null or inconsistent values in key columns, duplicate entries, and invalid data ranges.  
**Snowflake Query:**

sql
-- Query to detect NULL values in important columns
SELECT *
FROM SDL_MDS_PH_LAV_CUSTOMER
WHERE 
    PROVINCECODE_CODE IS NULL OR
    REGIONCODE_CODE IS NULL OR
    CHANNELCODE_CODE IS NULL OR
    LASTCHGUSERNAME IS NULL OR
    ENTERDATETIME IS NULL;

-- Query to detect duplicate entries based on a unique identifier
SELECT MUID, COUNT(*)
FROM SDL_MDS_PH_LAV_CUSTOMER
GROUP BY MUID
HAVING COUNT(*) > 1;

-- Query to find anomalies in latitude and longitude values
SELECT *
FROM SDL_MDS_PH_LAV_CUSTOMER
WHERE 
    LATITUDE < -90 OR LATITUDE > 90 OR
    LONGITUDE < -180 OR LONGITUDE > 180;

-- Query to find invalid data ranges or inconsistent data
SELECT *
FROM SDL_MDS_PH_LAV_CUSTOMER
WHERE 
    ENTERDATETIME > CURRENT_TIMESTAMP OR
    LASTCHGDATETIME < ENTERDATETIME;


**Note:** The queries are designed to detect common anomalies like null values in critical columns, duplicates based on a unique identifier (MUID), and invalid geographical data ranges. Adjust the queries as needed based on additional business rules or data integrity constraints specific to your dataset.
========================================================================================================================================

table_name: SDL_DSTR_WOOLWORTH_INV
solution: The data contains several negative and zero values in fields where they are not expected, such as 'lt', 'om', 'soh_oms', 'demand_oms', etc. These values need to be checked and corrected as per business logic. Ensure non-negative values where applicable and validate business rules for each column.
snowflake_query: 
SELECT *
FROM SDL_DSTR_WOOLWORTH_INV
WHERE TRY_TO_NUMBER(lt) < 0
   OR TRY_TO_NUMBER(om) < 0
   OR TRY_TO_NUMBER(soh_oms) < 0
   OR TRY_TO_NUMBER(demand_oms) < 0
   OR TRY_TO_NUMBER(soh_price) < 0
   OR TRY_TO_NUMBER(issues_oms) < 0
   OR TRY_TO_NUMBER(total_wholesale_demand_om) < 0
   OR TRY_TO_NUMBER(soo_oms) < 0
   OR TRY_TO_NUMBER(overlay_oms) < 0
   OR TRY_TO_NUMBER(awd_oms) < 0
   OR TRY_TO_NUMBER(dos_oms) < 0
   OR TRY_TO_NUMBER(cons_days_oos) < 0
   OR TRY_TO_NUMBER(oos_28_days) < 0;
========================================================================================================================================

table_name: SDL_MDS_PH_CLOBOTICS_SOS_REF
solution: Identify and address the following anomalies:
1. Inconsistent `versionflag` (Inactive vs. Active) within the same `version_id`.
2. `validationstatus` is set to 'Invalid' for all entries, suggesting potential data quality issues.
3. `changetrackingmask` is set to 0 for some records, possibly indicating missing change tracking.

snowflake query: 
SELECT 
    version_id, 
    COUNT(DISTINCT versionflag) AS distinct_versionflags,
    COUNT(CASE WHEN validationstatus = 'Invalid' THEN 1 END) AS invalid_count,
    COUNT(CASE WHEN changetrackingmask = 0 THEN 1 END) AS zero_trackingmask_count
FROM SDL_MDS_PH_CLOBOTICS_SOS_REF
GROUP BY version_id
HAVING 
    distinct_versionflags > 1 
    OR invalid_count > 0 
    OR zero_trackingmask_count > 0;


This solution identifies anomalies related to inconsistent version flags, uniformly invalid validation statuses, and zero change tracking masks. The query groups by `version_id` to detect anomalies at that level and uses HAVING to filter groups with issues.
========================================================================================================================================

markdown
table_name: SDL_MDS_PH_GT_CUSTOMER
solution: The table metadata and sample data indicate potential anomalies such as missing data, inconsistent data types, or outliers in numeric fields. To detect these anomalies, run queries to check for NULLs, unexpected data types, and outliers.
snowflake query: 
-- Check for NULL values across all columns
SELECT 
    COUNT(*) AS total_rows,
    COUNT(CASE WHEN id IS NULL THEN 1 END) AS null_id,
    COUNT(CASE WHEN muid IS NULL THEN 1 END) AS null_muid,
    COUNT(CASE WHEN versionname IS NULL THEN 1 END) AS null_versionname,
    COUNT(CASE WHEN versionnumber IS NULL THEN 1 END) AS null_versionnumber,
    COUNT(CASE WHEN version_id IS NULL THEN 1 END) AS null_version_id,
    COUNT(CASE WHEN versionflag IS NULL THEN 1 END) AS null_versionflag,
    COUNT(CASE WHEN name IS NULL THEN 1 END) AS null_name,
    COUNT(CASE WHEN code IS NULL THEN 1 END) AS null_code,
    COUNT(CASE WHEN changetrackingmask IS NULL THEN 1 END) AS null_changetrackingmask,
    COUNT(CASE WHEN salesman IS NULL THEN 1 END) AS null_salesman,
    COUNT(CASE WHEN salesmandesc IS NULL THEN 1 END) AS null_salesmandesc,
    COUNT(CASE WHEN reportgroup2 IS NULL THEN 1 END) AS null_reportgroup2,
    COUNT(CASE WHEN reportgroup2desc IS NULL THEN 1 END) AS null_reportgroup2desc,
    COUNT(CASE WHEN reportgroup3 IS NULL THEN 1 END) AS null_reportgroup3,
    COUNT(CASE WHEN reportgroup3desc IS NULL THEN 1 END) AS null_reportgroup3desc,
    COUNT(CASE WHEN reportgroup4_code IS NULL THEN 1 END) AS null_reportgroup4_code,
    COUNT(CASE WHEN reportgroup4_name IS NULL THEN 1 END) AS null_reportgroup4_name,
    COUNT(CASE WHEN reportgroup4_id IS NULL THEN 1 END) AS null_reportgroup4_id,
    COUNT(CASE WHEN reportgroup5 IS NULL THEN 1 END) AS null_reportgroup5,
    COUNT(CASE WHEN reportgroup5desc IS NULL THEN 1 END) AS null_reportgroup5desc,
    COUNT(CASE WHEN reportgroup6 IS NULL THEN 1 END) AS null_reportgroup6,
    COUNT(CASE WHEN reportgroup6desc IS NULL THEN 1 END) AS null_reportgroup6desc,
    COUNT(CASE WHEN status IS NULL THEN 1 END) AS null_status,
    COUNT(CASE WHEN address IS NULL THEN 1 END) AS null_address,
    COUNT(CASE WHEN zip IS NULL THEN 1 END) AS null_zip,
    COUNT(CASE WHEN slmgrpcode IS NULL THEN 1 END) AS null_slmgrpcode,
    COUNT(CASE WHEN frequencyvisit IS NULL THEN 1 END) AS null_frequencyvisit,
    COUNT(CASE WHEN storeprioritization IS NULL THEN 1 END) AS null_storeprioritization,
    COUNT(CASE WHEN latitude IS NULL THEN 1 END) AS null_latitude,
    COUNT(CASE WHEN longitude IS NULL THEN 1 END) AS null_longitude,
    COUNT(CASE WHEN reportgroup9_code IS NULL THEN 1 END) AS null_reportgroup9_code,
    COUNT(CASE WHEN reportgroup9_name IS NULL THEN 1 END) AS null_reportgroup9_name,
    COUNT(CASE WHEN reportgroup9_id IS NULL THEN 1 END) AS null_reportgroup9_id,
    COUNT(CASE WHEN reportgroup11_code IS NULL THEN 1 END) AS null_reportgroup11_code,
    COUNT(CASE WHEN reportgroup11_name IS NULL THEN 1 END) AS null_reportgroup11_name,
    COUNT(CASE WHEN reportgroup11_id IS NULL THEN 1 END) AS null_reportgroup11_id,
    COUNT(CASE WHEN sdtrct_code IS NULL THEN 1 END) AS null_sdtrct_code,
    COUNT(CASE WHEN sdtrct_name IS NULL THEN 1 END) AS null_sdtrct_name,
    COUNT(CASE WHEN sdtrct_id IS NULL THEN 1 END) AS null_sdtrct_id,
    COUNT(CASE WHEN distcode_code IS NULL THEN 1 END) AS null_distcode_code,
    COUNT(CASE WHEN distcode_name IS NULL THEN 1 END) AS null_distcode_name,
    COUNT(CASE WHEN distcode_id IS NULL THEN 1 END) AS null_distcode_id,
    COUNT(CASE WHEN reportgroup15desc IS NULL THEN 1 END) AS null_reportgroup15desc,
    COUNT(CASE WHEN enterdatetime IS NULL THEN 1 END) AS null_enterdatetime,
    COUNT(CASE WHEN enterusername IS NULL THEN 1 END) AS null_enterusername,
    COUNT(CASE WHEN enterversionnumber IS NULL THEN 1 END) AS null_enterversionnumber,
    COUNT(CASE WHEN lastchgdatetime IS NULL THEN 1 END) AS null_lastchgdatetime,
    COUNT(CASE WHEN lastchgusername IS NULL THEN 1 END) AS null_lastchgusername,
    COUNT(CASE WHEN lastchgversionnumber IS NULL THEN 1 END) AS null_lastchgversionnumber,
    COUNT(CASE WHEN validationstatus IS NULL THEN 1 END) AS null_validationstatus,
    COUNT(CASE WHEN zipcode_code IS NULL THEN 1 END) AS null_zipcode_code,
    COUNT(CASE WHEN zipcode_name IS NULL THEN 1 END) AS null_zipcode_name,
    COUNT(CASE WHEN zipcode_id IS NULL THEN 1 END) AS null_zipcode_id,
    COUNT(CASE WHEN barangaycode_code IS NULL THEN 1 END) AS null_barangaycode_code,
    COUNT(CASE WHEN barangaycode_name IS NULL THEN 1 END) AS null_barangaycode_name,
    COUNT(CASE WHEN barangaycode_id IS NULL THEN 1 END) AS null_barangaycode_id,
    COUNT(CASE WHEN longlatsource IS NULL THEN 1 END) AS null_longlatsource
FROM SDL_MDS_PH_GT_CUSTOMER;

-- Check for outliers in numeric columns
SELECT 
    MIN(changetrackingmask) AS min_changetrackingmask, 
    MAX(changetrackingmask) AS max_changetrackingmask, 
    MIN(versionnumber) AS min_versionnumber, 
    MAX(versionnumber) AS max_versionnumber,
    MIN(version_id) AS min_version_id, 
    MAX(version_id) AS max_version_id,
    MIN(reportgroup4_id) AS min_reportgroup4_id, 
    MAX(reportgroup4_id) AS max_reportgroup4_id,
    MIN(reportgroup9_id) AS min_reportgroup9_id, 
    MAX(reportgroup9_id) AS max_reportgroup9_id,
    MIN(reportgroup11_id) AS min_reportgroup11_id, 
    MAX(reportgroup11_id) AS max_reportgroup11_id,
    MIN(distcode_id) AS min_distcode_id, 
    MAX(distcode_id) AS max_distcode_id,
    MIN(barangaycode_id) AS min_barangaycode_id, 
    MAX(barangaycode_id) AS max_barangaycode_id
FROM SDL_MDS_PH_GT_CUSTOMER;
========================================================================================================================================

table_name: SDL_MDS_PH_POS_CUSTOMERS
solution: Detect null or empty values in critical columns and ensure valid data types and constraints are adhered to. Handle outliers and incorrect data by implementing appropriate data validation and correction strategies.
snowflake query: 
SELECT * 
FROM SDL_MDS_PH_POS_CUSTOMERS 
WHERE 
    address1 IS NULL OR address2 IS NULL OR 
    ae_nm IS NULL OR area_cd IS NULL OR 
    area_nm IS NULL OR ash_nm IS NULL OR 
    ash_no IS NULL OR barangaycode_code IS NULL OR 
    barangaycode_id IS NULL OR barangaycode_name IS NULL OR 
    bp IS NULL OR branchno IS NULL OR 
    brnch_cd IS NULL OR brnch_grp1 IS NULL OR 
    brnch_grp2 IS NULL OR brnch_nm IS NULL OR 
    changetrackingmask IS NULL OR chnl IS NULL OR 
    chnl_sub_grp_cd IS NULL OR city_cd IS NULL OR 
    city_nm IS NULL OR class IS NULL OR 
    code IS NULL OR cust_cd IS NULL OR 
    da_tag IS NULL OR data_compln_status IS NULL OR 
    derived_branchno IS NULL OR dizr_tag IS NULL OR 
    dsm IS NULL OR dt_opnd IS NULL OR 
    enterdatetime IS NULL OR enterusername IS NULL OR 
    enterversionnumber IS NULL OR id IS NULL OR 
    jj_chnl_cd IS NULL OR jj_ship_to IS NULL OR 
    jj_sold_to IS NULL OR lastchgdatetime IS NULL OR 
    lastchgusername IS NULL OR lastchgversionnumber IS NULL OR 
    latitude IS NULL OR longitude IS NULL OR 
    longlatsource IS NULL OR mdctag IS NULL OR 
    mncplty_cd_code IS NULL OR mncplty_cd_id IS NULL OR 
    mncplty_cd_name IS NULL OR muid IS NULL OR 
    name IS NULL OR operating_hrs IS NULL OR 
    outlet_typ IS NULL OR pmr IS NULL OR 
    pms_nm IS NULL OR prefix IS NULL OR 
    prov_cd_code IS NULL OR prov_cd_id IS NULL OR 
    prov_cd_name IS NULL OR prov_cd2 IS NULL OR 
    region_cd_code IS NULL OR region_cd_id IS NULL OR 
    region_cd_name IS NULL OR region_nm IS NULL OR 
    route IS NULL OR sales_grp IS NULL OR 
    salesmantag IS NULL OR status IS NULL OR 
    store_clsfn IS NULL OR store_mtrx IS NULL OR 
    store_mtrx_cd IS NULL OR store_size IS NULL OR 
    store_size_cd IS NULL OR store_tin_no IS NULL OR 
    store_typ_cd IS NULL OR store_typ_desc IS NULL OR 
    tsr IS NULL OR validationstatus IS NULL OR 
    version_id IS NULL OR versionflag IS NULL OR 
    versionname IS NULL OR versionnumber IS NULL OR 
    wsman IS NULL OR zipcode_code IS NULL OR 
    zipcode_id IS NULL OR zipcode_name IS NULL OR 
    gsb IS NULL OR area IS NULL OR 
    format IS NULL;
========================================================================================================================================

table_name: SDL_MDS_VN_CUSTOMER_SEGMENTATION
solution: 
1. Negative IDs and changetrackingmask values should be corrected to positive values as IDs should be unique positive identifiers and changetrackingmask should be tracked accurately.
2. Inactive version flags should be reviewed for relevancy and updated to active if necessary.
3. Validation status should be corrected to 'valid' if the data is accurate and complete.

snowflake query: 
SELECT *
FROM SDL_MDS_VN_CUSTOMER_SEGMENTATION
WHERE id < 0
   OR changetrackingmask < 0
   OR versionflag = 'inactive'
   OR validationstatus = 'invalid';
========================================================================================================================================

table_name: SDL_IG_INVENTORY_DATA
solution: The sample data seems to be empty, which is an anomaly. Verify data loading processes and check for data availability issues. Ensure that the ETL process is correctly populating the table.
snowflake query: 
SELECT * 
FROM SDL_IG_INVENTORY_DATA 
WHERE inv_dt IS NULL 
AND state IS NULL 
AND ware_house IS NULL 
AND pe_item_no IS NULL 
AND item_description IS NULL 
AND stock_details_promo_ind IS NULL 
AND stock_details_vendor IS NULL 
AND stock_details_vendor_description IS NULL 
AND stock_details_sub_vendor IS NULL 
AND stock_details_lead_time IS NULL 
AND stock_details_buyer_number IS NULL 
AND stock_details_buyer_name IS NULL 
AND stock_details_stock_control_email IS NULL 
AND stock_details_soh IS NULL 
AND stock_details_soo IS NULL 
AND stock_details_awd IS NULL 
AND stock_details_weeks_cover IS NULL 
AND inbound_ordered_cases IS NULL 
AND inbound_received_cases IS NULL 
AND inbound_po_number IS NULL 
AND item_details_item_sub_range_code IS NULL 
AND item_details_item_sub_range_description IS NULL 
AND item_details_pack_size IS NULL 
AND item_details_buying_master_pack IS NULL 
AND item_details_retail_unit IS NULL 
AND item_details_buy_in_pallet IS NULL 
AND item_details_ti IS NULL 
AND item_details_hi IS NULL 
AND item_details_pallet IS NULL 
AND item_details_item_status IS NULL 
AND item_details_delete_code IS NULL 
AND item_details_deletion_date IS NULL 
AND item_details_metcash_item_type IS NULL 
AND item_details_ord_split_cat_code IS NULL 
AND item_details_ndc_item IS NULL 
AND item_details_imported_goods IS NULL 
AND item_details_code_date IS NULL 
AND item_details_packed_on_date IS NULL 
AND item_details_incremental_days IS NULL 
AND item_details_max_shelf_days IS NULL 
AND item_details_receiving_limit IS NULL 
AND item_details_dispatch_limit IS NULL 
AND item_details_current_dd IS NULL 
AND item_details_date_added_to_og IS NULL 
AND item_details_consumer_gtin IS NULL 
AND item_details_inner_gtin IS NULL 
AND item_details_outer_gtin IS NULL 
AND sales_week_6 IS NULL 
AND sales_week_5 IS NULL 
AND sales_week_4 IS NULL 
AND sales_week_3 IS NULL 
AND sales_week_2 IS NULL 
AND sales_week_1 IS NULL 
AND sales_this_week IS NULL 
AND create_dt IS NULL 
AND file_name IS NULL;
========================================================================================================================================

table_name: SDL_LA_GT_ROUTE_DETAIL_TEMP
solution: Identify discrepancies such as duplicate hashkeys, missing or unexpected timestamps, and data type mismatches. To resolve, ensure unique constraints on hashkeys, validate date formats, and establish data type consistency.
snowflake query: 
SELECT 
    HASHKEY, 
    COUNT(*) AS COUNT 
FROM 
    SDL_LA_GT_ROUTE_DETAIL_TEMP 
GROUP BY 
    HASHKEY 
HAVING 
    COUNT > 1;

SELECT 
    * 
FROM 
    SDL_LA_GT_ROUTE_DETAIL_TEMP 
WHERE 
    CRT_DTTM IS NULL 
    OR FILE_UPLOAD_DATE IS NULL 
    OR NOT TRY_TO_TIMESTAMP(CRT_DTTM) 
    OR NOT TRY_TO_DATE(FILE_UPLOAD_DATE);

SELECT 
    * 
FROM 
    SDL_LA_GT_ROUTE_DETAIL_TEMP 
WHERE 
    TYPEOF(CREATED_DATE) != 'TEXT' 
    OR TYPEOF(FILE_UPLOAD_DATE) != 'DATE' 
    OR TYPEOF(CRT_DTTM) != 'TIMESTAMP_NTZ';
========================================================================================================================================

sql
table_name : SDL_MDS_PH_POS_PRICELIST
solution : Identify and correct anomalies such as invalid YEARMO format, negative pricing values, and mismatched STATUS_CODE and STATUS_NAME.
snowflake query : 
SELECT *
FROM SDL_MDS_PH_POS_PRICELIST
WHERE 
  YEARMO NOT LIKE '%-%' OR
  TRY_TO_NUMBER(SUBSTR(YEARMO, 6, 2)) > 12 OR
  LISTPRICECASE < 0 OR
  LISTPRICEDZ < 0 OR
  LISTPRICEUNIT < 0 OR
  SRP < 0 OR
  (STATUS_CODE = 'A' AND STATUS_NAME != 'Active') OR
  (STATUS_CODE = 'I' AND STATUS_NAME != 'Inactive');
========================================================================================================================================

table_name: PRODBU_PRODUCTBUSINESSUNIT
solution: Identify anomalies such as inconsistent data types, missing values, or unexpected data patterns. For instance, check for non-numeric values in fields expected to be numeric, or dates that are not in the expected range. Ensure referential integrity and data consistency across related fields.
snowflake query: 
SELECT 
    *
FROM 
    PRODBU_PRODUCTBUSINESSUNIT
WHERE 
    (TRY_TO_NUMBER(FETCHEDSEQUENCE) IS NULL AND FETCHEDSEQUENCE IS NOT NULL) OR 
    (TRY_TO_NUMBER(MAXIMUMORDERQUANTITY) IS NULL AND MAXIMUMORDERQUANTITY IS NOT NULL) OR 
    (TRY_TO_DATE(FETCHEDDATETIME) IS NULL AND FETCHEDDATETIME IS NOT NULL) OR 
    (TRY_TO_DATE(AZUREDATETIME) IS NULL AND AZUREDATETIME IS NOT NULL) OR 
    (TRY_TO_DATE(CDL_DATETIME) IS NULL AND CDL_DATETIME IS NOT NULL) OR 
    ISLISTED NOT IN ('Yes', 'No') OR 
    ISORDERABLE NOT IN ('Yes', 'No') OR 
    ISRETURNABLE NOT IN ('Yes', 'No') OR
    (PRODUCTID IS NULL OR PRODUCTID = '') OR 
    (BUSINESSUNITID IS NULL OR BUSINESSUNITID = '');
========================================================================================================================================

table_name: SDL_AU_DSTR_CHS_HEADER  
solution: Some numeric fields are stored as TEXT, which can cause data type issues. Convert these fields to appropriate numeric types.  
snowflake query: 
SELECT 
    TRY_TO_NUMBER(LAST_COST) AS LAST_COST_NUMERIC,
    TRY_TO_NUMBER(SOH_QTY) AS SOH_QTY_NUMERIC,
    TRY_TO_NUMBER(SOH_AMT) AS SOH_AMT_NUMERIC,
    TRY_TO_NUMBER(SOO_QTY) AS SOO_QTY_NUMERIC,
    TRY_TO_NUMBER(SOO_AMT) AS SOO_AMT_NUMERIC,
    TRY_TO_NUMBER(BACK_ORDER_QTY) AS BACK_ORDER_QTY_NUMERIC,
    TRY_TO_NUMBER(MONTH_01) AS MONTH_01_NUMERIC,
    TRY_TO_NUMBER(MONTH_02) AS MONTH_02_NUMERIC,
    TRY_TO_NUMBER(MONTH_03) AS MONTH_03_NUMERIC,
    TRY_TO_NUMBER(MONTH_04) AS MONTH_04_NUMERIC,
    TRY_TO_NUMBER(MONTH_05) AS MONTH_05_NUMERIC,
    TRY_TO_NUMBER(MONTH_06) AS MONTH_06_NUMERIC,
    TRY_TO_NUMBER(MONTH_07) AS MONTH_07_NUMERIC,
    TRY_TO_NUMBER(MONTH_08) AS MONTH_08_NUMERIC,
    TRY_TO_NUMBER(MONTH_09) AS MONTH_09_NUMERIC,
    TRY_TO_NUMBER(MONTH_10) AS MONTH_10_NUMERIC,
    TRY_TO_NUMBER(MONTH_11) AS MONTH_11_NUMERIC,
    TRY_TO_NUMBER(MONTH_12) AS MONTH_12_NUMERIC
FROM SDL_AU_DSTR_CHS_HEADER
WHERE 
    TRY_TO_NUMBER(LAST_COST) IS NULL OR
    TRY_TO_NUMBER(SOH_QTY) IS NULL OR
    TRY_TO_NUMBER(SOH_AMT) IS NULL OR
    TRY_TO_NUMBER(SOO_QTY) IS NULL OR
    TRY_TO_NUMBER(SOO_AMT) IS NULL OR
    TRY_TO_NUMBER(BACK_ORDER_QTY) IS NULL OR
    TRY_TO_NUMBER(MONTH_01) IS NULL OR
    TRY_TO_NUMBER(MONTH_02) IS NULL OR
    TRY_TO_NUMBER(MONTH_03) IS NULL OR
    TRY_TO_NUMBER(MONTH_04) IS NULL OR
    TRY_TO_NUMBER(MONTH_05) IS NULL OR
    TRY_TO_NUMBER(MONTH_06) IS NULL OR
    TRY_TO_NUMBER(MONTH_07) IS NULL OR
    TRY_TO_NUMBER(MONTH_08) IS NULL OR
    TRY_TO_NUMBER(MONTH_09) IS NULL OR
    TRY_TO_NUMBER(MONTH_10) IS NULL OR
    TRY_TO_NUMBER(MONTH_11) IS NULL OR
    TRY_TO_NUMBER(MONTH_12) IS NULL;
========================================================================================================================================

table_name: SDL_AU_DSTR_API_HEADER
solution: There are negative values in columns that typically should not have them, such as sales quantities, cost prices, and stock quantities. This might indicate data entry errors or incorrect calculations. Ensure data validation rules are in place to prevent negative entries where not logical.
snowflake_query: 
SELECT *
FROM SDL_AU_DSTR_API_HEADER
WHERE CAST(MTH_TOTAL_INVOICED_QTY AS NUMBER) < 0
   OR CAST(SOH_QTY AS NUMBER) < 0
   OR CAST(COST_PRICE AS NUMBER) < 0
   OR CAST(MONTH_01 AS NUMBER) < 0
   OR CAST(MONTH_02 AS NUMBER) < 0
   OR CAST(MONTH_03 AS NUMBER) < 0
   OR CAST(MONTH_04 AS NUMBER) < 0
   OR CAST(MONTH_05 AS NUMBER) < 0
   OR CAST(MONTH_06 AS NUMBER) < 0
   OR CAST(MONTH_07 AS NUMBER) < 0
   OR CAST(MONTH_08 AS NUMBER) < 0
   OR CAST(MONTH_09 AS NUMBER) < 0
   OR CAST(MONTH_10 AS NUMBER) < 0
   OR CAST(MONTH_11 AS NUMBER) < 0
   OR CAST(MONTH_12 AS NUMBER) < 0
   OR CAST(MONTH_13 AS NUMBER) < 0
   OR CAST(DC_SOO_QTY AS NUMBER) < 0
   OR CAST(SO_BACKORDER_QTY AS NUMBER) < 0;
========================================================================================================================================

table_name: SDL_CSL_DAILYSALES
solution: The sample data indicates several anomalies, such as negative `MRP`, zero values for quantities and amounts where they should logically be non-zero, and a `salnetamt` that is negative due to total deductions exceeding total additions and sales gross amount. These anomalies suggest data integrity and validation issues.

snowflake_query: 
SELECT *
FROM SDL_CSL_DAILYSALES
WHERE 
  MRP < 0
  OR salgrossamt <= 0
  OR salnetamt < 0
  OR prdqty <= 0
  OR prdselratebeforetax < 0
  OR prdselrateaftertax < 0
  OR salinvlinecount = 0
  OR migrationflag = 'Y'
  OR uploadflag = 'N';


This query identifies records with negative or zero values in critical fields like `MRP`, `salgrossamt`, `salnetamt`, and checks for anomalies in flag columns. The solution involves implementing data validation rules to prevent such anomalies during data insertion or update.
========================================================================================================================================

table_name: SDL_CSL_ORDERBOOKING
solution: Check for missing or NULL values in critical columns, validate numeric data for negative or zero values where inappropriate, and ensure dates are logically consistent (e.g., order date before delivery date).
snowflake query: 
SELECT 
    ORDERNO, ORDERDATE, ORDDLVDATE, ALLOWBACKORDER, ORDTYPE, 
    ORDPRIORITY, ORDDOCREF, REMARKS, ROUNDOFFAMT, ORDTOTALAMT, 
    SALESMANCODE, SALESMANNAME, SALESROUTECODE, SALESROUTENAME, 
    RTRID, RTRCODE, RTRNAME, PRDCODE, PRDBATCDE, PRDQTY, 
    PRDBILLEDQTY, PRDSELRATE, PRDGROSSAMT, UPLOADFLAG, RECORDDATE, 
    CREATEDDATE, SYNCID, RECOMMENDEDSKU, RUN_ID, CRT_DTTM, FILE_NAME
FROM SDL_CSL_ORDERBOOKING
WHERE 
    ORDERDATE IS NULL OR ORDDLVDATE IS NULL OR 
    ORDERDATE > ORDDLVDATE OR 
    PRDQTY <= 0 OR PRDBILLEDQTY <= 0 OR 
    PRDSELRATE < 0 OR PRDGROSSAMT < 0 OR 
    ROUNDOFFAMT < 0 OR ORDTOTALAMT < 0;
========================================================================================================================================

table_name: SDL_CSL_RETAILERMASTER
solution: The sample data for all columns is empty, indicating potential data loading issues or missing records. Verify the data source, ETL processes, and ensure data is being populated correctly in the table.
snowflake query: 
SELECT 
    RTRID, 
    RTRCODE, 
    RTRNAME, 
    RTRCATLEVELID, 
    RTRCATEGORYCODE, 
    CLASSCODE, 
    KEYACCOUNT, 
    REGDATE, 
    RELATIONSTATUS, 
    PARENTCODE, 
    GEOLEVEL, 
    GEOLEVELVALUE, 
    STATUS, 
    CREATEDID, 
    CREATEDDATE, 
    RTRADDRESS1, 
    RTRADDRESS2, 
    RTRADDRESS3, 
    RTRPINCODE 
FROM 
    SDL_CSL_RETAILERMASTER 
WHERE 
    RTRID IS NULL 
    OR RTRCODE IS NULL 
    OR RTRNAME IS NULL 
    OR STATUS IS NULL 
    OR CREATEDID IS NULL 
    OR CREATEDDATE IS NULL 
    OR RTRADDRESS1 IS NULL 
    OR RTRPINCODE IS NULL;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_OUTLET_MASTER
solution: Identify missing or inconsistent data in key columns and ensure data integrity by adding constraints or validation checks.
snowflake query: 
SELECT 
    COUNT(*) AS total_records,
    COUNT(DISTINCT distributorcode) AS unique_distributors,
    SUM(CASE WHEN distributorcode IS NULL OR distributorcode = '' THEN 1 ELSE 0 END) AS missing_distributorcode,
    SUM(CASE WHEN usercode IS NULL OR usercode = '' THEN 1 ELSE 0 END) AS missing_usercode,
    SUM(CASE WHEN locationcode IS NULL OR locationcode = '' THEN 1 ELSE 0 END) AS missing_locationcode,
    SUM(CASE WHEN outletcode IS NULL OR outletcode = '' THEN 1 ELSE 0 END) AS missing_outletcode,
    SUM(CASE WHEN outletname IS NULL OR outletname = '' THEN 1 ELSE 0 END) AS missing_outletname,
    SUM(CASE WHEN channelcode IS NULL OR channelcode = '' THEN 1 ELSE 0 END) AS missing_channelcode,
    SUM(CASE WHEN credit_limit < 0 OR credit_period < 0 OR invoice_limit < 0 THEN 1 ELSE 0 END) AS invalid_credit_values
FROM SDL_DISTRIBUTOR_IVY_OUTLET_MASTER;
========================================================================================================================================

table_name : SDL_KR_COUPANG_BPA_REPORT
solution : Identify negative values in metrics where they shouldn't occur and ensure positive values. Verify data source and rectify any data entry or processing errors.
snowflake query : 
SELECT * FROM SDL_KR_COUPANG_BPA_REPORT 
WHERE CAST(CLICK_COUNT AS INTEGER) < 0 
OR CAST(CTR AS FLOAT) < 0 
OR CAST(IMPRESSION_COUNT AS INTEGER) < 0 
OR CAST(TOTAL_AD_RETURN_1D AS FLOAT) < 0 
OR CAST(DIRECT_AD_RETURN_1D AS FLOAT) < 0 
OR CAST(INDIRECT_AD_RETURN_1D AS FLOAT) < 0 
OR CAST(TOTAL_AD_RETURN_14D AS FLOAT) < 0 
OR CAST(DIRECT_AD_RETURN_14D AS FLOAT) < 0 
OR CAST(INDIRECT_AD_RETURN_14D AS FLOAT) < 0;
========================================================================================================================================

sql
table_name: SDL_MDS_VN_POS_PRODUCTS
solution: Detect and address duplicate MUIDs and missing CODE values.
snowflake query: 
SELECT 
    muid, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_MDS_VN_POS_PRODUCTS
GROUP BY 
    muid
HAVING 
    duplicate_count > 1;

SELECT 
    *
FROM 
    SDL_MDS_VN_POS_PRODUCTS
WHERE 
    code IS NULL;
========================================================================================================================================

table_name: SDL_GCCH_CUST_HIER
solution: Identify potential anomalies such as missing values, duplicate entries, incorrect data types, and outliers. Validate data integrity and consistency.
snowflake query: 
SELECT *
FROM SDL_GCCH_CUST_HIER
WHERE
    -- Check for missing essential values
    (tamr_id IS NULL OR origin_source_name IS NULL OR origin_entity_id IS NULL OR unique_id IS NULL OR region IS NULL OR customer IS NULL OR country IS NULL) OR
    -- Check for duplicate entries based on unique identifier
    unique_id IN (
        SELECT unique_id
        FROM SDL_GCCH_CUST_HIER
        GROUP BY unique_id
        HAVING COUNT(*) > 1
    ) OR
    -- Check for incorrect data types or format (e.g., postal_code should be numeric)
    NOT TRY_TO_NUMBER(postal_code) IS NOT NULL OR
    -- Check for outliers in numerical fields
    suggestedclassificationscore NOT BETWEEN 0 AND 100 OR
    -- Any additional domain-specific business logic validation
    finalclassificationpath IS NULL;
========================================================================================================================================

table_name: SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN
solution: Check for missing or null values, duplicate entries, and consistency in data types.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    COUNT(DISTINCT sl_no) AS unique_sl_no,
    SUM(CASE WHEN sls_rep_cd_nm IS NULL THEN 1 ELSE 0 END) AS missing_sls_rep_cd_nm,
    SUM(CASE WHEN sls_rep_cd IS NULL THEN 1 ELSE 0 END) AS missing_sls_rep_cd,
    SUM(CASE WHEN sls_rep_nm IS NULL THEN 1 ELSE 0 END) AS missing_sls_rep_nm,
    SUM(CASE WHEN store_cd IS NULL THEN 1 ELSE 0 END) AS missing_store_cd,
    SUM(CASE WHEN store_nm IS NULL THEN 1 ELSE 0 END) AS missing_store_nm,
    SUM(CASE WHEN store_class IS NULL THEN 1 ELSE 0 END) AS missing_store_class,
    SUM(CASE WHEN week IS NULL THEN 1 ELSE 0 END) AS missing_week,
    SUM(CASE WHEN day IS NULL THEN 1 ELSE 0 END) AS missing_day,
    SUM(CASE WHEN period IS NULL THEN 1 ELSE 0 END) AS missing_period
FROM SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN;
========================================================================================================================================

table_name: SDL_MDS_MY_PRODUCT_MASTER
solution: Several anomalies such as negative values in columns where they shouldn't be (e.g., negative product dimensions and prices). Implement data validation checks to ensure only valid data entries are allowed. Create constraints to prevent negative values where inappropriate.
snowflake query: 
SELECT * 
FROM SDL_MDS_MY_PRODUCT_MASTER
WHERE "qty-shipper/pallet" < 0 
   OR "qty-dz/pallet" < 0 
   OR "CARTON_PRICE" < 0 
   OR "product_dimension-l_(mm)" < 0 
   OR "product_dimension-h_(mm)" < 0 
   OR "product_weight" < 0 
   OR "LIST_PRICE" < 0 
   OR "bnd-list_price" < 0 
   OR "bn-duty" < 0 
   OR "qty-shrink_wrap_(pc)" < 0 
   OR "shelf_life_(years)" < 0 
   OR "trade_margin_%" < 0 
   OR "shipper_dimension-h_(mm)" < 0;
========================================================================================================================================

table_name: SDL_LA_GT_ROUTE_HEADER
solution: Check for NULL or missing values, ensure data type consistency, and validate logical constraints like unique route_id and correct date formats. Address anomalies by imputing missing values, enforcing constraints, and correcting data types.
snowflake query: 
SELECT 
    route_id, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_LA_GT_ROUTE_HEADER
GROUP BY 
    route_id
HAVING 
    COUNT(*) > 1
UNION ALL
SELECT 
    'Missing route_id' AS route_id, 
    COUNT(*) AS missing_count
FROM 
    SDL_LA_GT_ROUTE_HEADER
WHERE 
    route_id IS NULL
UNION ALL
SELECT 
    'Invalid date' AS route_id, 
    COUNT(*) AS invalid_date_count
FROM 
    SDL_LA_GT_ROUTE_HEADER
WHERE 
    TRY_TO_TIMESTAMP(crt_dttm) IS NULL OR TRY_TO_DATE(file_upload_date) IS NULL
UNION ALL
SELECT 
    'Inactive routes' AS route_id, 
    COUNT(*) AS inactive_count
FROM 
    SDL_LA_GT_ROUTE_HEADER
WHERE 
    is_active = 'N';
========================================================================================================================================

table_name : SDL_ID_POS_DAILY_IDM_SELLOUT
solution : Detect anomalies in data such as duplicate entries, missing values, incorrect data types, and out-of-range values.
snowflake query : 
WITH anomalies AS (
    SELECT 
        account, kode_branch, branch_name, tgl, plu, descp, type, value, pos_cust, yearmonth, run_id, crtd_dttm, filename,
        ROW_NUMBER() OVER (PARTITION BY account, kode_branch, branch_name, tgl, plu ORDER BY crtd_dttm DESC) AS row_num,
        CASE 
            WHEN account IS NULL THEN 'Missing account'
            WHEN kode_branch IS NULL THEN 'Missing kode_branch'
            WHEN branch_name IS NULL THEN 'Missing branch_name'
            WHEN tgl IS NULL OR TRY_TO_DATE(tgl, 'YYYY-MM-DD') IS NULL THEN 'Invalid or missing tgl'
            WHEN plu IS NULL THEN 'Missing plu'
            WHEN descp IS NULL THEN 'Missing descp'
            WHEN type IS NULL OR type NOT IN ('A', 'B', 'C') THEN 'Invalid or missing type'
            WHEN value IS NULL OR value < 0 THEN 'Invalid or missing value'
            WHEN pos_cust IS NULL THEN 'Missing pos_cust'
            WHEN yearmonth IS NULL OR LENGTH(yearmonth) <> 6 THEN 'Invalid or missing yearmonth'
            WHEN run_id IS NULL THEN 'Missing run_id'
            WHEN crtd_dttm IS NULL THEN 'Missing crtd_dttm'
            WHEN filename IS NULL THEN 'Missing filename'
            ELSE NULL
        END AS anomaly_reason
    FROM SDL_ID_POS_DAILY_IDM_SELLOUT
)
SELECT * 
FROM anomalies
WHERE row_num > 1 OR anomaly_reason IS NOT NULL;
========================================================================================================================================

table_name : SDL_KR_COUPANG_PA_REPORT
solution : The data types for numeric columns are set as TEXT, which can lead to data processing inefficiencies and potential errors in calculations. Convert these columns to appropriate numeric types.
snowflake query : 
ALTER TABLE SDL_KR_COUPANG_PA_REPORT 
MODIFY COLUMN CLICK_COUNT NUMBER, 
MODIFY COLUMN AD_COST NUMBER, 
MODIFY COLUMN CTR FLOAT, 
MODIFY COLUMN TOTAL_ORDERS_1D NUMBER, 
MODIFY COLUMN DIRECT_ORDERS_1D NUMBER, 
MODIFY COLUMN INDIRECT_ORDERS_1D NUMBER, 
MODIFY COLUMN TOTAL_SALES_1D NUMBER, 
MODIFY COLUMN DIRECT_SALES_QUANTITY_1D NUMBER, 
MODIFY COLUMN INDIRECT_SALES_QUANTITY_1D NUMBER, 
MODIFY COLUMN TOTAL_CONVERSION_SALES_1D NUMBER, 
MODIFY COLUMN DIRECT_CONVERSION_SALES_1D NUMBER, 
MODIFY COLUMN INDIRECT_CONVERSION_SALES_1D NUMBER, 
MODIFY COLUMN TOTAL_ORDERS_14D NUMBER, 
MODIFY COLUMN DIRECT_ORDERS_14D NUMBER, 
MODIFY COLUMN INDIRECT_ORDERS_14D NUMBER, 
MODIFY COLUMN TOTAL_SALES_14D NUMBER, 
MODIFY COLUMN DIRECT_SALES_QUANTITY_14D NUMBER, 
MODIFY COLUMN INDIRECT_SALES_QUANTITY_14D NUMBER, 
MODIFY COLUMN TOTAL_CONVERSION_SALES_14D NUMBER, 
MODIFY COLUMN DIRECT_CONVERSION_SALES_14D NUMBER, 
MODIFY COLUMN INDIRECT_CONVERSION_SALES_14D NUMBER, 
MODIFY COLUMN TOTAL_AD_RETURN_1D NUMBER, 
MODIFY COLUMN DIRECT_AD_RETURN_1D NUMBER, 
MODIFY COLUMN INDIRECT_AD_RETURN_1D NUMBER, 
MODIFY COLUMN TOTAL_AD_RETURN_14D NUMBER, 
MODIFY COLUMN DIRECT_AD_RETURN_14D NUMBER, 
MODIFY COLUMN INDIRECT_AD_RETURN_14D NUMBER, 
MODIFY COLUMN IMPRESSION_COUNT NUMBER;
========================================================================================================================================

table_name: SDL_MDS_PH_NON_ISE_WEIGHTS
solution: The weight values should not be negative. Check for negative weights and recommend a review of business logic or data entry processes.
snowflake_query: 
SELECT *
FROM SDL_MDS_PH_NON_ISE_WEIGHTS
WHERE WEIGHT < 0;
========================================================================================================================================

sql
table_name: SDL_CSL_SALESRETURN
solution: Negative values detected in columns that typically should have non-negative values such as quantities and amounts. Recommend verifying data entry processes and applying constraints to prevent such entries.
snowflake query: 
SELECT *
FROM SDL_CSL_SALESRETURN
WHERE 
    srngrossamt < 0 OR 
    srnspldiscamt < 0 OR 
    srnschdiscamt < 0 OR 
    srncashdiscamt < 0 OR 
    srndbdiscamt < 0 OR 
    srntaxamt < 0 OR 
    srnroundoffamt < 0 OR 
    srnnetamt < 0 OR 
    prdsalqty < 0 OR 
    prdunsalqty < 0 OR 
    prdofferqty < 0 OR 
    prdgrossamt < 0 OR 
    prdspldiscamt < 0 OR 
    prdschdiscamt < 0 OR 
    prdcashdiscamt < 0 OR 
    prddbdiscamt < 0 OR 
    prdtaxamt < 0 OR 
    prdnetamt < 0 OR 
    mrp < 0 OR 
    rtnfreeqtyvalue < 0 OR 
    rtnlinecount < 0 OR 
    nrvalue < 0 OR 
    prdselrateaftertax < 0;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_INVOICE
solution: Detect anomalies such as negative invoice amounts, missing or zero quantities, invalid date formats, and discrepancies between calculated line values and invoice amounts. Implement data validation and cleansing procedures to address these issues.
snowflake_query: 
    SELECT 
        INVOICE_NO, 
        CASE 
            WHEN INVOICE_AMOUNT < 0 THEN 'Negative Invoice Amount'
            WHEN QTY IS NULL OR QTY = 0 THEN 'Missing/Zero Quantity'
            WHEN INVOICE_DATE IS NULL THEN 'Missing Invoice Date'
            WHEN PIECE_PRICE * QTY != LINE_VALUE THEN 'Line Value Discrepancy'
            ELSE NULL 
        END AS Anomaly_Description
    FROM SDL_DISTRIBUTOR_IVY_INVOICE
    WHERE INVOICE_AMOUNT < 0 
        OR QTY IS NULL 
        OR QTY = 0 
        OR INVOICE_DATE IS NULL 
        OR PIECE_PRICE * QTY != LINE_VALUE;
========================================================================================================================================

table_name: SDL_ECOM_BACKMARGIN
solution: Identify missing or unexpected data patterns across the table.
snowflake query: 
WITH anomalies AS (
  SELECT 
    ORDERSN, 
    SHOP_ID, 
    SELLER_USERNAME, 
    SKU_ID, 
    BUNDLE_ORD_ITMID, 
    PRODUCT_ID, 
    ITM_NAME, 
    MODEL_ID, 
    MODEL_NAME, 
    PURCHASED_TIME, 
    CATEGORY, 
    SUB_CATEGORY, 
    BE_STATUS, 
    SELLER_VOUCHER, 
    PLATFORM_VOUCHER, 
    QUANTITY, 
    FLASH_SALE, 
    FREE_SHIPPING_REBATE, 
    SHOPEE_VOUCHER_REBATE, 
    SELLER_VOUCHER_REBATE, 
    PLATFORM_VOUCHER_SELLER_REBATE, 
    PLATFORM_VOUCHER_SHOPEE_REBATE, 
    COIN_EARN, 
    COIN_USED, 
    SPECIFIC_PURCHASE_TIME, 
    COGS_PER_QUANTITY, 
    PRICE_BEFORE_DISCOUNT, 
    ITEM_PRICE, 
    PERCENT_DISCOUNT, 
    PROMOTION_ID, 
    SHIPPING_CARRIER, 
    BUNDLE_ID, 
    ACTUAL_SHIPPING_FEE, 
    BUYER_SHIPPING_FEE, 
    ADD_ON_DEAL_ID, 
    IS_ADD_ON_SUB_ITEM, 
    BACKMARGIN_CFS, 
    BACKMARGIN_NORMAL, 
    BACKMARGIN_BUNDLE, 
    BACKMARGIN_ADDON, 
    BACKMARGIN_SHIPPING, 
    SELLER_VOUCHER_COIN_EARN, 
    PLATFORM_VOUCHER_COIN_EARN, 
    SUPPLIER_ID, 
    SUPPLIERNAME, 
    NMV, 
    BUNDLE_RULE_TYPE, 
    BUNDLE_RULE_VALUE, 
    ITEM_BRAND, 
    IS_EXCLUSIVE_PRICE, 
    ORDER_VALUE, 
    IS_NEW_BUYER_PRICE, 
    IS_LIVE_ORDER, 
    ESCROW_PAID_DATE, 
    CRTD_DTTM, 
    FILENAME
  FROM SDL_ECOM_BACKMARGIN
  WHERE 
    ORDERSN IS NULL OR 
    SHOP_ID IS NULL OR 
    SELLER_USERNAME IS NULL OR 
    SKU_ID IS NULL OR 
    BUNDLE_ORD_ITMID IS NULL OR 
    PRODUCT_ID IS NULL OR 
    ITM_NAME IS NULL OR 
    MODEL_ID IS NULL OR 
    MODEL_NAME IS NULL OR 
    PURCHASED_TIME IS NULL OR 
    CATEGORY IS NULL OR 
    SUB_CATEGORY IS NULL OR 
    BE_STATUS IS NULL OR 
    SELLER_VOUCHER IS NULL OR 
    PLATFORM_VOUCHER IS NULL OR 
    QUANTITY IS NULL OR 
    FLASH_SALE IS NULL OR 
    FREE_SHIPPING_REBATE IS NULL OR 
    SHOPEE_VOUCHER_REBATE IS NULL OR 
    SELLER_VOUCHER_REBATE IS NULL OR 
    PLATFORM_VOUCHER_SELLER_REBATE IS NULL OR 
    PLATFORM_VOUCHER_SHOPEE_REBATE IS NULL OR 
    COIN_EARN IS NULL OR 
    COIN_USED IS NULL OR 
    SPECIFIC_PURCHASE_TIME IS NULL OR 
    COGS_PER_QUANTITY IS NULL OR 
    PRICE_BEFORE_DISCOUNT IS NULL OR 
    ITEM_PRICE IS NULL OR 
    PERCENT_DISCOUNT IS NULL OR 
    PROMOTION_ID IS NULL OR 
    SHIPPING_CARRIER IS NULL OR 
    BUNDLE_ID IS NULL OR 
    ACTUAL_SHIPPING_FEE IS NULL OR 
    BUYER_SHIPPING_FEE IS NULL OR 
    ADD_ON_DEAL_ID IS NULL OR 
    IS_ADD_ON_SUB_ITEM IS NULL OR 
    BACKMARGIN_CFS IS NULL OR 
    BACKMARGIN_NORMAL IS NULL OR 
    BACKMARGIN_BUNDLE IS NULL OR 
    BACKMARGIN_ADDON IS NULL OR 
    BACKMARGIN_SHIPPING IS NULL OR 
    SELLER_VOUCHER_COIN_EARN IS NULL OR 
    PLATFORM_VOUCHER_COIN_EARN IS NULL OR 
    SUPPLIER_ID IS NULL OR 
    SUPPLIERNAME IS NULL OR 
    NMV IS NULL OR 
    BUNDLE_RULE_TYPE IS NULL OR 
    BUNDLE_RULE_VALUE IS NULL OR 
    ITEM_BRAND IS NULL OR 
    IS_EXCLUSIVE_PRICE IS NULL OR 
    ORDER_VALUE IS NULL OR 
    IS_NEW_BUYER_PRICE IS NULL OR 
    IS_LIVE_ORDER IS NULL OR 
    ESCROW_PAID_DATE IS NULL OR 
    CRTD_DTTM IS NULL OR 
    FILENAME IS NULL 
)
SELECT * FROM anomalies;
========================================================================================================================================

table_name: SDL_ECOM_COGS
solution: Detect and handle NULL or missing values in crucial columns, check for outliers in numerical columns, and validate data types.
snowflake query: 
-- Identify columns with NULL values
SELECT 
    'plant', COUNT(*) AS null_count FROM SDL_ECOM_COGS WHERE plant IS NULL
UNION ALL
SELECT 
    'mat_type', COUNT(*) AS null_count FROM SDL_ECOM_COGS WHERE mat_type IS NULL
UNION ALL
SELECT 
    'proc_type', COUNT(*) AS null_count FROM SDL_ECOM_COGS WHERE proc_type IS NULL
UNION ALL
SELECT 
    'profit_center', COUNT(*) AS null_count FROM SDL_ECOM_COGS WHERE profit_center IS NULL
UNION ALL
SELECT 
    'total_cost', COUNT(*) AS null_count FROM SDL_ECOM_COGS WHERE total_cost IS NULL
UNION ALL
SELECT 
    'std_cost', COUNT(*) AS null_count FROM SDL_ECOM_COGS WHERE std_cost IS NULL;

-- Check for negative or zero values in columns where it doesn't make logical sense
SELECT 
    * 
FROM 
    SDL_ECOM_COGS 
WHERE 
    total_cost <= 0 OR std_cost <= 0 OR labour < 0 OR raw_pack < 0;

-- Validate data types and detect anomalies
SELECT 
    material_no, 
    CASE WHEN TRY_CAST(total_cost AS NUMBER) IS NULL THEN 'Invalid' ELSE 'Valid' END AS total_cost_validation,
    CASE WHEN TRY_CAST(std_cost AS NUMBER) IS NULL THEN 'Invalid' ELSE 'Valid' END AS std_cost_validation
FROM 
    SDL_ECOM_COGS;
========================================================================================================================================

table_name: SDL_MDS_MY_ECOM_PRODUCT
solution: Identify and rectify negative IDs and version numbers, ensure unique MUIDs, and address negative change tracking masks.
snowflake query: 
SELECT *
FROM SDL_MDS_MY_ECOM_PRODUCT
WHERE id < 0 
   OR versionnumber < 0 
   OR muid IS NULL 
   OR changetrackingmask < 0
   OR (muid IS NOT NULL AND muid IN (
         SELECT muid
         FROM SDL_MDS_MY_ECOM_PRODUCT
         GROUP BY muid
         HAVING COUNT(*) > 1));
========================================================================================================================================

table_name: SDL_MDS_MY_TARGETS
solution: The metadata suggests inconsistencies with missing data in sample data. Ensure all columns have the expected data type and not NULL where not applicable. Check for missing entries and data consistency between related columns.
snowflake query: 
SELECT 
    *
FROM 
    SDL_MDS_MY_TARGETS
WHERE
    ID IS NULL OR
    MUID IS NULL OR
    VERSIONNAME IS NULL OR
    VERSIONNUMBER IS NULL OR
    VERSION_ID IS NULL OR
    VERSIONFLAG IS NULL OR
    NAME IS NULL OR
    CODE IS NULL OR
    CHANGETRACKINGMASK IS NULL OR
    SOLD_TO IS NULL OR
    CUSTOMER IS NULL OR
    BRAND IS NULL OR
    SUBSEGMENT IS NULL OR
    YEAR_CODE IS NULL OR
    YEAR_NAME IS NULL OR
    YEAR_ID IS NULL OR
    TYPE_CODE IS NULL OR
    TYPE_NAME IS NULL OR
    TYPE_ID IS NULL OR
    TARGET_MEASURE_NAME_CODE IS NULL OR
    TARGET_MEASURE_NAME_NAME IS NULL OR
    TARGET_MEASURE_NAME_ID IS NULL OR
    JAN IS NULL OR
    FEB IS NULL OR
    MAR IS NULL OR
    APR IS NULL OR
    MAY IS NULL OR
    JUN IS NULL OR
    JUL IS NULL OR
    AUG IS NULL OR
    SEP IS NULL OR
    OCT IS NULL OR
    NOV IS NULL OR
    DEC IS NULL OR
    ENTERDATETIME IS NULL OR
    ENTERUSERNAME IS NULL OR
    ENTERVERSIONNUMBER IS NULL OR
    LASTCHGDATETIME IS NULL OR
    LASTCHGUSERNAME IS NULL OR
    LASTCHGVERSIONNUMBER IS NULL OR
    VALIDATIONSTATUS IS NULL;
========================================================================================================================================

table_name: SDL_LA_GT_SELLOUT_FACT
solution: Detect anomalies by identifying negative values in `totalbeforevat`, `avgdiscount`, and `iscancel` not being a boolean. Also, verify consistency in `orderdate` with `crt_dttm`.
snowflake_query: 
SELECT * 
FROM SDL_LA_GT_SELLOUT_FACT 
WHERE totalbeforevat < 0 
   OR avgdiscount < 0 
   OR iscancel NOT IN (0, 1)
   OR CAST(orderdate AS DATE) != CAST(crt_dttm AS DATE);
========================================================================================================================================

table_name: SDL_MDS_SG_ECOM_PRODUCT
solution: Detect anomalies where 'VERSIONFLAG' is inconsistent with 'VALIDATIONSTATUS', and check date-time consistency between 'ENTERDATETIME' and 'LASTCHGDATETIME'.
snowflake query: 
SELECT * 
FROM SDL_MDS_SG_ECOM_PRODUCT
WHERE 
  (VERSIONFLAG = 'active' AND VALIDATIONSTATUS = 'invalid') OR 
  (VERSIONFLAG = 'inactive' AND VALIDATIONSTATUS = 'valid') OR
  ENTERDATETIME > LASTCHGDATETIME;
========================================================================================================================================

table_name: SDL_MY_CUSTOMER_DIM
solution: Identified potential anomalies in 'ullage' and 'trdng_term_val' with negative values, 'rdd_ind' inconsistent status, and 'cdl_dttm' having non-date values. Suggest data validation checks and cleansing for these fields.

snowflake query:
SELECT 
    cust_id, 
    cust_nm, 
    dstrbtr_grp_cd, 
    dstrbtr_grp_nm, 
    ullage, 
    chnl, 
    territory, 
    retail_env, 
    trdng_term_val, 
    rdd_ind, 
    cdl_dttm, 
    curr_dt, 
    file_name 
FROM 
    SDL_MY_CUSTOMER_DIM
WHERE 
    TRY_TO_NUMBER(ullage) < 0 OR 
    TRY_TO_NUMBER(trdng_term_val) < 0 OR 
    rdd_ind NOT IN ('Y', 'N') OR 
    TRY_TO_DATE(cdl_dttm, 'YYYY-MM-DD') IS NULL;
========================================================================================================================================

table_name: SDL_MY_AFGR
solution: 
- Check for negative financial amounts which may indicate incorrect data entries.
- Identify records with invalid SC validation status.
- Look for missing or null customer names and bill numbers.

snowflake query: 
SELECT 
    * 
FROM 
    SDL_MY_AFGR
WHERE 
    CAST(CN_AMT AS FLOAT) < 0 OR 
    CAST(AFGR_AMT AS FLOAT) < 0 OR 
    CAST(DN_AMT_EXC_GST_VAL AS FLOAT) < 0 OR 
    SC_VALIDATION = 'Invalid' OR 
    CUST_NM IS NULL OR 
    BILL_NUM IS NULL;
========================================================================================================================================

table_name: SDL_HK_WINGKEUNG_INDIRECT_SALES_REP_ROUTE_PLAN
solution: 
1. Check for negative values in the 'PERIOD' column as it should generally represent a positive time period.
2. Ensure 'VISIT_FREQ' and 'PERIOD' are within reasonable limits (e.g., non-negative).
3. Validate consistency in relationships, such as ensuring 'SLS_REP_CD' and 'SLS_REP_CD_NM' match appropriately.
4. Ensure non-empty and valid 'STORE_CD' and 'STORE_NM'.

snowflake query: 
SELECT 
    * 
FROM 
    SDL_HK_WINGKEUNG_INDIRECT_SALES_REP_ROUTE_PLAN 
WHERE 
    PERIOD < 0 
    OR VISIT_FREQ < 0 
    OR STORE_CD IS NULL 
    OR STORE_NM IS NULL 
    OR SLS_REP_CD IS NULL 
    OR SLS_REP_CD_NM IS NULL 
    OR LENGTH(SLS_REP_CD) != 6 
    OR LENGTH(SLS_REP_CD_NM) < 4;
========================================================================================================================================

table_name : DAILYSALES
solution : Identify and handle negative or zero values in key metrics such as `salnetamt`, `prdfreeqty`, and `prdnetamt`. Review entries with `uploadflag` set to 'N'.
snowflake query : 
SELECT *
FROM DAILYSALES
WHERE salnetamt <= 0 
   OR prdfreeqty < 0 
   OR prdnetamt <= 0 
   OR uploadflag = 'N';
========================================================================================================================================

table_name: SDL_MDS_SG_PRODUCT_MAPPING
solution: Detect and address negative version numbers and ensure unique constraints on IDs.
snowflake_query: 
SELECT * 
FROM SDL_MDS_SG_PRODUCT_MAPPING
WHERE versionnumber < 0 
   OR id IS NULL 
   OR muid IS NULL 
   OR versionname IS NULL 
   OR code IS NULL 
   OR changetrackingmask IS NULL 
   OR customer_name_code IS NULL 
   OR customer_name_name IS NULL 
   OR customer_name_id IS NULL 
   OR customer_brand_code IS NULL 
   OR customer_brand_name IS NULL 
   OR customer_brand_id IS NULL 
   OR customer_product_code IS NULL 
   OR customer_product_name IS NULL 
   OR "material code" IS NULL 
   OR "master code" IS NULL 
   OR "product name" IS NULL 
   OR enterdatetime IS NULL 
   OR enterusername IS NULL 
   OR enterversionnumber IS NULL 
   OR lastchgdatetime IS NULL 
   OR lastchgusername IS NULL 
   OR lastchgversionnumber IS NULL 
   OR validationstatus IS NULL;
========================================================================================================================================

sql
table_name: PRODTR_PRODUCTTRANSLATION
solution: Identify and correct the NULL values in 'PRODUCTTRANSLATIONNAME' and ensure dates are consistent across related fields.
snowflake query: 
SELECT * 
FROM PRODTR_PRODUCTTRANSLATION 
WHERE PRODUCTTRANSLATIONNAME IS NULL 
   OR CDL_DATETIME != AZUREDATETIME 
   OR CDL_DATETIME != FETCHEDDATETIME;
========================================================================================================================================

table_name: SDL_LA_GT_SALES_ORDER_FACT_TEMP
solution: The anomalies in the data include negative quantity (qty), unusual payment type (Bitcoin), and missing entries in the dataset. For the negative quantity, validate the data source for errors or apply a business rule to handle such entries. For unusual payment types, review if this is acceptable or needs verification. Address missing entries by ensuring complete data capture and integrity checks.
snowflake query: 
SELECT 
    orderid, 
    customer_id, 
    qty, 
    paymenttype, 
    orderdate, 
    deliverydate 
FROM 
    SDL_LA_GT_SALES_ORDER_FACT_TEMP 
WHERE 
    qty < 0 
    OR paymenttype NOT IN ('Cash', 'Credit Card', 'Debit Card', 'Bank Transfer') 
    OR orderdate IS NULL 
    OR customer_id IS NULL;
========================================================================================================================================

sql
table_name: SDL_ECOM_SEARCH_ADS_BY_CHANNEL
solution: Identify and address any missing or inconsistent data patterns to ensure data integrity and consistency.
snowflake query: 
SELECT 
    TIME_PERIOD, CHANNEL, REGION, SHOP_NAME, SHOP_ID, TERMINAL,
    SALES_USD, SALES_LCY, ORDERS, UNITS_SOLD, VISITS, UNIQUE_VISITORS,
    ADD_TO_CART_UNITS, ADD_TO_CART_VALUE_USD, ADD_TO_CART_VALUE_LCY,
    BUYERS, NEW_BUYERS, ITEM_CONVERSION_RATE, CRTD_DTTM, FILENAME
FROM SDL_ECOM_SEARCH_ADS_BY_CHANNEL
WHERE 
    SALES_USD IS NULL 
    OR SALES_LCY IS NULL 
    OR ORDERS < 0 
    OR UNITS_SOLD < 0 
    OR VISITS < 0 
    OR UNIQUE_VISITORS < 0 
    OR ADD_TO_CART_UNITS < 0 
    OR ADD_TO_CART_VALUE_USD < 0 
    OR ADD_TO_CART_VALUE_LCY < 0 
    OR BUYERS < 0 
    OR NEW_BUYERS < 0 
    OR ITEM_CONVERSION_RATE < 0 
    OR CRTD_DTTM IS NULL 
    OR FILENAME IS NULL;
========================================================================================================================================

table_name: SDL_MDS_APAC_DCL_TARGETS
solution: Identify missing or NULL values in critical columns and ensure data consistency across related fields. Validate numerical fields for realistic values.
snowflake query: 
SELECT 
    *
FROM 
    SDL_MDS_APAC_DCL_TARGETS
WHERE 
    ID IS NULL
    OR MUID IS NULL
    OR VERSIONNAME IS NULL
    OR VERSIONNUMBER IS NULL
    OR VERSION_ID IS NULL
    OR VERSIONFLAG IS NULL
    OR NAME IS NULL
    OR CODE IS NULL
    OR TARGET_TYPE_CODE IS NULL
    OR TARGET_TYPE_NAME IS NULL
    OR TARGET_TYPE_ID IS NULL
    OR COUNTRY_CODE IS NULL
    OR COUNTRY_NAME IS NULL
    OR COUNTRY_ID IS NULL
    OR SALES_CHANNEL_CODE IS NULL
    OR SALES_CHANNEL_NAME IS NULL
    OR SALES_CHANNEL_ID IS NULL
    OR YEAR_CODE IS NULL
    OR YEAR_NAME IS NULL
    OR YEAR_ID IS NULL
    OR JAN < 0
    OR FEB < 0
    OR MAR < 0
    OR APR < 0
    OR MAY < 0
    OR JUN < 0
    OR JUL < 0
    OR AUG < 0
    OR SEP < 0
    OR OCT < 0
    OR NOV < 0
    OR DEC < 0;


This query checks for NULL values in critical text fields and ensures that numerical fields (such as month columns) do not contain negative values, indicating potential data entry errors or anomalies.
========================================================================================================================================

table_name: SDL_ALL_DISTRIBUTOR_SELLOUT_SALES_FACT
solution: The data contains negative sales quantities (SLS_QTY) which may indicate returns or data entry errors. Ensure that negative values are intentional and properly accounted for. Validate data entry processes and consider implementing constraints or checks to prevent unintended negative entries.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_ALL_DISTRIBUTOR_SELLOUT_SALES_FACT 
WHERE 
    SLS_QTY < 0;
========================================================================================================================================

table_name: SDL_GCPH_BRAND
solution: 
1. Check for records with zero or negative weight, volume, or dimensions.
2. Ensure unique IDs and material numbers are unique and not null.
3. Verify dates are within expected ranges.
4. Check for missing or null critical fields like 'origin_entity_id', 'product', 'material_type'.

snowflake query: 
WITH potential_anomalies AS (
    SELECT 
        *,
        CASE 
            WHEN gross_weight <= 0 THEN 'Invalid Gross Weight'
            WHEN net_weight <= 0 THEN 'Invalid Net Weight'
            WHEN width < 0 OR length < 0 OR height < 0 THEN 'Invalid Dimensions'
            WHEN volume < 0 THEN 'Invalid Volume'
            WHEN unique_id IS NULL OR unique_id = '' THEN 'Missing Unique ID'
            WHEN material_number IS NULL OR material_number = '' THEN 'Missing Material Number'
            WHEN dateofextract IS NULL OR dateofextract = '' OR TRY_TO_TIMESTAMP(dateofextract) IS NULL THEN 'Invalid Date of Extract'
            WHEN cdl_datetime IS NULL OR cdl_datetime = '' OR TRY_TO_TIMESTAMP(cdl_datetime) IS NULL THEN 'Invalid CDL Datetime'
            WHEN origin_entity_id IS NULL OR origin_entity_id = '' THEN 'Missing Origin Entity ID'
            WHEN product IS NULL OR product = '' THEN 'Missing Product'
            WHEN material_type IS NULL OR material_type = '' THEN 'Missing Material Type'
            ELSE NULL
        END AS anomaly_type
    FROM SDL_GCPH_BRAND
)
SELECT * FROM potential_anomalies
WHERE anomaly_type IS NOT NULL;
========================================================================================================================================

table_name: SDL_CBD_GT_SALES_REPORT_FACT_TEMP
solution: 
1. Negative values in 'sales_qty', 'foc_qty', 'net_price', and 'net_sales' fields indicate potential errors in data entry or return transactions not being flagged correctly. Validate entries and ensure return transactions are properly managed.
2. Check for expired products by comparing 'billing_date' with 'expiry_date'. Ensure no transactions occur after expiry.

snowflake query: 
SELECT * 
FROM SDL_CBD_GT_SALES_REPORT_FACT_TEMP
WHERE sales_qty < 0 
   OR foc_qty < 0 
   OR net_price < 0 
   OR net_sales < 0 
   OR billing_date > expiry_date;
========================================================================================================================================

table_name: SDL_DAILYSALES_DEL
solution: 
1. Check for negative or zero quantities and amounts where they should be positive (e.g., `salinvlinecount` should not be negative).
2. Ensure `prdqty`, `prdfreeqty`, and similar fields are non-negative.
3. Validate that `salnetamt`, `prdnetamt`, and other net amounts are correct based on deductions and additions.
4. Verify that timestamps are logical and consistent, e.g., `createddate` should be before `modifieddate`.
5. Ensure `syncid` is non-zero and positive for valid records.

snowflake query: 
SELECT * 
FROM SDL_DAILYSALES_DEL 
WHERE 
    salinvlinecount < 0 OR 
    prdqty < 0 OR 
    prdfreeqty < 0 OR 
    salnetamt < 0 OR 
    prdnetamt < 0 OR 
    prdgrossamt < 0 OR 
    createddate > modifieddate OR 
    syncid <= 0;
========================================================================================================================================

table_name: SDL_MDS_VN_POS_CUSTOMERS
solution: Identify and address inconsistencies in the 'versionflag' and 'status' fields, and ensure that timestamps are in the expected order. Validate NULL values in critical fields.
snowflake query: 
SELECT 
    id, 
    muid, 
    versionflag, 
    status, 
    enterdatetime, 
    lastchgdatetime,
    name, 
    code, 
    note_closed_store, 
    store_name, 
    store_name_2, 
    customer_name
FROM 
    SDL_MDS_VN_POS_CUSTOMERS
WHERE 
    (versionflag NOT IN ('active', 'inactive') OR status NOT IN ('Active', 'Inactive'))
    OR (enterdatetime > lastchgdatetime)
    OR (name IS NULL OR customer_name IS NULL OR note_closed_store IS NULL)
    OR (store_name != store_name_2)
    OR (changetrackingmask != versionnumber);
========================================================================================================================================

table_name: SDL_MDS_VN_PRICE_PRODUCTS
solution: 
1. Negative or Zero `pc_per_case` values should be reviewed and corrected.
2. Ensure `id` column values are positive and unique.
3. Validate that all `price` values are positive.

snowflake query: 
SELECT * 
FROM SDL_MDS_VN_PRICE_PRODUCTS 
WHERE pc_per_case <= 0 
   OR id <= 0 
   OR price <= 0;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_PRODUCT_MAPPING_COLES
solution: Detect anomalies in the version numbers, such as negative values, nulls in important columns like 'jnj_sap_code', and mismatch in version-related fields.
snowflake_query: 
SELECT 
    *
FROM 
    SDL_MDS_PACIFIC_PRODUCT_MAPPING_COLES
WHERE 
    versionnumber < 0 
    OR version_id < 0
    OR jnj_sap_code IS NULL
    OR enterversionnumber <> versionnumber
    OR lastchgversionnumber < versionnumber
========================================================================================================================================

table_name: ITG_SFA_PM
solution: Identify and handle missing or invalid data, such as NULL values in essential columns and invalid file paths or names.
snowflake query: 
SELECT * FROM ITG_SFA_PM
WHERE 
  filename LIKE 'invalid_file_name%' OR
  path LIKE '/invalid/%' OR
  brand IS NULL OR
  customername IS NULL OR 
  salesperson_firstname IS NULL OR 
  salesperson_lastname IS NULL OR
  salescampaignname IS NULL OR
  mastertaskname IS NULL;
========================================================================================================================================

table_name: SDL_AU_DSTR_SIGMA_HEADER
solution: 
1. Convert numeric columns to their appropriate data types for accurate calculations.
2. Validate negative values in stock-related columns and ensure they are logically correct.
3. Review handling status and ensure consistent categorization.
4. Verify if back order quantities and amounts should logically be zero or negative.
snowflake query: 
SELECT 
    warehouse_desc, 
    product_code, 
    product_desc, 
    TRY_CAST(cost_price AS NUMBER) AS cost_price, 
    TRY_CAST(soh_qty AS NUMBER) AS soh_qty, 
    TRY_CAST(soh_amt AS NUMBER) AS soh_amt, 
    TRY_CAST(stock_in_transit_qty AS NUMBER) AS stock_in_transit_qty, 
    TRY_CAST(stock_in_transit_amt AS NUMBER) AS stock_in_transit_amt, 
    TRY_CAST(restricted_stock_qty AS NUMBER) AS restricted_stock_qty, 
    TRY_CAST(restricted_stock_amt AS NUMBER) AS restricted_stock_amt, 
    TRY_CAST(soo_qty AS NUMBER) AS soo_qty, 
    TRY_CAST(soo_amt AS NUMBER) AS soo_amt, 
    TRY_CAST(back_order_qty AS NUMBER) AS back_order_qty, 
    TRY_CAST(back_order_amt AS NUMBER) AS back_order_amt 
FROM SDL_AU_DSTR_SIGMA_HEADER
WHERE 
    TRY_CAST(cost_price AS NUMBER) IS NULL 
    OR TRY_CAST(soh_qty AS NUMBER) < 0 
    OR TRY_CAST(soh_amt AS NUMBER) > 0 
    OR TRY_CAST(stock_in_transit_qty AS NUMBER) < 0 
    OR TRY_CAST(stock_in_transit_amt AS NUMBER) > 0 
    OR TRY_CAST(restricted_stock_qty AS NUMBER) > 0 
    OR TRY_CAST(restricted_stock_amt AS NUMBER) < 0 
    OR TRY_CAST(soo_qty AS NUMBER) < 0 
    OR TRY_CAST(soo_amt AS NUMBER) < 0 
    OR TRY_CAST(back_order_qty AS NUMBER) > 0 
    OR TRY_CAST(back_order_amt AS NUMBER) > 0;
========================================================================================================================================

table_name : SDL_CBD_GT_SALES_REPORT_FACT
solution : Address negative 'foc_qty', ensure 'client' and 'sub_client' uniqueness, verify 'billing_date' against future dates.
snowflake query : 
SELECT 
    *
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
WHERE 
    TO_NUMBER(FOC_QTY) < 0
    OR CLIENT IN (
        SELECT CLIENT 
        FROM SDL_CBD_GT_SALES_REPORT_FACT 
        GROUP BY CLIENT 
        HAVING COUNT(*) > 1
    )
    OR SUB_CLIENT IN (
        SELECT SUB_CLIENT 
        FROM SDL_CBD_GT_SALES_REPORT_FACT 
        GROUP BY SUB_CLIENT 
        HAVING COUNT(*) > 1
    )
    OR TRY_TO_DATE(BILLING_DATE) > CURRENT_DATE();
========================================================================================================================================

sql
table_name: SDL_ECOM_GMV_SHOPEE
solution: Identify missing or zero values, detect unusually high growth rates, and check for negative values where not expected.
snowflake_query: 
SELECT 
    product_id, 
    product_name, 
    date, 
    platform, 
    filename,
    CASE WHEN gross_sales IS NULL OR gross_sales = 0 THEN 'Missing or zero gross_sales' END AS anomaly_gross_sales,
    CASE WHEN gross_sales_growth > 1000 THEN 'Unusually high gross_sales_growth' END AS anomaly_gross_sales_growth,
    CASE WHEN gross_orders IS NULL OR gross_orders = 0 THEN 'Missing or zero gross_orders' END AS anomaly_gross_orders,
    CASE WHEN gross_orders_growth > 1000 THEN 'Unusually high gross_orders_growth' END AS anomaly_gross_orders_growth,
    CASE WHEN gross_units_sold IS NULL OR gross_units_sold = 0 THEN 'Missing or zero gross_units_sold' END AS anomaly_gross_units_sold,
    CASE WHEN gross_units_sold_growth > 1000 THEN 'Unusually high gross_units_sold_growth' END AS anomaly_gross_units_sold_growth,
    CASE WHEN gross_avg_basket_size < 0 THEN 'Negative gross_avg_basket_size' END AS anomaly_gross_avg_basket_size,
    CASE WHEN gross_avg_basket_size_growth > 1000 THEN 'Unusually high gross_avg_basket_size_growth' END AS anomaly_gross_avg_basket_size_growth,
    CASE WHEN gross_item_per_order < 0 THEN 'Negative gross_item_per_order' END AS anomaly_gross_item_per_order,
    CASE WHEN gross_item_per_order_growth > 1000 THEN 'Unusually high gross_item_per_order_growth' END AS anomaly_gross_item_per_order_growth,
    CASE WHEN gross_avg_selling_price < 0 THEN 'Negative gross_avg_selling_price' END AS anomaly_gross_avg_selling_price,
    CASE WHEN gross_avg_selling_price_growth > 1000 THEN 'Unusually high gross_avg_selling_price_growth' END AS anomaly_gross_avg_selling_price_growth,
    CASE WHEN product_views IS NULL OR product_views = 0 THEN 'Missing or zero product_views' END AS anomaly_product_views,
    CASE WHEN product_views_growth > 1000 THEN 'Unusually high product_views_growth' END AS anomaly_product_views_growth,
    CASE WHEN product_visitors IS NULL OR product_visitors = 0 THEN 'Missing or zero product_visitors' END AS anomaly_product_visitors,
    CASE WHEN product_visitors_growth > 1000 THEN 'Unusually high product_visitors_growth' END AS anomaly_product_visitors_growth,
    CASE WHEN gross_order_conversion_rate < 0 THEN 'Negative gross_order_conversion_rate' END AS anomaly_gross_order_conversion_rate,
    CASE WHEN gross_order_conversion_rate_growth > 1000 THEN 'Unusually high gross_order_conversion_rate_growth' END AS anomaly_gross_order_conversion_rate_growth,
    CASE WHEN gross_item_conversion_rate < 0 THEN 'Negative gross_item_conversion_rate' END AS anomaly_gross_item_conversion_rate,
    CASE WHEN gross_item_conversion_rate_growth > 1000 THEN 'Unusually high gross_item_conversion_rate_growth' END AS anomaly_gross_item_conversion_rate_growth
FROM 
    SDL_ECOM_GMV_SHOPEE
WHERE 
    gross_sales IS NULL OR gross_sales = 0 OR 
    gross_sales_growth > 1000 OR 
    gross_orders IS NULL OR gross_orders = 0 OR 
    gross_orders_growth > 1000 OR 
    gross_units_sold IS NULL OR gross_units_sold = 0 OR 
    gross_units_sold_growth > 1000 OR 
    gross_avg_basket_size < 0 OR 
    gross_avg_basket_size_growth > 1000 OR 
    gross_item_per_order < 0 OR 
    gross_item_per_order_growth > 1000 OR 
    gross_avg_selling_price < 0 OR 
    gross_avg_selling_price_growth > 1000 OR 
    product_views IS NULL OR product_views = 0 OR 
    product_views_growth > 1000 OR 
    product_visitors IS NULL OR product_visitors = 0 OR 
    product_visitors_growth > 1000 OR 
    gross_order_conversion_rate < 0 OR 
    gross_order_conversion_rate_growth > 1000 OR 
    gross_item_conversion_rate < 0 OR 
    gross_item_conversion_rate_growth > 1000;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_OUTLET_MASTER_ADFTEMP
solution: 
1. Ensure all numeric fields are positive where applicable.
2. Validate and format the latitude and longitude values.
3. Verify the 'cdl_dttm' field for valid datetime format.
4. Ensure 'is_diamond_store' field is consistent.
5. Correct 'run_id' to be positive.
6. Ensure 'credit_limit', 'invoice_limit', and 'credit_period' are realistic and positive.
7. Confirm 'file_name' follows expected naming conventions.
snowflake query: 
SELECT * 
FROM SDL_DISTRIBUTOR_IVY_OUTLET_MASTER_ADFTEMP 
WHERE 
    credit_limit < 0 OR 
    invoice_limit < 0 OR 
    credit_period < 0 OR 
    TRY_TO_TIMESTAMP(cdl_dttm) IS NULL OR 
    (CAST(lattitude AS FLOAT) > 90 OR CAST(lattitude AS FLOAT) < -90) OR 
    (CAST(longitude AS FLOAT) > 180 OR CAST(longitude AS FLOAT) < -180) OR 
    run_id < 0 OR 
    NOT REGEXP_LIKE(is_diamond_store, '^(YES|NO)$') OR 
    NOT REGEXP_LIKE(file_name, '^file\d+\.txt$');
========================================================================================================================================

table_name: SDL_MDS_PH_ECOM_PRODUCT
solution: 
1. Check for duplicate entries based on `id`, `code`, or `muid` which should be unique.
2. Verify `versionnumber` and `version_id` for consistency and ensure they align with `versionname`.
3. Look for entries with 'inactive' status in `versionflag` but recent `lastchgdatetime`.
4. Validate `validationstatus` for any discrepancies with other columns indicating changes.

snowflake query: 
WITH DuplicateCheck AS (
    SELECT id, code, muid, COUNT(*) AS cnt
    FROM SDL_MDS_PH_ECOM_PRODUCT
    GROUP BY id, code, muid
    HAVING cnt > 1
),
VersionConsistency AS (
    SELECT *
    FROM SDL_MDS_PH_ECOM_PRODUCT
    WHERE versionnumber != version_id
),
InactiveRecentChanges AS (
    SELECT *
    FROM SDL_MDS_PH_ECOM_PRODUCT
    WHERE versionflag = 'inactive' AND lastchgdatetime > CURRENT_DATE() - INTERVAL '7 DAY'
),
ValidationDiscrepancies AS (
    SELECT *
    FROM SDL_MDS_PH_ECOM_PRODUCT
    WHERE validationstatus != 'valid'
)

SELECT * 
FROM DuplicateCheck
UNION ALL
SELECT * 
FROM VersionConsistency
UNION ALL
SELECT * 
FROM InactiveRecentChanges
UNION ALL
SELECT * 
FROM ValidationDiscrepancies;
========================================================================================================================================

table_name: SDL_MDS_MY_PS_TARGETS
solution: Check for missing or null values in critical columns such as 'id', 'muid', and 'versionnumber'. Ensure 'value' is non-negative if it represents a measurable quantity. Validate that 'enterdatetime' and 'lastchgdatetime' are not in the future. Ensure 'version_id' aligns with 'versionnumber'.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MDS_MY_PS_TARGETS 
WHERE 
    id IS NULL 
    OR muid IS NULL 
    OR versionnumber IS NULL 
    OR value < 0 
    OR enterdatetime > CURRENT_TIMESTAMP() 
    OR lastchgdatetime > CURRENT_TIMESTAMP()
    OR version_id != versionnumber;
========================================================================================================================================

table_name : SDL_POP6_SG_POPS
solution : Identify and correct invalid latitude and longitude values, ensure status values are within a valid range.
snowflake query : 
SELECT *
FROM SDL_POP6_SG_POPS
WHERE 
  (LATITUDE < -90 OR LATITUDE > 90)
  OR (LONGITUDE < -180 OR LONGITUDE > 180)
  OR (STATUS < 0 OR STATUS > 5);
========================================================================================================================================

table_name: SDL_ECOM_SEARCH_ADS_BY_DATE
solution: Identify anomalies in sales figures, buyers, and item conversion rate, which include negative values and zero values where unexpected. Implement data validation checks or business rule validations to prevent such entries.

snowflake query: 
SELECT 
    DATE, 
    REGION, 
    SHOP_NAME, 
    SHOP_ID, 
    TERMINAL, 
    SALES_USD, 
    SALES_LCY, 
    ORDERS, 
    UNITS_SOLD, 
    VISITS, 
    UNIQUE_VISITORS, 
    ADD_TO_CART_UNITS,
    ADD_TO_CART_VALUE_USD, 
    ADD_TO_CART_VALUE_LCY, 
    BUYERS, 
    NEW_BUYERS, 
    ITEM_CONVERSION_RATE, 
    CRTD_DTTM, 
    FILENAME 
FROM 
    SDL_ECOM_SEARCH_ADS_BY_DATE 
WHERE 
    SALES_USD < 0 
    OR SALES_LCY < 0 
    OR BUYERS < 0 
    OR ITEM_CONVERSION_RATE < 0 
    OR ORDERS = 0 
    OR UNITS_SOLD = 0 
    OR VISITS = 0 
    OR UNIQUE_VISITORS = 0 
    OR ADD_TO_CART_UNITS = 0 
    OR ADD_TO_CART_VALUE_USD = 0 
    OR ADD_TO_CART_VALUE_LCY = 0
========================================================================================================================================

table_name : SDL_ID_POS_CARREFOUR_STOCK
solution : Detect negative stock quantities and amounts, and ensure correct data entries. Recommend verifying source data for errors and correcting them.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_ID_POS_CARREFOUR_STOCK
WHERE 
    STOCK_QTY < 0 
    OR STOCK_AMT < 0;
========================================================================================================================================

table_name: SDL_CSL_CLASSMASTER
solution: 
1. Check for duplicates in 'pkey' and 'classid' columns, which should be unique.
2. Verify that 'availabilty' and 'turnover' are non-negative values.
3. Ensure 'createddate' and 'crt_dttm' are consistent and logical (e.g., no future dates).
4. Validate that 'file_name' follows a consistent naming convention.

snowflake query: 
WITH duplicate_check AS (
    SELECT
        pkey,
        classid,
        COUNT(*) AS count
    FROM SDL_CSL_CLASSMASTER
    GROUP BY pkey, classid
    HAVING COUNT(*) > 1
),
negative_values AS (
    SELECT
        tableid,
        pkey,
        classid,
        availabilty,
        turnover
    FROM SDL_CSL_CLASSMASTER
    WHERE availabilty < 0 OR turnover < 0
),
inconsistent_dates AS (
    SELECT
        tableid,
        pkey,
        classid,
        createddate,
        crt_dttm
    FROM SDL_CSL_CLASSMASTER
    WHERE createddate IS NULL OR crt_dttm IS NULL OR createddate > CURRENT_TIMESTAMP() OR crt_dttm > CURRENT_TIMESTAMP()
),
invalid_file_name AS (
    SELECT
        tableid,
        pkey,
        classid,
        file_name
    FROM SDL_CSL_CLASSMASTER
    WHERE file_name NOT REGEXP 'file[0-9]+\\.txt'
)
SELECT * FROM duplicate_check
UNION ALL
SELECT * FROM negative_values
UNION ALL
SELECT * FROM inconsistent_dates
UNION ALL
SELECT * FROM invalid_file_name;
========================================================================================================================================

table_name: SDL_MDS_PH_MSL_DTLS
solution: Check for duplicate entries and ensure data consistency across related fields.
snowflake_query: 
SELECT 
    ID, COUNT(*) AS cnt
FROM 
    SDL_MDS_PH_MSL_DTLS
GROUP BY 
    ID
HAVING 
    COUNT(*) > 1;

SELECT 
    ID, MUID, VERSIONNUMBER, VERSION_ID, SKU_ID, MSL_HDR_CODE_ID
FROM 
    SDL_MDS_PH_MSL_DTLS
WHERE 
    VERSIONNUMBER != VERSION_ID
    OR SKU_ID != ID
    OR MSL_HDR_CODE_ID != ID;

SELECT 
    ID, ENTERDATETIME, LASTCHGDATETIME
FROM 
    SDL_MDS_PH_MSL_DTLS
WHERE 
    ENTERDATETIME > LASTCHGDATETIME;

SELECT 
    ID, NAME, SKU_NAME
FROM 
    SDL_MDS_PH_MSL_DTLS
WHERE 
    NAME != SKU_NAME;
========================================================================================================================================

table_name: SDL_MDS_PH_ISE_WEIGHTS
solution: 
- Detect negative values in 'weight' and 'versionnumber' columns as they are likely to be anomalies.
- Identify 'inactive' versionflags with high or unusual weights.
- Check for inconsistent 'validationstatus' for active versionflags.

snowflake_query: 
SELECT 
    * 
FROM 
    SDL_MDS_PH_ISE_WEIGHTS
WHERE 
    weight < 0 
    OR versionnumber < 0 
    OR (versionflag = 'inactive' AND weight > 100) 
    OR (versionflag = 'active' AND validationstatus = 'invalid');
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_INVENTORY
solution: Detect rows with negative quantities and missing batch expiry dates, and ensure proper data validation during data entry.
snowflake query: 
SELECT * FROM SDL_DISTRIBUTOR_IVY_INVENTORY 
WHERE QTY < 0 OR BATCH_EXPIRY_DATE IS NULL;
========================================================================================================================================

sql
table_name: SDL_POP6_SG_POP_LISTS
solution: Address negative 'run_id' and ensure 'status' has valid reference. Validate 'pop_list_date' against realistic past or future dates.
snowflake query: 
SELECT * 
FROM SDL_POP6_SG_POP_LISTS 
WHERE run_id < 0 
   OR status NOT IN (SELECT DISTINCT status FROM valid_status_reference_table) 
   OR pop_list_date < '1900-01-01' 
   OR pop_list_date > CURRENT_DATE();
========================================================================================================================================

table_name : SDL_MDS_SG_PRODUCT_HIERARCHY
solution : Identify rows with identical 'id' and 'version_id' where other fields differ, indicating potential duplication or data entry errors.
snowflake query : 
SELECT *
FROM SDL_MDS_SG_PRODUCT_HIERARCHY
WHERE (id, version_id) IN (
    SELECT id, version_id
    FROM SDL_MDS_SG_PRODUCT_HIERARCHY
    GROUP BY id, version_id
    HAVING COUNT(*) > 1
)
AND (
    (name, code, brand_mapping_code, brand_mapping_name, new_category_code, new_category_name, product_type_code, product_type_name, product_variant_code, product_variant_name, validationstatus) NOT IN (
        SELECT DISTINCT name, code, brand_mapping_code, brand_mapping_name, new_category_code, new_category_name, product_type_code, product_type_name, product_variant_code, product_variant_name, validationstatus
        FROM SDL_MDS_SG_PRODUCT_HIERARCHY
    )
);
========================================================================================================================================

table_name : SDL_CLAVIS_GB_PRODUCTS
solution : Identify and address anomalies such as negative milestone values, high observed prices compared to MSRP, and overly high promo discounts.
snowflake query : 
SELECT 
    product_id,
    report_date,
    CASE 
        WHEN milestone2_comp < 0 THEN 'Negative Milestone'
        WHEN milestone6_comp < 0 THEN 'Negative Milestone'
        WHEN observed_price > msrp THEN 'Observed Price Exceeds MSRP'
        WHEN promo_discount_percent > 100 THEN 'Unusual Promo Discount'
        ELSE 'No Anomaly'
    END AS anomaly_detected
FROM SDL_CLAVIS_GB_PRODUCTS
WHERE milestone2_comp < 0 
   OR milestone6_comp < 0 
   OR observed_price > msrp 
   OR promo_discount_percent > 100;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_ORDER
solution: 
1. Detect negative values in 'qty' and 'order_value' columns.
2. Identify mismatched totals between 'line_value' and 'order_value'.
3. Check for 'order_status' inconsistencies such as 'CANCELLED' orders with non-zero 'order_value'.
4. Validate geographical coordinates for 'order_latitude' and 'order_longitude' for expected range.
5. Ensure 'delivery_date' is after 'order_date'.
snowflake query:
SELECT 
    order_id, 
    qty, 
    order_value, 
    line_value, 
    order_status, 
    order_latitude, 
    order_longitude, 
    order_date, 
    delivery_date
FROM 
    SDL_DISTRIBUTOR_IVY_ORDER
WHERE 
    qty < 0 
    OR order_value < 0 
    OR line_value != order_value 
    OR (order_status = 'CANCELLED' AND order_value != 0)
    OR order_latitude NOT BETWEEN -90 AND 90
    OR order_longitude NOT BETWEEN -180 AND 180
    OR delivery_date <= order_date;
========================================================================================================================================

table_name: SDL_ID_POS_DAILY_BASEDLINE_SELLOUT
solution: Data contains negative values and invalid dates (e.g., month 13). Review data entry processes, validate data types, and implement checks to prevent invalid data. Correct historical data to ensure accuracy.
snowflake query: 
SELECT * FROM SDL_ID_POS_DAILY_BASEDLINE_SELLOUT
WHERE 
    MONTH NOT BETWEEN 1 AND 12 OR
    YEAR < 1900 OR YEAR > 2100 OR
    PLU < 0 OR
    QTY_TRX < 0 OR
    CUM_YTM_QTY < 0 OR
    PROMO_QTY < 0 OR
    CUM_PROMO_QTY < 0 OR
    BASEDLINE_TOTAL_QTY < 0 OR
    CUM_BASEDLINE_TOTAL_QTY < 0 OR
    TOTAL_DAYS < 0 OR
    CUM_TOTAL_DAYS < 0 OR
    PROMO_DAYS < 0 OR
    CUM_PROMO_DAYS < 0 OR
    BASELINED_TOTAL_DAYS < 0 OR
    CUM_BASELINED_TOTAL_DAYS < 0 OR
    TOTAL_QTY_BASELINED < 0 OR
    INDIRECT_QTY_TRX < 0 OR
    INDIRECT_CUM_QTY < 0 OR
    INDIRECT_PROMO_QTY < 0 OR
    INDIRECT_CUM_PROMO_QTY < 0 OR
    INDIRECT_BASEDLINE_TOTAL_QTY < 0 OR
    INDIRECT_CUM_BASEDLINE_TOTAL_QTY < 0 OR
    INDIRECT_QTY_BASEDLINED < 0;
========================================================================================================================================

table_name: SDL_MDS_MY_PS_MSL
solution: Validate negative or unexpected version numbers and null values in critical columns like 'versionflag'. Address inconsistent validation statuses by ensuring data integrity.
snowflake query: 
SELECT * 
FROM SDL_MDS_MY_PS_MSL 
WHERE versionnumber < 0 
   OR enterversionnumber < 0 
   OR versionflag IS NULL 
   OR validationstatus NOT IN ('valid', 'pending', 'invalid');
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_ECOM_PRODUCT
solution: Identify negative or unusual values in columns such as 'versionnumber', 'changetrackingmask', and 'lastchgversionnumber'. Check for NULL values in critical fields like 'name', 'upc', and 'sku_name'. Ensure 'versionflag' and 'validationstatus' have valid status values.
snowflake query:
SELECT *
FROM SDL_MDS_PACIFIC_ECOM_PRODUCT
WHERE versionnumber < 0
   OR changetrackingmask < 0
   OR lastchgversionnumber < 0
   OR name IS NULL
   OR upc IS NULL
   OR sku_name IS NULL
   OR versionflag NOT IN ('inactive', 'finalized', 'archived', 'submitted')
   OR validationstatus NOT IN ('pending', 'archived', 'active', 'finalized');
========================================================================================================================================

table_name: SDL_MDS_PH_POS_PRODUCT
solution: 
1. Missing or null values in critical columns like `id`, `muid`, `versionname`, `versionnumber`, `version_id` can lead to data integrity issues. Ensure these fields are populated.
2. Data type mismatches such as `NUMBER` fields containing non-numeric data should be corrected.
3. Duplicate entries based on unique constraints like `id` or `code` should be identified and removed.
4. Timestamps such as `enterdatetime` and `lastchgdatetime` should be logical and not in the future.
5. Ensure `barcode` fields are valid and conform to expected formats.

snowflake query:
sql
SELECT *
FROM SDL_MDS_PH_POS_PRODUCT
WHERE 
    id IS NULL OR
    muid IS NULL OR
    versionname IS NULL OR
    versionnumber IS NULL OR
    version_id IS NULL OR
    TRY_TO_NUMBER(versionnumber) IS NULL OR
    TRY_TO_NUMBER(version_id) IS NULL OR
    id IN (SELECT id FROM SDL_MDS_PH_POS_PRODUCT GROUP BY id HAVING COUNT(*) > 1) OR
    code IN (SELECT code FROM SDL_MDS_PH_POS_PRODUCT GROUP BY code HAVING COUNT(*) > 1) OR
    enterdatetime > CURRENT_TIMESTAMP() OR
    lastchgdatetime > CURRENT_TIMESTAMP() OR
    NOT REGEXP_LIKE(barcode, '^[0-9A-Za-z]+$');
========================================================================================================================================

sql
table_name: SDL_KR_COUPANG_PRODUCT_SUMMARY_MONTHLY
solution: 
1. Ensure 'RUN_ID' is always positive as it likely represents an identifier.
2. Validate 'YEARMO' format to ensure it aligns with 'YYYYMM' structure.
3. Check for any missing values in 'CATEGORY_DEPTH3' and ensure they are handled appropriately.

snowflake query: 
SELECT 
  * 
FROM 
  SDL_KR_COUPANG_PRODUCT_SUMMARY_MONTHLY 
WHERE 
  RUN_ID < 0 
  OR LENGTH(YEARMO) != 6 
  OR TRY_CAST(SUBSTR(YEARMO, 1, 4) AS INTEGER) IS NULL 
  OR TRY_CAST(SUBSTR(YEARMO, 5, 2) AS INTEGER) IS NULL 
  OR CATEGORY_DEPTH3 IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PH_LAV_PRODUCT
solution: 
1. Check for missing data: Ensure that critical fields are not null, especially IDs and codes.
2. Validate data types: Ensure that numeric fields do not contain non-numeric characters.
3. Identify duplicate records: Check for records with the same combination of unique fields.
4. Ensure referential integrity: Verify that foreign keys correspond to existing records in related tables.

snowflake query: 
-- Check for missing data
SELECT *
FROM SDL_MDS_PH_LAV_PRODUCT
WHERE ID IS NULL 
   OR MUID IS NULL 
   OR CODE IS NULL 
   OR SCARDFRANCHISECODE_CODE IS NULL 
   OR SCARDBRANDCODE_CODE IS NULL 
   OR SCARDVARIANTCODE_CODE IS NULL 
   OR SCARDPUTUPCODE_CODE IS NULL;

-- Validate data types
SELECT *
FROM SDL_MDS_PH_LAV_PRODUCT
WHERE TRY_CAST(SCARDVARIANTCODE_ID AS NUMBER) IS NULL
   OR TRY_CAST(VERSIONNUMBER AS NUMBER) IS NULL
   OR TRY_CAST(REPORTGROUP1DESC_ID AS NUMBER) IS NULL;

-- Identify duplicate records
SELECT ID, COUNT(*)
FROM SDL_MDS_PH_LAV_PRODUCT
GROUP BY ID
HAVING COUNT(*) > 1;

-- Ensure referential integrity
SELECT *
FROM SDL_MDS_PH_LAV_PRODUCT p
LEFT JOIN RELATED_TABLE r ON p.SCARDVARIANTCODE_ID = r.ID
WHERE r.ID IS NULL;
========================================================================================================================================

table_name: SDL_MDS_VN_PS_TARGETS
solution: Identify anomalies such as negative version IDs and mismatched version numbers, then implement data validation checks to prevent such anomalies. For existing anomalies, correct the data entries.
snowflake_query:
SELECT *
FROM SDL_MDS_VN_PS_TARGETS
WHERE
    version_id < 0 OR
    versionnumber != enterversionnumber OR
    versionnumber != lastchgversionnumber OR
    validationstatus NOT IN ('Valid', 'Invalid');
========================================================================================================================================

table_name: SDL_MY_DAILY_SELLOUT_STOCK_FACT
solution: 
1. Identify rows with negative values in columns where only positive values are expected (e.g., 'qty', 'unit_prc', 'total_val').
2. Check for mismatches between related fields (e.g., 'qty', 'qty_on_ord', 'qty_committed' should be consistent).
3. Validate data types and ensure text fields do not contain unexpected numeric values.
4. Address the issue of negative values by verifying source data and correcting data entry errors or logic in data processing.

snowflake query: 
SELECT * 
FROM SDL_MY_DAILY_SELLOUT_STOCK_FACT
WHERE TRY_TO_NUMBER(qty) < 0
   OR TRY_TO_NUMBER(unit_prc) < 0
   OR TRY_TO_NUMBER(total_val) < 0
   OR TRY_TO_NUMBER(qty) != TRY_TO_NUMBER(qty_on_ord) + TRY_TO_NUMBER(qty_committed)
   OR NOT REGEXP_LIKE(cust_id, '^[A-Za-z]+$')
   OR NOT REGEXP_LIKE(item_cd, '^[A-Za-z]+$');
========================================================================================================================================

table_name : SDL_CSL_PRODUCTWISESTOCK
solution : Identify and correct negative values in columns where negative values are not expected, such as stock and sales figures. Ensure proper business logic to handle returns and stock adjustments.
snowflake query : 
SELECT * 
FROM SDL_CSL_PRODUCTWISESTOCK
WHERE salopenstock < 0 
   OR unsalopenstock < 0 
   OR offeropenstock < 0 
   OR salpurchase < 0 
   OR unsalpurchase < 0 
   OR offerpurchase < 0 
   OR salsales < 0 
   OR unsalsales < 0 
   OR offersales < 0 
   OR salstockin < 0 
   OR unsalstockin < 0 
   OR offerstockin < 0 
   OR salstockout < 0 
   OR unsalstockout < 0 
   OR offerstockout < 0 
   OR damagein < 0 
   OR damageout < 0 
   OR salsalesreturn < 0 
   OR unsalsalesreturn < 0 
   OR offersalesreturn < 0 
   OR salstkjurin < 0 
   OR unsalstkjurin < 0 
   OR offerstkjurin < 0 
   OR salstkjurout < 0 
   OR unsalstkjurout < 0 
   OR offerstkjurout < 0 
   OR salbattfrin < 0 
   OR unsalbattfrin < 0 
   OR offerbattfrin < 0 
   OR salbattfrout < 0 
   OR unsalbattfrout < 0 
   OR offerbattfrout < 0 
   OR sallcntfrin < 0 
   OR unsallcntfrin < 0 
   OR offerlcntfrin < 0 
   OR sallcntfrout < 0 
   OR unsallcntfrout < 0 
   OR offerlcntfrout < 0 
   OR salreplacement < 0 
   OR offerreplacement < 0 
   OR salclsstock < 0 
   OR unsalclsstock < 0 
   OR offerclsstock < 0;
========================================================================================================================================

table_name: SDL_CSL_SALESMANMASTER
solution: Identify and address anomalies such as negative daily allowances, missing salesman codes, and future created dates.
snowflake_query: 
SELECT 
    * 
FROM 
    SDL_CSL_SALESMANMASTER 
WHERE 
    SMDAILYALLOWANCE < 0 
    OR SMCODE IS NULL 
    OR CREATEDDATE > CURRENT_TIMESTAMP();
========================================================================================================================================

table_name: SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING
solution: 
1. Check for discrepancies in 'active' field since all entries are marked as active (1) while 'versionflag' is 'inactive'.
2. Ensure 'enterdatetime' and 'lastchgdatetime' are logically consistent, i.e., 'enterdatetime' should not be after 'lastchgdatetime'.
3. Verify if 'msl_subchannel' should contain values since it currently has None for all records.
4. Confirm unique constraints on 'code' and 'shoptype_code' to prevent duplicates.

snowflake query:
SELECT *
FROM SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING
WHERE 
    (active = 1 AND versionflag = 'inactive') OR 
    (enterdatetime > lastchgdatetime) OR 
    (msl_subchannel IS NULL) OR 
    (code IN (SELECT code FROM SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING GROUP BY code HAVING COUNT(*) > 1)) OR
    (shoptype_code IN (SELECT shoptype_code FROM SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING GROUP BY shoptype_code HAVING COUNT(*) > 1));
========================================================================================================================================

table_name : SDL_POP6_SG_PRODUCTS
solution : The data contains negative values in fields like `status`, `unit_price`, `display_order`, `largest_uom_quantity`, `middle_uom_quantity`, `smallest_uom_quantity`, and `run_id`, which should be positive. Validate data entry processes and update existing records to correct these values.
snowflake query : 
SELECT * 
FROM SDL_POP6_SG_PRODUCTS 
WHERE status < 0 
   OR unit_price < 0 
   OR display_order < 0 
   OR largest_uom_quantity < 0 
   OR middle_uom_quantity < 0 
   OR smallest_uom_quantity < 0 
   OR run_id < 0;
========================================================================================================================================

table_name : SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
solution : Identify and handle negative values in the RUN_ID column and ensure that CRTD_DTTM is within a valid range. Also, confirm that all required fields are non-null.
snowflake query : 
SELECT 
    *
FROM 
    SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
WHERE 
    RUN_ID < 0
    OR CRTD_DTTM IS NULL
    OR PRODUCT_ATTRIBUTE_ID IS NULL
    OR FILE_NAME IS NULL
    OR FIELD_CODE IS NULL
    OR VISIT_ID IS NULL
    OR FIELD_TYPE IS NULL
    OR FIELD_ID IS NULL
    OR RESPONSE IS NULL
    OR AUDIT_FORM_ID IS NULL
    OR DEPENDENT_ON_FIELD_ID IS NULL
    OR SECTION IS NULL
    OR AUDIT_FORM IS NULL
    OR PRODUCT_ATTRIBUTE_VALUE IS NULL
    OR FIELD_LABEL IS NULL
    OR SECTION_ID IS NULL
    OR PRODUCT_ATTRIBUTE_VALUE_ID IS NULL
    OR PRODUCT_ATTRIBUTE IS NULL;
========================================================================================================================================

table_name: CUST_CUSTOMER  
solution: Address negative values in 'fetchedsequence', check if 'country' values are valid, ensure 'phonenumber' format consistency.  
snowflake query:  
SELECT *  
FROM CUST_CUSTOMER  
WHERE fetchedsequence < 0  
   OR country NOT IN ('USA', 'WAK')  
   OR NOT REGEXP_LIKE(phonenumber, '^[0-9]{10}$');
========================================================================================================================================

table_name: SDL_CSL_RETAILERHIERARCHY  
solution: Address negative values in 'turnover' and 'run_id', and ensure future dates are handled correctly.  
snowflake query:  
SELECT *  
FROM SDL_CSL_RETAILERHIERARCHY  
WHERE turnover < 0  
   OR run_id < 0  
   OR createddt > CURRENT_TIMESTAMP  
   OR crt_dttm > CURRENT_TIMESTAMP;
========================================================================================================================================

table_name: SDL_ID_POS_DIAMOND_SELLOUT
solution: 
  - Anomaly in 'qty' and 'sales': Negative values detected.
  - Anomaly in 'yearmonth': Invalid future date '9999-12'.
  - Anomaly in 'sales': Zero sales with positive quantity.
  - Anomaly in 'crtd_dttm': Future dates should be validated.

snowflake query: 
  SELECT *
  FROM SDL_ID_POS_DIAMOND_SELLOUT
  WHERE qty < 0 
     OR sales < 0 
     OR (sales = 0 AND qty > 0) 
     OR yearmonth = '9999-12' 
     OR crtd_dttm > CURRENT_TIMESTAMP();
========================================================================================================================================

table_name: SDL_KR_COUPANG_SEARCH_KEYWORD_BY_CATEGORY
solution: Detect anomalies such as negative run_id, negative product_ranking, invalid yearmo, and inconsistent data_granularity.

snowflake query:
SELECT *
FROM SDL_KR_COUPANG_SEARCH_KEYWORD_BY_CATEGORY
WHERE run_id < 0
   OR product_ranking < 0
   OR TRY_TO_DATE(yearmo || '01', 'YYYYMMDD') IS NULL
   OR data_granularity NOT IN ('Daily', 'Weekly', 'Monthly');
========================================================================================================================================

table_name: SDL_MDS_SG_PS_WEIGHTS
solution: Detect duplicate entries by checking for multiple records with the same 'id'. Ensure consistency of 'versionnumber' and 'version_id'. Verify 'lastchgdatetime' follows 'enterdatetime'. Check for 'weight' values outside the expected range.
snowflake query: 
SELECT 
    id, 
    COUNT(*) AS record_count 
FROM 
    SDL_MDS_SG_PS_WEIGHTS 
GROUP BY 
    id 
HAVING 
    COUNT(*) > 1;

SELECT 
    * 
FROM 
    SDL_MDS_SG_PS_WEIGHTS 
WHERE 
    versionnumber != version_id;

SELECT 
    * 
FROM 
    SDL_MDS_SG_PS_WEIGHTS 
WHERE 
    lastchgdatetime < enterdatetime;

SELECT 
    * 
FROM 
    SDL_MDS_SG_PS_WEIGHTS 
WHERE 
    weight < 0 OR weight > 10000;  -- Adjust range as needed
========================================================================================================================================

table_name: SDL_SPIRAL_MTI_OFFTAKE
solution: 
- Ensure 'year' values are within a valid range (e.g., 1900-2100).
- Validate 'month' values to ensure they are between 1 and 12.
- Check that 'quantity', 'amount', and 'amountusd' have non-negative values.
snowflake query: 
SELECT *
FROM SDL_SPIRAL_MTI_OFFTAKE
WHERE 
  TRY_TO_NUMBER(year) NOT BETWEEN 1900 AND 2100
  OR TRY_TO_NUMBER(month) NOT BETWEEN 1 AND 12
  OR TRY_TO_NUMBER(quantity) < 0
  OR TRY_TO_NUMBER(amount) < 0
  OR TRY_TO_NUMBER(amountusd) < 0;
========================================================================================================================================

table_name: SDL_MDS_PH_POS_PRODUCT_TEMP
solution: Identify missing or unexpected data patterns across the table to ensure data integrity. Focus on checking for NULLs, duplicates, and data type discrepancies.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    COUNT(DISTINCT id) AS unique_ids,
    COUNT(*) - COUNT(DISTINCT id) AS duplicate_ids,
    SUM(CASE WHEN id IS NULL THEN 1 ELSE 0 END) AS null_ids,
    SUM(CASE WHEN muid IS NULL THEN 1 ELSE 0 END) AS null_muid,
    SUM(CASE WHEN versionname IS NULL THEN 1 ELSE 0 END) AS null_versionname,
    SUM(CASE WHEN versionnumber IS NULL THEN 1 ELSE 0 END) AS null_versionnumber,
    SUM(CASE WHEN version_id IS NULL THEN 1 ELSE 0 END) AS null_version_id,
    SUM(CASE WHEN sap_item_cd_id IS NULL THEN 1 ELSE 0 END) AS null_sap_item_cd_id,
    SUM(CASE WHEN lastchgdatetime IS NULL THEN 1 ELSE 0 END) AS null_lastchgdatetime,
    SUM(CASE WHEN lastchgversionnumber IS NULL THEN 1 ELSE 0 END) AS null_lastchgversionnumber
FROM SDL_MDS_PH_POS_PRODUCT_TEMP;

-- Additional checks for data format discrepancies
SELECT 
    id, 
    CASE WHEN TRY_CAST(versionnumber AS NUMBER) IS NULL THEN 'Invalid number' END AS versionnumber_issue,
    CASE WHEN TRY_CAST(lastchgdatetime AS TIMESTAMP_NTZ) IS NULL THEN 'Invalid timestamp' END AS lastchgdatetime_issue
FROM SDL_MDS_PH_POS_PRODUCT_TEMP
WHERE 
    TRY_CAST(versionnumber AS NUMBER) IS NULL
    OR TRY_CAST(lastchgdatetime AS TIMESTAMP_NTZ) IS NULL;
========================================================================================================================================

table_name : SDL_MY_DAILY_SELLOUT_SALES_FACT
solution : Identify and correct data where total_amt_bfr_tax is negative, and ensure all necessary fields are populated.
snowflake query : 
SELECT * 
FROM SDL_MY_DAILY_SELLOUT_SALES_FACT
WHERE CAST(total_amt_bfr_tax AS FLOAT) < 0
   OR custom_field1 IS NULL
   OR custom_field2 IS NULL 
   OR custom_field3 IS NULL;
========================================================================================================================================

sql
table_name: SDL_DNR_CUSTOMER_DIM
solution: 
1. Detect null values in CUST_ID and PSTLZ columns and decide how to handle them (e.g., replace with default values or investigate missing data).
2. Check for GRCUST values that seem unusually short or invalid and verify if they are correct.
3. Ensure unique constraints on CUST_ID to prevent duplicates.

snowflake query:
SELECT 
    CUST_ID, 
    CUSTNAME, 
    CUSTADD, 
    CUSTCITY, 
    PSTLZ, 
    GRCUST 
FROM 
    SDL_DNR_CUSTOMER_DIM 
WHERE 
    CUST_ID IS NULL 
    OR PSTLZ IS NULL 
    OR LENGTH(GRCUST) < 5 
    OR CUST_ID IN (SELECT CUST_ID FROM SDL_DNR_CUSTOMER_DIM GROUP BY CUST_ID HAVING COUNT(*) > 1);
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_ECOM_NTS
solution: 
1. Check for invalid month values (should be between 1 and 12).
2. Identify negative 'versionnumber' values.
3. Ensure 'enterusername' and 'lastchgusername' are not null.
4. Validate 'validationstatus' for inconsistencies.

snowflake query: 
SELECT * 
FROM SDL_MDS_PACIFIC_ECOM_NTS 
WHERE 
    month NOT BETWEEN 1 AND 12 
    OR versionnumber < 0 
    OR enterusername IS NULL 
    OR lastchgusername IS NULL 
    OR validationstatus NOT IN ('valid', 'invalid');
========================================================================================================================================

table_name: SDL_CSL_UDCDETAILS
solution: Detect missing or null values, inconsistent data, and ensure data integrity. Focus on columns like 'mastervaluecode' and 'columnvalue' for null checks, and 'uploadflag' for invalid entries.
snowflake query: 
SELECT 
  masterid, 
  distcode, 
  mastername, 
  mastervaluecode, 
  mastervaluename, 
  columnname, 
  columnvalue, 
  uploadflag, 
  createddate, 
  syncid, 
  run_id, 
  crt_dttm, 
  file_name
FROM 
  SDL_CSL_UDCDETAILS
WHERE 
  mastervaluecode IS NULL 
  OR columnvalue IS NULL 
  OR uploadflag NOT IN ('Y', 'N');
========================================================================================================================================

table_name: SDL_LA_GT_CUSTOMER
solution: The 'ACTIVESTATUS' field contains negative values which might indicate inactive status or erroneous data. Consider filtering and investigating these entries. Also, many columns contain 'NULL' values, which may indicate incomplete data entry. Recommend ensuring data completeness and validating the logic for 'ACTIVESTATUS'.
snowflake query: 
SELECT * 
FROM SDL_LA_GT_CUSTOMER 
WHERE ACTIVESTATUS < 0 
   OR ARNAME IS NULL 
   OR ARADDRESS IS NULL 
   OR TELEPHONE IS NULL 
   OR FAX IS NULL 
   OR CITY IS NULL 
   OR REGION IS NULL 
   OR SALESDISTRICT IS NULL 
   OR SALEOFFICE IS NULL 
   OR SALEGROUP IS NULL 
   OR ARTYPECODE IS NULL 
   OR SALEEMPLOYEE IS NULL 
   OR SALENAME IS NULL 
   OR BILLNO IS NULL 
   OR BILLMOO IS NULL 
   OR BILLSOI IS NULL 
   OR BILLROAD IS NULL 
   OR BILLSUBDIST IS NULL 
   OR BILLDISTRICT IS NULL 
   OR BILLPROVINCE IS NULL 
   OR BILLZIPCODE IS NULL 
   OR ROUTESTEP1 IS NULL 
   OR ROUTESTEP2 IS NULL 
   OR ROUTESTEP3 IS NULL 
   OR ROUTESTEP4 IS NULL 
   OR ROUTESTEP5 IS NULL 
   OR ROUTESTEP6 IS NULL 
   OR ROUTESTEP7 IS NULL 
   OR LATITUDE IS NULL 
   OR LONGITUDE IS NULL 
   OR ROUTESTEP10 IS NULL 
   OR STORE IS NULL 
   OR PRICELEVEL IS NULL 
   OR SALESAREANAME IS NULL 
   OR BRANCHCODE IS NULL 
   OR BRANCHNAME IS NULL 
   OR FREQUENCYOFVISIT IS NULL 
   OR FILENAME IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_CIW_ADJUSTMENT
solution: Check for NULLs in crucial columns, verify data types, and ensure unique constraints on IDs.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    SUM(CASE WHEN id IS NULL THEN 1 ELSE 0 END) AS null_id_count,
    SUM(CASE WHEN muid IS NULL THEN 1 ELSE 0 END) AS null_muid_count,
    SUM(CASE WHEN versionname IS NULL THEN 1 ELSE 0 END) AS null_versionname_count,
    SUM(CASE WHEN versionnumber IS NULL THEN 1 ELSE 0 END) AS null_versionnumber_count,
    SUM(CASE WHEN version_id IS NULL THEN 1 ELSE 0 END) AS null_version_id_count,
    SUM(CASE WHEN versionflag IS NULL THEN 1 ELSE 0 END) AS null_versionflag_count,
    SUM(CASE WHEN name IS NULL THEN 1 ELSE 0 END) AS null_name_count,
    SUM(CASE WHEN code IS NULL THEN 1 ELSE 0 END) AS null_code_count,
    SUM(CASE WHEN changetrackingmask IS NULL THEN 1 ELSE 0 END) AS null_changetrackingmask_count,
    SUM(CASE WHEN customer_id IS NULL THEN 1 ELSE 0 END) AS null_customer_id_count,
    SUM(CASE WHEN prod_mjr_cd IS NULL THEN 1 ELSE 0 END) AS null_prod_mjr_cd_count,
    SUM(CASE WHEN sap_accnt IS NULL THEN 1 ELSE 0 END) AS null_sap_accnt_count,
    SUM(CASE WHEN amt_obj_crncy IS NULL THEN 1 ELSE 0 END) AS null_amt_obj_crncy_count,
    SUM(CASE WHEN local_ccy IS NULL THEN 1 ELSE 0 END) AS null_local_ccy_count,
    SUM(CASE WHEN enterdatetime IS NULL THEN 1 ELSE 0 END) AS null_enterdatetime_count,
    SUM(CASE WHEN enterusername IS NULL THEN 1 ELSE 0 END) AS null_enterusername_count,
    SUM(CASE WHEN enterversionnumber IS NULL THEN 1 ELSE 0 END) AS null_enterversionnumber_count,
    SUM(CASE WHEN lastchgdatetime IS NULL THEN 1 ELSE 0 END) AS null_lastchgdatetime_count,
    SUM(CASE WHEN lastchgusername IS NULL THEN 1 ELSE 0 END) AS null_lastchgusername_count,
    SUM(CASE WHEN lastchgversionnumber IS NULL THEN 1 ELSE 0 END) AS null_lastchgversionnumber_count,
    SUM(CASE WHEN validationstatus IS NULL THEN 1 ELSE 0 END) AS null_validationstatus_count
FROM SDL_MDS_PACIFIC_CIW_ADJUSTMENT;
========================================================================================================================================

table_name: SDL_MY_DAILY_SELLOUT_SALES_FACT_MDS_SYNC
solution: 
- Detect rows where quantity doesn't match between 'quantity', 'quantity_in_pieces', and 'quantity_after_conversion'.
- Identify records with negative or zero values where logical (e.g., 'gross_item_price', 'total_amt_after_tax').
- Check mismatches in 'sub_total_1', 'sub_total_2', 'total_amt_before_tax', and 'total_amt_after_tax'.

snowflake query: 
SELECT 
    * 
FROM 
    SDL_MY_DAILY_SELLOUT_SALES_FACT_MDS_SYNC
WHERE 
    quantity != quantity_in_pieces 
    OR quantity != quantity_after_conversion
    OR quantity_in_pieces != quantity_after_conversion
    OR CAST(gross_item_price AS FLOAT) <= 0
    OR CAST(total_amt_after_tax AS FLOAT) <= 0
    OR sub_total_2 != CAST(sub_total_1 AS FLOAT) - CAST(discount AS FLOAT)
    OR total_amt_before_tax != sub_total_2
    OR total_amt_after_tax != total_amt_before_tax + (CAST(total_amt_before_tax AS FLOAT) * 0.05); -- Assuming a 5% tax rate.
========================================================================================================================================

Certainly, here is the solution for identifying anomalies in the table `SDL_MDS_PACIFIC_CUST_ATTRB` and the corresponding Snowflake query:


table_name : SDL_MDS_PACIFIC_CUST_ATTRB
solution : 
1. Check for null or empty values in critical columns.
2. Identify duplicate entries based on unique identifiers.
3. Detect invalid or inconsistent relationships among related columns.
4. Validate data types and range constraints.
snowflake query : 
SELECT 
  *,
  CASE WHEN id IS NULL THEN 'Missing ID' ELSE NULL END AS anomaly_id,
  CASE WHEN muid IS NULL THEN 'Missing MUID' ELSE NULL END AS anomaly_muid,
  CASE WHEN versionnumber IS NULL THEN 'Missing Version Number' ELSE NULL END AS anomaly_versionnumber,
  CASE WHEN version_id IS NULL THEN 'Missing Version ID' ELSE NULL END AS anomaly_version_id,
  CASE WHEN (code IS NOT NULL AND LENGTH(code) < 5) THEN 'Invalid Code Length' ELSE NULL END AS anomaly_code,
  CASE WHEN COUNT(*) OVER (PARTITION BY id) > 1 THEN 'Duplicate ID' ELSE NULL END AS anomaly_duplicate_id
FROM SDL_MDS_PACIFIC_CUST_ATTRB
WHERE id IS NULL 
   OR muid IS NULL 
   OR versionnumber IS NULL 
   OR version_id IS NULL 
   OR (code IS NOT NULL AND LENGTH(code) < 5)
   OR COUNT(*) OVER (PARTITION BY id) > 1;


This query identifies rows with missing or invalid data and checks for duplicate entries based on the `id` column. Adjust the conditions as necessary to match the specific data validation rules and constraints applicable to your dataset.
========================================================================================================================================

text
table_name: SDL_MDS_PACIFIC_COGS_MASTER
solution: Identify negative COGS values and invalid validation statuses to ensure data accuracy. Review and update records with negative COGS or invalid statuses.
snowflake query: 
SELECT * 
FROM SDL_MDS_PACIFIC_COGS_MASTER 
WHERE AU_COGS_PER_UNIT < 0 
   OR NZ_COGS_PER_UNIT < 0 
   OR VALIDATIONSTATUS = 'Invalid';
========================================================================================================================================

table_name: SDL_HK_IMS_VIVA_SEL_OUT
solution: 
1. Negative sales volume and order quantity should be investigated for errors.
2. Negative exchange rate values are unlikely and should be verified.
3. Ensure net trade sales are consistent with sales volume and order quantity.

snowflake query: 
SELECT 
    CUSTOMER_NAME, 
    SALES_OFFICE, 
    SALES_GROUP, 
    SALES_VOLUME, 
    SALES_ORDER_QUANTITY, 
    NET_TRADE_SALES, 
    LOCAL_CURR_EXCH_RATE 
FROM 
    SDL_HK_IMS_VIVA_SEL_OUT 
WHERE 
    SALES_VOLUME < 0 OR 
    SALES_ORDER_QUANTITY < 0 OR 
    LOCAL_CURR_EXCH_RATE < 0 OR 
    NET_TRADE_SALES < 0;
========================================================================================================================================

table_name: SDL_POP6_SG_DISPLAY_PLANS
solution: The anomalies detected in the data include negative 'status' and 'required_number_of_displays' values. Ensure these fields contain only positive numbers by setting constraints or handling them in ETL processes.
snowflake query: 
SELECT *
FROM SDL_POP6_SG_DISPLAY_PLANS
WHERE status < 0 
   OR required_number_of_displays < 0;
========================================================================================================================================

sql
table_name : SDL_MDS_SG_PS_TARGETS
solution : 
1. Check for negative values in 'value' column, as they may indicate incorrect data.
2. Validate 'versionnumber' to ensure it is non-negative.
3. Ensure 'enterdatetime' and 'lastchgdatetime' are not future dates.
4. Confirm 'versionflag' matches expected values ('active', 'inactive').

snowflake query : 
SELECT * 
FROM SDL_MDS_SG_PS_TARGETS
WHERE 
    value < 0 
    OR versionnumber < 0 
    OR enterdatetime > CURRENT_TIMESTAMP 
    OR lastchgdatetime > CURRENT_TIMESTAMP 
    OR versionflag NOT IN ('active', 'inactive');
========================================================================================================================================

table_name: SDL_API_DSTR
solution: The table 'SDL_API_DSTR' has all columns defined as 'TEXT' even for potentially numeric or date columns. This can lead to data integrity issues and inefficient querying. Consider converting columns such as 'cost_price', 'invt_dt', 'soh_qty', 'mth_total_invoiced_qty', and 'dc_soo_qty' to appropriate data types like NUMBER or DATE. Additionally, check for missing data in the sample data as it appears empty.

snowflake query: 
-- Detect anomalies by checking for non-numeric data in numeric-intended columns
SELECT 
  ARTICLE_ID,
  CASE WHEN TRY_CAST(COST_PRICE AS NUMBER) IS NULL AND COST_PRICE IS NOT NULL THEN 'Non-numeric cost_price' END AS cost_price_anomaly,
  CASE WHEN TRY_CAST(SOH_QTY AS NUMBER) IS NULL AND SOH_QTY IS NOT NULL THEN 'Non-numeric soh_qty' END AS soh_qty_anomaly,
  CASE WHEN TRY_CAST(MTH_TOTAL_INVOICED_QTY AS NUMBER) IS NULL AND MTH_TOTAL_INVOICED_QTY IS NOT NULL THEN 'Non-numeric mth_total_invoiced_qty' END AS mth_total_invoiced_qty_anomaly,
  CASE WHEN TRY_CAST(DC_SOO_QTY AS NUMBER) IS NULL AND DC_SOO_QTY IS NOT NULL THEN 'Non-numeric dc_soo_qty' END AS dc_soo_qty_anomaly,
  CASE WHEN TRY_CAST(INVT_DT AS DATE) IS NULL AND INVT_DT IS NOT NULL THEN 'Invalid date invt_dt' END AS invt_dt_anomaly
FROM SDL_API_DSTR
WHERE 
  TRY_CAST(COST_PRICE AS NUMBER) IS NULL AND COST_PRICE IS NOT NULL OR
  TRY_CAST(SOH_QTY AS NUMBER) IS NULL AND SOH_QTY IS NOT NULL OR
  TRY_CAST(MTH_TOTAL_INVOICED_QTY AS NUMBER) IS NULL AND MTH_TOTAL_INVOICED_QTY IS NOT NULL OR
  TRY_CAST(DC_SOO_QTY AS NUMBER) IS NULL AND DC_SOO_QTY IS NOT NULL OR
  TRY_CAST(INVT_DT AS DATE) IS NULL AND INVT_DT IS NOT NULL;
========================================================================================================================================

Certainly! Here's the solution in the specified format:


table_name: SDL_MDS_PH_DISTRIBUTOR_SUPERVISORS
solution: Analyze and clean up the NULL or empty values in critical fields. Ensure primary and foreign key constraints are respected. Validate and correct data types and formats.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MDS_PH_DISTRIBUTOR_SUPERVISORS 
WHERE 
    ENTVERSIONNUMBER IS NULL OR 
    CHANGETRACKINGMASK IS NULL OR 
    SLSSPNM IS NULL OR 
    VALIDATIONSTATUS IS NULL OR 
    DISTCODE IS NULL OR 
    CODE IS NULL OR 
    SLSGRP IS NULL OR 
    SLSSPID IS NULL OR 
    MUID IS NULL OR 
    LASTCHGDATETIME IS NULL OR 
    SLSGRPNM IS NULL OR 
    VERSIONNAME IS NULL OR 
    SLSNM IS NULL OR 
    VERSION_ID IS NULL OR 
    ID IS NULL OR 
    LASTCHGUSERNAME IS NULL OR 
    ENTERUSERNAME IS NULL OR 
    SALESCYCLE IS NULL OR 
    VERSIONNUMBER IS NULL OR 
    VERSIONFLAG IS NULL OR 
    ENTERDATETIME IS NULL OR 
    LASTCHGVERSIONNUMBER IS NULL OR 
    SLSID IS NULL OR 
    NAME IS NULL;


This query checks for NULL values in all columns of the `SDL_MDS_PH_DISTRIBUTOR_SUPERVISORS` table, which can be considered anomalies if these columns are expected to have valid data.
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_RANKING_MONTHLY
solution: 
1. Ranking values should be non-negative and within a reasonable range.
2. Verify that SKU IDs are unique for each product_ranking_date.
3. Ensure file_name corresponds correctly with run_id and other fields.

snowflake query: 
SELECT * FROM SDL_KR_COUPANG_PRODUCT_RANKING_MONTHLY
WHERE 
  TRY_TO_NUMBER(ranking) < 0 
  OR TRY_TO_NUMBER(ranking) > 1000000 
  OR coupang_sku_id IN (
    SELECT coupang_sku_id 
    FROM SDL_KR_COUPANG_PRODUCT_RANKING_MONTHLY 
    GROUP BY product_ranking_date, coupang_sku_id 
    HAVING COUNT(*) > 1
  );
========================================================================================================================================

table_name: SDL_POP6_SG_DISPLAYS
solution: There are anomalies where the `end_date` is before the `start_date`. Ensure that the `end_date` is always greater than or equal to the `start_date`.
snowflake_query: 
SELECT *
FROM SDL_POP6_SG_DISPLAYS
WHERE END_DATE < START_DATE;


Note: The above query detects rows where the `end_date` is earlier than the `start_date`, which is an anomaly. The solution is to ensure that `end_date` should be equal to or later than the `start_date`.
========================================================================================================================================

table_name: SDL_MATERIAL_PKA_MARA_EXTRACT
solution: The sample data appears to be empty, indicating that there might be an issue with data ingestion or extraction. Verify data pipeline processes to ensure data is being loaded correctly. Additionally, check for any data filters or constraints that might be excluding records.
snowflake query: 


sql
SELECT 
    material, description, material_type, created_on, manufacturer, 
    manufacturing_source, bh_mega_brand, bh_mega_brand_desc, bh_brand, 
    bh_brand_desc, bh_base_product, bh_base_product_desc, bh_variant, 
    bh_variant_desc, bh_put_up, bh_put_up_desc, franchise, 
    franchise_description, brand, brand_description, subbrand, 
    subbranddesc, variant, variantdesc, subvariant, subvariantdesc, 
    flavor, flavordesc, ingredient, ingredientdesc, application, 
    applicationdesc, strength, strengthdesc, shape, shapedesc, spf, 
    spfdesc, cover, coverdesc, form, formdesc, size, sizedesc, 
    character, charaterdesc, package, packagedesc, attribute13, 
    attribute13desc, attribute14, attribute14desc, skuidentification, 
    skuiddesc, onetimerel, onetimereldesc, productkey, productdesc, 
    rootcode, rootcodedes, with_2018_2019_nts
FROM SDL_MATERIAL_PKA_MARA_EXTRACT
WHERE material IS NULL 
   OR description IS NULL 
   OR material_type IS NULL 
   OR created_on IS NULL 
   OR manufacturer IS NULL 
   OR manufacturing_source IS NULL 
   OR bh_mega_brand IS NULL;


This query identifies records with missing critical fields, which may indicate anomalies in the data ingestion process. The solution is to investigate and correct any issues in the data pipeline or extraction logic to ensure complete data is being captured.
========================================================================================================================================

table_name: SDL_MDS_PH_NPI_SALES_GROUPINGS

solution: Anomalies identified include negative IDs, mismatched account_name_id with account_name_code, and invalid validation statuses. Suggested solutions involve ensuring IDs are positive, verifying account relationships, and correcting validation statuses.

snowflake query: 
SELECT *
FROM SDL_MDS_PH_NPI_SALES_GROUPINGS
WHERE id < 0
   OR account_name_id < 0
   OR (account_name_id < 0 AND account_name_code NOT LIKE 'ACC%')
   OR validationstatus NOT IN ('Validated', 'Pending', 'Invalid')
   OR enterversionnumber < 0
   OR lastchgversionnumber < 0
   OR versionnumber < 0;
========================================================================================================================================

table_name: SDL_CSL_RETAILERROUTE
solution: 
Detect records with missing or inconsistent data, such as negative IDs, missing codes, or null fields in critical columns.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_CSL_RETAILERROUTE 
WHERE 
    RTRID < 0 
    OR RMID < 0 
    OR SYNCID < 0 
    OR RUN_ID < 0 
    OR DISTCODE IS NULL 
    OR RTRCODE IS NULL 
    OR RTRNAME IS NULL 
    OR RMCODE IS NULL 
    OR RMNAME IS NULL 
    OR ROUTETYPE IS NULL 
    OR UPLOADFLAG IS NULL 
    OR FILE_NAME IS NULL;
========================================================================================================================================

table_name : SDL_GCPH_CATEGORY  
solution : Detect anomalies in numeric fields such as negative values where they shouldn't exist, and extremely large values that may indicate data entry errors. Implement validation rules or constraints to prevent such anomalies in the future.  
snowflake query : SELECT * FROM SDL_GCPH_CATEGORY WHERE LENGTH < 0 OR NET_WEIGHT < 0 OR VOLUME < 0 OR GROSS_WEIGHT < 0 OR HEIGHT < 0 OR WIDTH < 0 OR MANUALCLASSIFICATIONID > 999999999 OR SUGGESTEDCLASSIFICATIONSCORE > 1000;
========================================================================================================================================

table_name: SDL_KR_COUPANG_BRAND_RANKING
solution: Check for data type inconsistencies and logical errors. Ensure rankings are numerical and analyze rank change signs for anomalies.
snowflake_query: 
SELECT * 
FROM SDL_KR_COUPANG_BRAND_RANKING
WHERE TRY_TO_NUMBER(RANKING) IS NULL
   OR TRY_TO_NUMBER(RANK_CHANGE) IS NULL
   OR REGEXP_LIKE(RANK_CHANGE, '^[+-]\d+$') = FALSE
   OR LENGTH(YEARMO) != 6
   OR DATA_GRANULARITY NOT IN ('daily', 'weekly', 'monthly');
========================================================================================================================================

table_name : SDL_KR_COUPANG_PRODUCTSALEREPORT  
solution : Detect sales anomalies such as negative sales_gmv and units_sold. Address data integrity by correcting negative values or investigating data sources.  
snowflake query :   
sql  
SELECT *  
FROM SDL_KR_COUPANG_PRODUCTSALEREPORT  
WHERE sales_gmv < 0 OR units_sold < 0;  
  

table_name : SDL_KR_COUPANG_PRODUCTSALEREPORT  
solution : Identify mismatches in cost_of_purchase and sns_cogs, ensuring these values are positive. Investigate and correct any negative or unexpected discrepancies.  
snowflake query :   
sql  
SELECT *  
FROM SDL_KR_COUPANG_PRODUCTSALEREPORT  
WHERE cost_of_purchase < 0 OR sns_cogs < 0;  
  

table_name : SDL_KR_COUPANG_PRODUCTSALEREPORT  
solution : Check for inconsistencies in sns_units_sold and units_sold. Ensure sns_units_sold does not exceed units_sold and correct data if necessary.  
snowflake query :   
sql  
SELECT *  
FROM SDL_KR_COUPANG_PRODUCTSALEREPORT  
WHERE TRY_CAST(sns_units_sold AS NUMBER) > units_sold;  
  

table_name : SDL_KR_COUPANG_PRODUCTSALEREPORT  
solution : Validate shipping_sales_gmv and shipping_weight_percent. Correct any negative values and verify data source accuracy.  
snowflake query :   
sql  
SELECT *  
FROM SDL_KR_COUPANG_PRODUCTSALEREPORT  
WHERE TRY_CAST(shipping_sales_gmv AS NUMBER) < 0 OR TRY_CAST(shipping_weight_percent AS NUMBER) < 0;
========================================================================================================================================

table_name: SDL_MDS_PH_MSL_HDR
solution: 
- Many fields have NULL values (e.g., `muid`, `versionname`, `name`). Ensure proper data entry and validation processes to populate these fields.
- Consider auditing the data input process to enforce mandatory fields where applicable.
- Implement checks to ensure fields like `enterusername` and `lastchgusername` are not left NULL if they are required for tracking changes.
snowflake query: 
SELECT 
    id,
    muid,
    versionname,
    name,
    code,
    csg_code_code,
    csg_code_name,
    enterusername,
    enterdatetime,
    lastchgusername,
    lastchgdatetime,
    validationstatus
FROM 
    SDL_MDS_PH_MSL_HDR
WHERE 
    muid IS NULL OR
    versionname IS NULL OR
    name IS NULL OR
    code IS NULL OR
    csg_code_code IS NULL OR
    csg_code_name IS NULL OR
    enterusername IS NULL OR
    lastchgusername IS NULL OR
    validationstatus IS NULL;
========================================================================================================================================

table_name: SDL_ECOMMERCE_6PAI
solution: Identify and address anomalies by checking for significant gaps and discrepancies in KPI metrics, such as negative values in 'gap_vs_pm', 'gap_vs_p3m', or unusually high weights in 'score_weighted'.
snowflake query: 
SELECT *
FROM SDL_ECOMMERCE_6PAI
WHERE (GAP_VS_PM < -10 OR GAP_VS_P3M < -10 OR SCORE_WEIGHTED > 1 OR SCORE_NON_WEIGHTED > 1 OR GAP_VS_PLAN < 0);


This query identifies records with significantly negative gaps or unusually high weight scores, which may indicate data entry errors or significant performance issues needing attention.
========================================================================================================================================

table_name: SDL_MDS_VN_ECOM_NTS
solution: Check for duplicate records, consistency of timestamps, and unique identifiers.
snowflake query: 
SELECT 
    id, 
    COUNT(*) AS record_count 
FROM 
    SDL_MDS_VN_ECOM_NTS 
GROUP BY 
    id 
HAVING 
    record_count > 1 
UNION ALL 
SELECT 
    id, 
    COUNT(DISTINCT enterdatetime) AS distinct_enterdatetime_count 
FROM 
    SDL_MDS_VN_ECOM_NTS 
GROUP BY 
    id 
HAVING 
    distinct_enterdatetime_count > 1 
UNION ALL
SELECT 
    id, 
    COUNT(DISTINCT muid) AS distinct_muid_count 
FROM 
    SDL_MDS_VN_ECOM_NTS 
GROUP BY 
    id 
HAVING 
    distinct_muid_count > 1;


In this solution, we identified potential anomalies, such as duplicate records based on the `id`, inconsistent timestamps for the same `id`, and duplicate `muid` values. The Snowflake query is designed to detect these anomalies efficiently.
========================================================================================================================================

table_name: KPI2DATA_MAPPING
solution: Identify and address negative values in the 'value' column, ensure 'start_date' is before 'end_date', and verify consistent 'identifier' usage across 'data_type'.
snowflake query: 
SELECT 
    IDENTIFIER, 
    CATEGORY, 
    DATA_TYPE, 
    SEGMENT, 
    VALUE, 
    START_DATE, 
    END_DATE, 
    CTRY, 
    STORE_TYPE, 
    KPI_NAME, 
    CRT_DTTM 
FROM 
    KPI2DATA_MAPPING 
WHERE 
    CAST(VALUE AS INTEGER) < 0 
    OR START_DATE > END_DATE 
    OR IDENTIFIER IN (
        SELECT IDENTIFIER 
        FROM KPI2DATA_MAPPING 
        GROUP BY IDENTIFIER 
        HAVING COUNT(DISTINCT DATA_TYPE) > 1
    );
========================================================================================================================================

table_name: SDL_CSL_TBL_SCHEMEWISE_APNO
solution: Identify and handle missing values, check for duplicate records, and ensure referential integrity.
snowflake query: 
SELECT 
    schid, 
    apno, 
    createduserid, 
    createddate, 
    schcategorytype1code, 
    schcategorytype2code, 
    crt_dttm
FROM 
    SDL_CSL_TBL_SCHEMEWISE_APNO
WHERE 
    schcategorytype1code IS NULL 
    OR schcategorytype2code IS NULL 
    OR (schid, apno) IN (
        SELECT schid, apno 
        FROM SDL_CSL_TBL_SCHEMEWISE_APNO 
        GROUP BY schid, apno 
        HAVING COUNT(*) > 1
    )
    OR createduserid NOT IN (
        SELECT user_id 
        FROM users_table -- assuming 'users_table' holds valid user IDs
    );
========================================================================================================================================

table_name: SDL_MDS_VN_DISTRIBUTOR_PRODUCTS
solution: Detect anomalies such as null or duplicate values in key columns (like 'ID', 'MUID', 'CODE'), and check for data type inconsistencies or unexpected values in critical columns.
snowflake query: 
SELECT 
    ID, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_MDS_VN_DISTRIBUTOR_PRODUCTS
GROUP BY 
    ID
HAVING 
    COUNT(*) > 1

UNION ALL

SELECT 
    'Null values in critical columns' AS anomaly_type, 
    COUNT(*) AS count 
FROM 
    SDL_MDS_VN_DISTRIBUTOR_PRODUCTS
WHERE 
    ID IS NULL 
    OR MUID IS NULL 
    OR CODE IS NULL

UNION ALL

SELECT 
    'Data type inconsistency or unexpected values' AS anomaly_type, 
    COUNT(*) AS count
FROM 
    SDL_MDS_VN_DISTRIBUTOR_PRODUCTS
WHERE 
    NOT TRY_CAST(VERSION_ID AS NUMBER) IS NULL
    OR NOT TRY_CAST(JNJ_SAP_CODE AS NUMBER) IS NULL
========================================================================================================================================

table_name: SDL_POP6_SG_EXECUTED_VISITS
solution: The table has no sample data provided, implying a potential data loading issue or an empty table. Verify data ingestion processes and ensure data is appropriately populated.

snowflake_query: 
SELECT 
    VISIT_ID, 
    VISIT_DATE, 
    CHECK_IN_DATETIME, 
    CHECK_OUT_DATETIME, 
    POPDB_ID, 
    POP_CODE, 
    POP_NAME, 
    ADDRESS, 
    CHECK_IN_LONGITUDE, 
    CHECK_IN_LATITUDE, 
    CHECK_OUT_LONGITUDE, 
    CHECK_OUT_LATITUDE, 
    CHECK_IN_PHOTO, 
    CHECK_OUT_PHOTO, 
    USERNAME, 
    USER_FULL_NAME, 
    SUPERIOR_USERNAME, 
    SUPERIOR_NAME, 
    PLANNED_VISIT, 
    CANCELLED_VISIT, 
    CANCELLATION_REASON, 
    CANCELLATION_NOTE, 
    FILE_NAME, 
    RUN_ID, 
    CRTD_DTTM 
FROM SDL_POP6_SG_EXECUTED_VISITS
WHERE 1=1
    AND (VISIT_ID IS NULL 
         OR VISIT_DATE IS NULL 
         OR CHECK_IN_DATETIME IS NULL 
         OR CHECK_OUT_DATETIME IS NULL 
         OR POPDB_ID IS NULL 
         OR POP_CODE IS NULL 
         OR POP_NAME IS NULL 
         OR ADDRESS IS NULL 
         OR CHECK_IN_LONGITUDE IS NULL 
         OR CHECK_IN_LATITUDE IS NULL 
         OR CHECK_OUT_LONGITUDE IS NULL 
         OR CHECK_OUT_LATITUDE IS NULL 
         OR CHECK_IN_PHOTO IS NULL 
         OR CHECK_OUT_PHOTO IS NULL 
         OR USERNAME IS NULL 
         OR USER_FULL_NAME IS NULL 
         OR SUPERIOR_USERNAME IS NULL 
         OR SUPERIOR_NAME IS NULL 
         OR PLANNED_VISIT IS NULL 
         OR CANCELLED_VISIT IS NULL 
         OR CANCELLATION_REASON IS NULL 
         OR CANCELLATION_NOTE IS NULL 
         OR FILE_NAME IS NULL 
         OR RUN_ID IS NULL 
         OR CRTD_DTTM IS NULL);
========================================================================================================================================

table_name: SDL_MDS_MY_CUSTOMER_HIERARCHY
solution: Check for missing or null values and duplicates in the critical columns to ensure data integrity. Also, verify that ID fields are unique and foreign key relationships are consistent.
snowflake query: 
SELECT
    'ID' AS anomaly_column,
    COUNT(*) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
WHERE ID IS NULL OR ID = ''
UNION ALL
SELECT
    'ID' AS anomaly_column,
    COUNT(*) - COUNT(DISTINCT ID) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
UNION ALL
SELECT
    'MUID' AS anomaly_column,
    COUNT(*) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
WHERE MUID IS NULL OR MUID = ''
UNION ALL
SELECT
    'VERSION_ID' AS anomaly_column,
    COUNT(*) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
WHERE VERSION_ID IS NULL OR VERSION_ID = ''
UNION ALL
SELECT
    'CHANNEL_ID' AS anomaly_column,
    COUNT(*) - COUNT(DISTINCT CHANNEL_ID) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
UNION ALL
SELECT
    'REG_CHANNEL_ID' AS anomaly_column,
    COUNT(*) - COUNT(DISTINCT REG_CHANNEL_ID) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
UNION ALL
SELECT
    'REG_GROUP_ID' AS anomaly_column,
    COUNT(*) - COUNT(DISTINCT REG_GROUP_ID) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
UNION ALL
SELECT
    'TERRITORY_ID' AS anomaly_column,
    COUNT(*) - COUNT(DISTINCT TERRITORY_ID) AS anomaly_count
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_USER_MASTER
solution: Detect negative run_id values, duplicated names, and future dates in cdl_dttm. Correct negative run_id values, ensure unique names, and validate date formats.
snowflake_query: 
SELECT 
    md_code, sd_code, rbdm_code, bdm_code, bdr_code, dis_code, rsm_code, sup_code, sr_code, 
    md_name, sd_name, rbdm_name, bdm_name, bdr_name, dis_name, rsm_name, sup_name, sr_name,
    cdl_dttm, run_id, file_name
FROM SDL_DISTRIBUTOR_IVY_USER_MASTER
WHERE run_id < 0 
   OR cdl_dttm > CURRENT_TIMESTAMP()
   OR (md_name IN (SELECT md_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY md_name HAVING COUNT(*) > 1)
       OR sd_name IN (SELECT sd_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY sd_name HAVING COUNT(*) > 1)
       OR rbdm_name IN (SELECT rbdm_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY rbdm_name HAVING COUNT(*) > 1)
       OR bdm_name IN (SELECT bdm_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY bdm_name HAVING COUNT(*) > 1)
       OR bdr_name IN (SELECT bdr_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY bdr_name HAVING COUNT(*) > 1)
       OR dis_name IN (SELECT dis_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY dis_name HAVING COUNT(*) > 1)
       OR rsm_name IN (SELECT rsm_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY rsm_name HAVING COUNT(*) > 1)
       OR sup_name IN (SELECT sup_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY sup_name HAVING COUNT(*) > 1)
       OR sr_name IN (SELECT sr_name FROM SDL_DISTRIBUTOR_IVY_USER_MASTER GROUP BY sr_name HAVING COUNT(*) > 1));
========================================================================================================================================

table_name: SDL_MY_CIW_MAP
solution: Identify records with null values in critical columns and inconsistent data entries. Ensure data integrity and consistency by implementing validation rules for critical columns.
snowflake_query: 
SELECT * 
FROM SDL_MY_CIW_MAP 
WHERE ciw_buckt1 IS NULL 
   OR ciw_buckt2 IS NULL 
   OR bravo_desc1 IS NULL 
   OR acct_desc IS NULL 
   OR (bravo_cd1 != bravo_cd2) 
   OR (acct_type IS NULL AND acct_type1 IS NOT NULL) 
   OR (acct_type IS NOT NULL AND acct_type1 IS NULL);
========================================================================================================================================

Certainly! Here is the solution in the requested format:


table_name: SDL_JNJ_OSA_OOS_REPORT
solution: 
1. The negative `run_id` values should be corrected to reflect the correct identifiers.
2. Ensure `oos_reason` is populated when `oos` is 'Yes' to avoid missing data.
3. Validate the `yearmo` field to ensure it represents valid year-month combinations.
4. Correct any incorrect or missing `oos_reason` values to maintain data integrity.

snowflake query: 
-- Detect negative run_id values
SELECT * FROM SDL_JNJ_OSA_OOS_REPORT WHERE RUN_ID < 0;

-- Detect missing oos_reason where oos is 'Yes'
SELECT * FROM SDL_JNJ_OSA_OOS_REPORT WHERE OOS = 'Yes' AND OOS_REASON IS NULL;

-- Validate yearmo field for correct year-month format
SELECT * FROM SDL_JNJ_OSA_OOS_REPORT WHERE NOT REGEXP_LIKE(YEARMO, '^(19|20)\d{2}(0[1-9]|1[0-2])$');

-- Detect incorrect or missing oos_reason values
SELECT * FROM SDL_JNJ_OSA_OOS_REPORT WHERE OOS = 'Yes' AND (OOS_REASON IS NULL OR OOS_REASON = '');


This SQL script will help you identify anomalies in the SDL_JNJ_OSA_OOS_REPORT table and take corrective actions as necessary.
========================================================================================================================================

table_name: SDL_MDS_VN_PS_WEIGHTS
solution: Detect anomalies in weights (negative values) and changetrackingmask (high fixed value). Suggest correcting weights to positive values and verifying changetrackingmask usage.
snowflake_query: 
SELECT 
    id, 
    muid, 
    weight, 
    changetrackingmask 
FROM 
    SDL_MDS_VN_PS_WEIGHTS 
WHERE 
    weight < 0 
    OR changetrackingmask = 999999999;
========================================================================================================================================

table_name: SDL_DSTR_COLES_INV
solution: Identify negative stock on hand values and address data entry errors. Ensure vendor codes meet expected lengths.
snowflake_query: 
SELECT *
FROM SDL_DSTR_COLES_INV
WHERE CAST(closing_soh_nic AS NUMBER) < 0
   OR LENGTH(vendor) NOT BETWEEN 3 AND 50;
========================================================================================================================================

Sure, here's a concise solution for detecting anomalies in the SDL_ECOM_GMV_KONVY table along with a Snowflake-friendly SQL query:


table_name: SDL_ECOM_GMV_KONVY
solution: The data contains various anomalies such as negative values in fields that should logically be positive (e.g., sales_amount, total_unit_sold, current_price, etc.). To address these anomalies, identify and filter out these records for further investigation and correction.
snowflake query: 
SELECT *
FROM SDL_ECOM_GMV_KONVY
WHERE sales_amount < 0
   OR total_unit_sold < 0
   OR current_price < 0
   OR pro_price < 0
   OR pro_cost < 0
   OR cost_in_vat < 0
   OR cost < 0
   OR market_value < 0
   OR stock_turnover_days < 0
   OR conversion < 0;


This query identifies rows with negative values in columns that should typically have positive values, allowing further investigation and rectification.
========================================================================================================================================

table_name: SDL_HK_IMS_WINGKEUNG_SEL_OUT  
solution: Detect negative sales volumes and net trade sales. Ensure data integrity and business logic correctness.  
snowflake_query:  
SELECT *  
FROM SDL_HK_IMS_WINGKEUNG_SEL_OUT  
WHERE sales_volume < 0 OR net_trade_sales < 0;
========================================================================================================================================

Certainly! Below is the solution in the specified format:


table_name: SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
solution: 
- Identify duplicate entries based on 'distcode', 'targetrefno', 'smcode', 'rmcode' with same 'targetdate'.
- Check for future 'targetyear' values that don't logically align with current or historical data.
- Validate 'targetvalue' and 'week' columns to ensure they sum up correctly.
snowflake query: 
-- Detect duplicate entries
SELECT 
    distcode, targetrefno, smcode, rmcode, targetdate, COUNT(*) 
FROM 
    SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT 
GROUP BY 
    distcode, targetrefno, smcode, rmcode, targetdate 
HAVING 
    COUNT(*) > 1;

-- Check for future 'targetyear' anomalies
SELECT 
    * 
FROM 
    SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT 
WHERE 
    targetyear > EXTRACT(YEAR FROM CURRENT_DATE);

-- Validate target and weekly values
SELECT 
    * 
FROM 
    SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT 
WHERE 
    (week1 + week2 + week3 + week4 + week5) <> targetvalue;


This solution aims to efficiently identify and correct anomalies found in the dataset from Snowflake.
========================================================================================================================================

table_name: SDL_JNJ_CONSUMERREACH_CVS
solution: Detect missing or inconsistent data in critical fields like 'retailname', 'distribution', 'status', and 'file_name'. Recommend data validation checks during data entry and enforcing not null constraints where applicable.
snowflake query: 
SELECT *
FROM SDL_JNJ_CONSUMERREACH_CVS
WHERE retailname IS NULL
   OR distribution IS NULL
   OR status IS NULL
   OR file_name IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_ACCT_NIELSENCODE_MAPPING

solution: 
1. Identify negative version numbers and set them to a default positive value or flag them for review.
2. Check for null values in critical fields like 'versionflag' and 'name' and update them or flag for data review.
3. Ensure 'validationstatus' is consistent and logical; review entries marked 'Pending' or 'Invalid'.

snowflake query: 
SELECT 
    id, 
    versionnumber, 
    versionflag, 
    name, 
    validationstatus
FROM 
    SDL_MDS_PACIFIC_ACCT_NIELSENCODE_MAPPING
WHERE 
    versionnumber < 0 
    OR versionflag IS NULL 
    OR name IS NULL 
    OR validationstatus IN ('Pending', 'Invalid');


This query is designed to identify records with negative version numbers, null values in important fields 'versionflag' and 'name', and entries with validation statuses that are either 'Pending' or 'Invalid', which could indicate anomalies.
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_MASTER
solution: Detect anomalies in 'ranking' and 'yearmo' columns. 'ranking' should be a positive integer and 'yearmo' should follow 'YYYYMM' format. 
snowflake query: 
SELECT * 
FROM SDL_KR_COUPANG_PRODUCT_MASTER 
WHERE TRY_TO_NUMBER(ranking) IS NULL OR TRY_TO_NUMBER(ranking) <= 0 
OR LENGTH(yearmo) != 6 
OR TRY_TO_NUMBER(SUBSTR(yearmo, 1, 4)) IS NULL 
OR TRY_TO_NUMBER(SUBSTR(yearmo, 5, 2)) > 12 
OR TRY_TO_NUMBER(SUBSTR(yearmo, 5, 2)) < 1;
========================================================================================================================================

table_name : SDL_CSL_UDCMASTER
solution : Identify and correct negative values in columns where they are not expected, such as 'COLUMNPRECISION', 'EDITABLE', 'RUN_ID', and ensure 'CREATEDUSERID' matches 'MASTERID'.
snowflake query : 
SELECT *
FROM SDL_CSL_UDCMASTER
WHERE 
    COLUMNPRECISION < 0 OR 
    EDITABLE < 0 OR 
    RUN_ID < 0 OR 
    CREATEDUSERID <> MASTERID;
========================================================================================================================================

table_name: SDL_MY_ACCRUALS
solution: Detect negative values, inconsistent data types, and ensure valid timestamps. For negative values, verify if they are correct or result from data entry errors. Convert numerical columns to appropriate data types. Ensure timestamp columns contain valid timestamps.
snowflake_query: 
SELECT * 
FROM SDL_MY_ACCRUALS 
WHERE 
  TRY_TO_NUMBER(JAN_VAL) < 0 OR 
  TRY_TO_NUMBER(FEB_VAL) < 0 OR 
  TRY_TO_NUMBER(MAR_VAL) < 0 OR 
  TRY_TO_NUMBER(APR_VAL) < 0 OR 
  TRY_TO_NUMBER(MAY_VAL) < 0 OR 
  TRY_TO_NUMBER(JUN_VAL) < 0 OR 
  TRY_TO_NUMBER(JUL_VAL) < 0 OR 
  TRY_TO_NUMBER(AUG_VAL) < 0 OR 
  TRY_TO_NUMBER(SEP_VAL) < 0 OR 
  TRY_TO_NUMBER(OCT_VAL) < 0 OR 
  TRY_TO_NUMBER(NOV_VAL) < 0 OR 
  TRY_TO_NUMBER(DEC_VAL) < 0 OR 
  TRY_TO_TIMESTAMP(CURR_DT) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_SG_PRODUCT_EXCEPTIONS
solution: Detect anomalies in data such as negative item codes, duplicate version numbers, and missing item descriptions. Ensure data integrity by setting constraints and performing regular data audits.
snowflake query: 
SELECT * 
FROM SDL_MDS_SG_PRODUCT_EXCEPTIONS
WHERE itemcode < 0
   OR versionnumber IN (
       SELECT versionnumber
       FROM SDL_MDS_SG_PRODUCT_EXCEPTIONS
       GROUP BY versionnumber
       HAVING COUNT(*) > 1
   )
   OR itemdescription IS NULL;
========================================================================================================================================

table_name: SDL_CHS_DSTR
solution: Address negative values in 'last_cost' and 'soo_qty', ensure 'status' matches data logic, and verify 'primary_gtin' uniqueness.
snowflake query: 
SELECT * 
FROM SDL_CHS_DSTR 
WHERE last_cost < 0 
   OR soo_qty < 0 
   OR (status NOT IN ('Active', 'Inactive')) 
   OR primary_gtin IS NULL 
   OR primary_gtin IN (
       SELECT primary_gtin 
       FROM SDL_CHS_DSTR 
       GROUP BY primary_gtin 
       HAVING COUNT(*) > 1
   );
========================================================================================================================================

table_name: SDL_ID_POS_IDM_SELLOUT
solution: 
1. Detect duplicate PLUs and handle appropriately to ensure unique identifiers.
2. Identify and address negative values in the 'values' column to maintain data integrity.

snowflake query: 
-- Query to detect duplicate PLUs
WITH Duplicate_PLUs AS (
    SELECT PLU, COUNT(*) AS PLU_Count
    FROM SDL_ID_POS_IDM_SELLOUT
    GROUP BY PLU
    HAVING COUNT(*) > 1
)
-- Query to identify negative values
SELECT *
FROM SDL_ID_POS_IDM_SELLOUT
WHERE PLU IN (SELECT PLU FROM Duplicate_PLUs)
   OR values < 0;
========================================================================================================================================

table_name: SDL_CHW_ECOMM_DATA
solution: Identify negative values in 'SALES_ONLINE' and 'UNIT_ONLINE' as they indicate potential data entry errors. Also, check consistency of 'MAT_YEAR' for future years which might be incorrect.
snowflake query: 
SELECT *
FROM SDL_CHW_ECOMM_DATA
WHERE 
    TRY_TO_NUMBER(SALES_ONLINE) < 0
    OR TRY_TO_NUMBER(UNIT_ONLINE) < 0
    OR TRY_TO_NUMBER(MAT_YEAR) > EXTRACT(YEAR FROM CURRENT_DATE);
========================================================================================================================================

table_name: SDL_ECOM_SHOPEE_COMPENSATION
solution: Analyze for NULL values, mismatched data types, and outliers in numerical fields. Ensure data consistency and enforce constraints where applicable.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_ECOM_SHOPEE_COMPENSATION 
WHERE 
    PO_CMPT_MNTH IS NULL OR 
    TYPE IS NULL OR 
    SCM_BARCODE IS NULL OR 
    PRODUCT_NAME IS NULL OR 
    ORDER_NO IS NULL OR 
    STATUS IS NULL OR 
    CRT_TM IS NULL OR 
    DLVRY_TM IS NULL OR 
    SUM_OF_QTY IS NULL OR 
    SUM_OF_RSPXQTY IS NULL OR 
    SUM_OF_TOTAL_NET_SELLING_PRICE IS NULL OR 
    SUM_OF_DIS_SHOPEE IS NULL OR 
    SUM_OF_LTPXQTY IS NULL OR 
    SUM_OF_FRONT_MARGIN IS NULL OR 
    SUM_OF_ENABLER_MARGIN IS NULL OR 
    SUM_OF_COMPENSATION IS NULL OR 
    CRTD_DTTM IS NULL OR 
    FILENAME IS NULL OR 
    SUM_OF_QTY < 0 OR 
    SUM_OF_RSPXQTY < 0 OR 
    SUM_OF_TOTAL_NET_SELLING_PRICE < 0 OR 
    SUM_OF_DIS_SHOPEE < 0 OR 
    SUM_OF_LTPXQTY < 0 OR 
    SUM_OF_FRONT_MARGIN < 0 OR 
    SUM_OF_ENABLER_MARGIN < 0 OR 
    SUM_OF_COMPENSATION < 0;
========================================================================================================================================

table_name: SDL_MDS_MY_SKU_BENCHMARKS  
solution: Detect inconsistent or duplicate entries by checking for duplicate IDs or overlapping date ranges for the same product. Ensure data integrity by verifying the uniqueness of key identifiers and consistency in date ranges.  
snowflake query:  

sql
SELECT 
    ID, 
    COUNT(*) as duplicate_count 
FROM 
    SDL_MDS_MY_SKU_BENCHMARKS 
GROUP BY 
    ID 
HAVING 
    COUNT(*) > 1;

SELECT 
    ID, 
    NAME, 
    VALID_FROM, 
    VALID_TO 
FROM 
    SDL_MDS_MY_SKU_BENCHMARKS 
WHERE 
    VALID_FROM >= VALID_TO;

SELECT 
    ID,
    COUNT(*) as overlapping_count
FROM 
    SDL_MDS_MY_SKU_BENCHMARKS 
GROUP BY 
    ID
HAVING 
    COUNT(DISTINCT VALID_FROM, VALID_TO) < COUNT(*);
========================================================================================================================================

table_name: SDL_KR_BO_YOUNG_JONG_HAP_LOGISTICS_GT_SELLOUT
solution: Identify negative or zero quantities and unit prices. Ensure data integrity by verifying with source, and correct erroneous data entries.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_KR_BO_YOUNG_JONG_HAP_LOGISTICS_GT_SELLOUT 
WHERE 
    TRY_TO_NUMBER(QTY) <= 0 
    OR TRY_TO_NUMBER(UNIT_PRICE) <= 0;


This query checks for anomalies in the `QTY` and `UNIT_PRICE` columns by filtering for records where either value is zero or negative, which are typically anomalies in sales data. The `TRY_TO_NUMBER` function is used to safely convert text to numbers for comparison.
========================================================================================================================================

table_name: SDL_JNJ_MER_COP
solution: Detect missing or irregular data, such as empty fields or non-standard date formats, and ensure data integrity by applying constraints or regular updates to clean data.
snowflake_query: 
SELECT 
    * 
FROM 
    SDL_JNJ_MER_COP 
WHERE 
    COP_DATE IS NULL 
    OR TRY_TO_DATE(COP_DATE, 'YYYY-MM-DD') IS NULL
    OR EMP_ADDRESS_PC IS NULL 
    OR PC_NAME IS NULL 
    OR SURVEY_NAME IS NULL 
    OR EMP_ADDRESS_SUPERVISOR IS NULL 
    OR SUPERVISOR_NAME IS NULL 
    OR COP_PRIORITY IS NULL 
    OR TRY_TO_DATE(START_DATE, 'YYYY-MM-DD') IS NULL 
    OR TRY_TO_DATE(END_DATE, 'YYYY-MM-DD') IS NULL 
    OR AREA IS NULL 
    OR CHANNEL IS NULL 
    OR ACCOUNT IS NULL 
    OR STORE_ID IS NULL 
    OR STORE_NAME IS NULL 
    OR QUESTION IS NULL 
    OR ANSWER IS NULL 
    OR RUN_ID IS NULL 
    OR FILE_NAME IS NULL 
    OR YEARMO IS NULL 
    OR ACTIVITY IS NULL 
    OR CATEGORY IS NULL 
    OR BRAND IS NULL 
    OR COMPLIANCE IS NULL;
========================================================================================================================================

table_name: SDL_JNJ_CONSUMERREACH_711
solution: Identify NULL values, duplicate rows, and abnormal data entries.
snowflake query: 
SELECT * 
FROM SDL_JNJ_CONSUMERREACH_711
WHERE 
    retailname IS NULL 
    OR retailprovince IS NULL 
    OR jjskuname IS NULL 
    OR COUNT(1) OVER(PARTITION BY id, cdate, retail, jjskubarcode) > 1 
    OR LENGTH(jjskubarcode) != 13 
    OR NOT TRY_CAST(run_id AS NUMBER) IS NOT NULL
    OR status NOT IN ('Active', 'Inactive');
========================================================================================================================================

table_name: SDL_POP6_SG_PRODUCT_LISTS_POPS
solution: Identify missing or NULL values, duplicate entries, and inconsistent data types. Ensure all dates are valid and timestamps are in the correct range.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    SUM(CASE WHEN CRTD_DTTM IS NULL THEN 1 ELSE 0 END) AS null_crtd_dttm,
    SUM(CASE WHEN FILE_NAME IS NULL THEN 1 ELSE 0 END) AS null_file_name,
    SUM(CASE WHEN POP_NAME IS NULL THEN 1 ELSE 0 END) AS null_pop_name,
    SUM(CASE WHEN PROD_GRP_DATE IS NULL THEN 1 ELSE 0 END) AS null_prod_grp_date,
    SUM(CASE WHEN PRODUCT_LIST IS NULL THEN 1 ELSE 0 END) AS null_product_list,
    SUM(CASE WHEN POP_CODE IS NULL THEN 1 ELSE 0 END) AS null_pop_code,
    SUM(CASE WHEN RUN_ID IS NULL THEN 1 ELSE 0 END) AS null_run_id,
    SUM(CASE WHEN POPDB_ID IS NULL THEN 1 ELSE 0 END) AS null_popdb_id,
    SUM(CASE WHEN HASHKEY IS NULL THEN 1 ELSE 0 END) AS null_hashkey,
    COUNT(DISTINCT HASHKEY) AS unique_hashkeys,
    COUNT(*) - COUNT(DISTINCT HASHKEY) AS duplicate_hashkeys,
    COUNT(DISTINCT CRTD_DTTM) AS unique_crtd_dttms,
    COUNT(DISTINCT FILE_NAME) AS unique_file_names,
    COUNT(DISTINCT POP_NAME) AS unique_pop_names,
    COUNT(DISTINCT PROD_GRP_DATE) AS unique_prod_grp_dates,
    COUNT(DISTINCT PRODUCT_LIST) AS unique_product_lists,
    COUNT(DISTINCT POP_CODE) AS unique_pop_codes,
    COUNT(DISTINCT RUN_ID) AS unique_run_ids,
    COUNT(DISTINCT POPDB_ID) AS unique_popdb_ids
FROM SDL_POP6_SG_PRODUCT_LISTS_POPS;
========================================================================================================================================

table_name: PROD_PRODUCT
solution: Identify negative or unrealistic values in 'WIDTH' and 'MAXIMUMORDERQUANTITY' columns. Ensure 'WIDTH' is positive and 'MAXIMUMORDERQUANTITY' is a realistic non-negative number. Validate 'ISLISTED', 'ISORDERABLE', and 'ISRETURNABLE' columns contain valid entries ('yes' or 'no').

snowflake query: 
SELECT 
    * 
FROM 
    PROD_PRODUCT 
WHERE 
    WIDTH < 0 
    OR MAXIMUMORDERQUANTITY < 0 
    OR WIDTH IS NULL 
    OR MAXIMUMORDERQUANTITY IS NULL 
    OR ISLISTED NOT IN ('yes', 'no') 
    OR ISORDERABLE NOT IN ('yes', 'no') 
    OR ISRETURNABLE NOT IN ('yes', 'no');
========================================================================================================================================

table_name: SDL_MDS_SG_CUSTOMER_HIERARCHY
solution: Detect negative IDs and version numbers, validate changetrackingmask, ensure timestamps are logical, and check validation status consistency.
snowflake query: 
SELECT * 
FROM SDL_MDS_SG_CUSTOMER_HIERARCHY
WHERE id < 0
   OR versionnumber < 0
   OR changetrackingmask < 0
   OR enterdatetime > lastchgdatetime
   OR validationstatus NOT IN ('Pending', 'Validated', 'Invalid');
========================================================================================================================================

table_name : SDL_CLAVIS_GB_SEARCH_TERMS_RESULTS
solution : Identify and handle empty or null values, check for inconsistent data types, and detect duplicates or outliers in numeric columns.
snowflake query : 
SELECT 
    client_id, id, type, report_date, region, search_term, online_store, brand, category, 
    manufacturer, dimension1, dimension2, dimension3, dimension4, dimension5, dimension6, 
    dimension7, dimension8, is_competitor, is_priority_search_term, results_per_page, 
    trusted_rpc, trusted_upc, trusted_mpc, trusted_product_description, harvested_url, 
    harvested_product_image_url, harvested_product_description, search_results_rank, 
    search_results_is_paid, search_results_basic_score, search_results_weighted_score, 
    search_results_priority_score, search_results_segment, search_results_segment_value, 
    search_results_max_rank, ext_page_no, etl_run_id, etl_load_dttm, delete_ind, run_id
FROM SDL_CLAVIS_GB_SEARCH_TERMS_RESULTS
WHERE 
    client_id IS NULL OR
    id IS NULL OR
    type IS NULL OR
    report_date IS NULL OR
    region IS NULL OR
    search_term IS NULL OR
    online_store IS NULL OR
    brand IS NULL OR
    category IS NULL OR
    manufacturer IS NULL OR
    is_competitor IS NULL OR
    is_priority_search_term IS NULL OR
    trusted_rpc IS NULL OR
    trusted_upc IS NULL OR
    trusted_mpc IS NULL OR
    trusted_product_description IS NULL OR
    harvested_url IS NULL OR
    harvested_product_image_url IS NULL OR
    harvested_product_description IS NULL OR
    search_results_rank IS NULL OR
    search_results_is_paid IS NULL OR
    search_results_basic_score IS NULL OR
    search_results_weighted_score IS NULL OR
    search_results_priority_score IS NULL OR
    search_results_segment IS NULL OR
    search_results_segment_value IS NULL OR
    search_results_max_rank IS NULL OR
    ext_page_no IS NULL OR
    etl_run_id IS NULL OR
    etl_load_dttm IS NULL OR
    delete_ind IS NULL OR
    run_id IS NULL
UNION
SELECT 
    client_id, id, type, report_date, region, search_term, online_store, brand, category, 
    manufacturer, dimension1, dimension2, dimension3, dimension4, dimension5, dimension6, 
    dimension7, dimension8, is_competitor, is_priority_search_term, results_per_page, 
    trusted_rpc, trusted_upc, trusted_mpc, trusted_product_description, harvested_url, 
    harvested_product_image_url, harvested_product_description, search_results_rank, 
    search_results_is_paid, search_results_basic_score, search_results_weighted_score, 
    search_results_priority_score, search_results_segment, search_results_segment_value, 
    search_results_max_rank, ext_page_no, etl_run_id, etl_load_dttm, delete_ind, run_id
FROM SDL_CLAVIS_GB_SEARCH_TERMS_RESULTS
GROUP BY 
    client_id, id, type, report_date, region, search_term, online_store, brand, category, 
    manufacturer, dimension1, dimension2, dimension3, dimension4, dimension5, dimension6, 
    dimension7, dimension8, is_competitor, is_priority_search_term, results_per_page, 
    trusted_rpc, trusted_upc, trusted_mpc, trusted_product_description, harvested_url, 
    harvested_product_image_url, harvested_product_description, search_results_rank, 
    search_results_is_paid, search_results_basic_score, search_results_weighted_score, 
    search_results_priority_score, search_results_segment, search_results_segment_value, 
    search_results_max_rank, ext_page_no, etl_run_id, etl_load_dttm, delete_ind, run_id
HAVING COUNT(*) > 1;
========================================================================================================================================

sql
table_name : SDL_DISTRIBUTOR_CUSTOMER_DIM
solution : Detect anomalies like missing distributor names, mismatched city and postal codes, and potential duplicate records.
snowflake query : 
SELECT 
    key_outlet, 
    jj_sap_dstrbtr_id, 
    jj_sap_dstrbtr_nm, 
    cust_id, 
    cust_nm, 
    address, 
    city, 
    cust_grp, 
    chnl, 
    outlet_type, 
    chnl_grp, 
    jjid, 
    pst_cd, 
    cust_id_map, 
    cust_nm_map, 
    chnl_grp2, 
    cust_crtd_dt, 
    cust_grp2, 
    crtd_dttm, 
    updt_dttm, 
    file_name
FROM 
    SDL_DISTRIBUTOR_CUSTOMER_DIM
WHERE 
    jj_sap_dstrbtr_nm IS NULL 
    OR (city IS NULL AND pst_cd IS NOT NULL) 
    OR (city IS NOT NULL AND pst_cd IS NULL)
    OR cust_id IN (
        SELECT cust_id
        FROM SDL_DISTRIBUTOR_CUSTOMER_DIM
        GROUP BY cust_id
        HAVING COUNT(*) > 1
    );
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_CUSTOMER_DIM_ADFTEMP
solution: Address missing distributor names and ensure all timestamps are in proper datetime format.
snowflake query: 
SELECT 
    key_outlet,
    jj_sap_dstrbtr_id,
    jj_sap_dstrbtr_nm,
    cust_id,
    cust_nm,
    address,
    city,
    cust_grp,
    chnl,
    outlet_type,
    chnl_grp,
    jjid,
    pst_cd,
    cust_id_map,
    cust_nm_map,
    chnl_grp2,
    cust_crtd_dt,
    cust_grp2,
    crtd_dttm,
    updt_dttm,
    file_name
FROM SDL_DISTRIBUTOR_CUSTOMER_DIM_ADFTEMP
WHERE jj_sap_dstrbtr_nm IS NULL
   OR TRY_TO_TIMESTAMP(crtd_dttm) IS NULL
   OR TRY_TO_TIMESTAMP(updt_dttm) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_VN_ECOM_TARGET
solution: Detect anomalies such as duplicate entries and mismatched version numbers, and ensure referential integrity.
snowflake query: 
WITH DuplicateRecords AS (
    SELECT id, COUNT(*) AS cnt
    FROM SDL_MDS_VN_ECOM_TARGET
    GROUP BY id
    HAVING COUNT(*) > 1
),
MismatchedVersions AS (
    SELECT id, versionnumber, version_id
    FROM SDL_MDS_VN_ECOM_TARGET
    WHERE versionnumber != version_id
),
ReferentialIntegrity AS (
    SELECT id, platform
    FROM SDL_MDS_VN_ECOM_TARGET
    WHERE platform NOT IN (SELECT DISTINCT platform FROM SomeRelatedTable)
)
SELECT * FROM DuplicateRecords
UNION ALL
SELECT * FROM MismatchedVersions
UNION ALL
SELECT * FROM ReferentialIntegrity;
========================================================================================================================================

table_name: MRCHR_MERCHANDISINGRESPONSE
solution: Identify and address negative or unexpected values, inconsistent start and end times, and possible data entry errors in the 'fetchedsequence', 'starttime', and 'endtime' columns.
snowflake_query: 
SELECT * 
FROM MRCHR_MERCHANDISINGRESPONSE
WHERE FETCHEDSEQUENCE < 0
   OR TO_TIMESTAMP(STARTDATE || ' ' || STARTTIME) > TO_TIMESTAMP(ENDDATE || ' ' || ENDTIME)
   OR STATUS NOT IN ('Completed', 'In Progress', 'Rejected', 'Pending');
========================================================================================================================================

table_name: SDL_MDS_VN_TOPDOOR_STORETYPE_MAPPING
solution: Identify and correct negative or unexpected values in 'changetrackingmask' and 'id'. Verify 'versionflag' consistency with 'versionname'. Ensure 'validationstatus' matches data integrity.
snowflake query: 
SELECT * 
FROM SDL_MDS_VN_TOPDOOR_STORETYPE_MAPPING
WHERE 
  id < 0 OR 
  changetrackingmask < 0 OR 
  (versionflag = 'inactive' AND versionname = 'v1.0') OR 
  (validationstatus = 'Invalid' AND NOT (
    code LIKE 'ST%' AND 
    storetype IN ('Retail', 'Wholesale') AND 
    top_door_group IN ('Top Group', 'Bottom Group', 'Middle Group')
  ));
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_RANKING_WEEKLY
solution: Check for missing or null values in critical fields and enforce column constraints. Analyze for duplicated data to ensure data quality.
snowflake query: 
SELECT 
    COUPANG_SKU_ID, 
    COUPANG_SKU_NAME, 
    PRODUCT_RANKING_DATE,
    COUNT(*) AS COUNT
FROM 
    SDL_KR_COUPANG_PRODUCT_RANKING_WEEKLY
WHERE 
    COUPANG_SKU_ID IS NULL
    OR COUPANG_SKU_NAME IS NULL
    OR PRODUCT_RANKING_DATE IS NULL
GROUP BY 
    COUPANG_SKU_ID, 
    COUPANG_SKU_NAME, 
    PRODUCT_RANKING_DATE
HAVING 
    COUNT(*) > 1;

-- Query to check for duplicates
SELECT 
    COUPANG_SKU_ID, 
    PRODUCT_RANKING_DATE, 
    COUNT(*) AS COUNT
FROM 
    SDL_KR_COUPANG_PRODUCT_RANKING_WEEKLY
GROUP BY 
    COUPANG_SKU_ID, 
    PRODUCT_RANKING_DATE
HAVING 
    COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_MDS_VN_ALLCHANNEL_SISO_TARGET_SKU
solution: Check for missing or null values, as well as duplicates in key columns such as 'ID', 'MUID', and 'VERSIONNUMBER'. Verify proper data types and logical consistency across records.
snowflake query: 
SELECT 
    COUNT(*) AS total_records,
    COUNT(DISTINCT ID) AS unique_ids,
    COUNT(DISTINCT MUID) AS unique_muids,
    COUNT(DISTINCT VERSIONNUMBER) AS unique_versionnumbers,
    SUM(CASE WHEN ID IS NULL THEN 1 ELSE 0 END) AS null_ids,
    SUM(CASE WHEN MUID IS NULL THEN 1 ELSE 0 END) AS null_muids,
    SUM(CASE WHEN VERSIONNUMBER IS NULL THEN 1 ELSE 0 END) AS null_versionnumbers,
    SUM(CASE WHEN NOT (DATA_TYPE IN ('TEXT', 'NUMBER', 'TIMESTAMP_NTZ')) THEN 1 ELSE 0 END) AS invalid_data_types
FROM SDL_MDS_VN_ALLCHANNEL_SISO_TARGET_SKU;
========================================================================================================================================

table_name: SDL_POP6_SG_PRODUCT_LISTS_PRODUCTS
solution: 
1. Validate 'msl_ranking' to ensure it contains valid rankings, not arbitrary text like 'low' or '9999'.
2. Ensure 'run_id' is a non-negative number.
3. Verify 'prod_grp_date' and 'crtd_dttm' for logical consistency and ensure 'prod_grp_date' is not in the future.
4. Validate 'sku' and 'productdb_id' for proper formatting according to business rules.
snowflake query: 
SELECT * 
FROM SDL_POP6_SG_PRODUCT_LISTS_PRODUCTS
WHERE 
    (NOT TRY_CAST(msl_ranking AS NUMBER) IS NOT NULL OR msl_ranking NOT IN ('rank')) OR
    (run_id < 0) OR
    (prod_grp_date > CURRENT_DATE) OR
    (productdb_id NOT LIKE 'DB%') OR
    (sku NOT LIKE 'SKU%');
========================================================================================================================================

table_name: SDL_MDS_SG_STORE_MASTER
solution: Identify anomalies in 'changetrackingmask' with negative values and 'enterversionnumber' with negative values.
snowflake query: 
SELECT * 
FROM SDL_MDS_SG_STORE_MASTER
WHERE CHANGETRACKINGMASK < 0 OR ENTERVERSIONNUMBER < 0;
========================================================================================================================================

table_name: SDL_ECOMMERCE_OFFTAKE_AMAZON
solution: Detect negative and zero quantities, and negative MRP off-take values. Review data entry and calculations for accuracy. Ensure MRP off-take calculations reflect realistic sales data.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_ECOMMERCE_OFFTAKE_AMAZON 
WHERE 
    QUANTITY <= 0 
    OR MRP_OFFTAKES_VALUE < 0;
========================================================================================================================================

table_name: SDL_CSL_SCHEME_HEADER
solution: Identify columns with empty or null data and verify data integrity. Ensure data is populated correctly and constraints are applied.
snowflake query: 
SELECT 
    schid, schcode, schdsc, claimable, clmamton, cmpschcode, schlevel_id, schtype, 
    flexisch, flexischtype, combisch, range, prorata, qps, qpsreset, schvalidfrom, 
    schvalidtill, schstatus, budget, adjwindisponlyonce, purofevery, apyqpssch, 
    setwindowdisp, editscheme, schlvlmode, createduserid, createddate, modifiedby, 
    modifieddate, versionno, serialno, claimgrpcode, fbm, combitype, allowuncheck, 
    settlementtype, consumerpromo, wdsbillscount, wdscapamount, wdsminpurqty, run_id, 
    crt_dttm, file_name 
FROM SDL_CSL_SCHEME_HEADER 
WHERE schid IS NULL 
   OR schcode IS NULL 
   OR schdsc IS NULL 
   OR claimable IS NULL 
   OR clmamton IS NULL 
   OR cmpschcode IS NULL 
   OR schlevel_id IS NULL 
   OR schtype IS NULL 
   OR flexisch IS NULL 
   OR flexischtype IS NULL 
   OR combisch IS NULL 
   OR range IS NULL 
   OR prorata IS NULL 
   OR qps IS NULL 
   OR qpsreset IS NULL 
   OR schvalidfrom IS NULL 
   OR schvalidtill IS NULL 
   OR schstatus IS NULL 
   OR budget IS NULL 
   OR adjwindisponlyonce IS NULL 
   OR purofevery IS NULL 
   OR apyqpssch IS NULL 
   OR setwindowdisp IS NULL 
   OR editscheme IS NULL 
   OR schlvlmode IS NULL 
   OR createduserid IS NULL 
   OR createddate IS NULL 
   OR modifiedby IS NULL 
   OR modifieddate IS NULL 
   OR versionno IS NULL 
   OR serialno IS NULL 
   OR claimgrpcode IS NULL 
   OR fbm IS NULL 
   OR combitype IS NULL 
   OR allowuncheck IS NULL 
   OR settlementtype IS NULL 
   OR consumerpromo IS NULL 
   OR wdsbillscount IS NULL 
   OR wdscapamount IS NULL 
   OR wdsminpurqty IS NULL 
   OR run_id IS NULL 
   OR crt_dttm IS NULL 
   OR file_name IS NULL;
========================================================================================================================================

sql
table_name: SDL_KR_COUPANG_DAILY_BRAND_REVIEWS
solution: Detect anomalies in review scores and potential duplicates based on key fields.
snowflake query: 
SELECT 
    REVIEW_DATE, 
    COUPANG_SKU_ID, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_KR_COUPANG_DAILY_BRAND_REVIEWS
GROUP BY 
    REVIEW_DATE, 
    COUPANG_SKU_ID
HAVING 
    COUNT(*) > 1
UNION ALL
SELECT 
    REVIEW_DATE, 
    COUPANG_SKU_ID, 
    REVIEW_SCORE_STAR
FROM 
    SDL_KR_COUPANG_DAILY_BRAND_REVIEWS
WHERE 
    TRY_CAST(REVIEW_SCORE_STAR AS INT) IS NULL
    OR CAST(REVIEW_SCORE_STAR AS INT) < 0
    OR CAST(REVIEW_SCORE_STAR AS INT) > 5;


This query first identifies duplicate entries by grouping on `REVIEW_DATE` and `COUPANG_SKU_ID` having more than one record, which may indicate redundancy. It also checks for anomalies in the `REVIEW_SCORE_STAR` column by identifying entries that are not numeric or fall outside the expected score range (0-5).
========================================================================================================================================

table_name: SDL_LA_GT_VISIT
solution: Identify and correct negative or inconsistent data entries, such as negative survey counts, future visits, and inconsistent time entries.
snowflake query: 
SELECT 
    id_sale, 
    sale_name, 
    id_customer, 
    customer_name, 
    date_plan, 
    time_plan, 
    date_visi, 
    time_visi, 
    visit_time, 
    count_survey 
FROM 
    SDL_LA_GT_VISIT
WHERE 
    CAST(count_survey AS INTEGER) < 0 OR 
    date_visi > CURRENT_DATE() OR 
    TO_TIMESTAMP(date_plan || ' ' || time_plan) > TO_TIMESTAMP(date_visi || ' ' || time_visi);


This query checks for negative survey counts, visits scheduled in the future, and time inconsistencies between planned and actual visits.
========================================================================================================================================

table_name: SDL_MDS_MY_PS_WEIGHTS
solution: 
1. Ensure MUIDs are unique across records.
2. Consider positive values for weights or validate the rationale for negative weights.
3. Verify the logical consistency between the 'versionflag' field and other related fields.

snowflake query: 
SELECT 
    *
FROM 
    SDL_MDS_MY_PS_WEIGHTS
WHERE 
    muid IN (
        SELECT muid 
        FROM SDL_MDS_MY_PS_WEIGHTS 
        GROUP BY muid 
        HAVING COUNT(*) > 1
    )
    OR weight < 0
    OR (versionflag = 'inactive' AND validationstatus = 'Valid')
    OR (versionflag = 'active' AND validationstatus = 'Invalid');
========================================================================================================================================

sql
table_name: SDL_MDS_APAC_DCL_CUSTOMERS
solution: Check for missing or null values, and ensure data consistency by comparing related fields.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    SUM(CASE WHEN VERSIONNUMBER IS NULL THEN 1 ELSE 0 END) AS missing_versionnumber,
    SUM(CASE WHEN SALES_CHANNEL_ID IS NULL THEN 1 ELSE 0 END) AS missing_sales_channel_id,
    SUM(CASE WHEN SALES_LOCATION_CODE IS NULL THEN 1 ELSE 0 END) AS missing_sales_location_code,
    SUM(CASE WHEN MUID IS NULL THEN 1 ELSE 0 END) AS missing_muid,
    SUM(CASE WHEN NAME IS NULL THEN 1 ELSE 0 END) AS missing_name,
    SUM(CASE WHEN RETAILER_NAME_CODE IS NULL THEN 1 ELSE 0 END) AS missing_retailer_name_code,
    SUM(CASE WHEN CTRY_KEY_ID IS NULL THEN 1 ELSE 0 END) AS missing_ctry_key_id,
    SUM(CASE WHEN VERSIONFLAG IS NULL THEN 1 ELSE 0 END) AS missing_versionflag,
    SUM(CASE WHEN CODE IS NULL THEN 1 ELSE 0 END) AS missing_code,
    SUM(CASE WHEN ENTERUSERNAME IS NULL THEN 1 ELSE 0 END) AS missing_enterusername,
    SUM(CASE WHEN REMARKS IS NULL THEN 1 ELSE 0 END) AS missing_remarks,
    SUM(CASE WHEN VALIDATIONSTATUS IS NULL THEN 1 ELSE 0 END) AS missing_validationstatus,
    SUM(CASE WHEN LASTCHGUSERNAME IS NULL THEN 1 ELSE 0 END) AS missing_lastchgusername
FROM SDL_MDS_APAC_DCL_CUSTOMERS;
========================================================================================================================================

table_name: SDL_JNJ_CONSUMERREACH_SFM
solution: Detect anomalies in distribution values and yearmo formatting. Exclude negative distribution and non-standard yearmo values.
snowflake query: 
SELECT *
FROM SDL_JNJ_CONSUMERREACH_SFM
WHERE CAST(distribution AS NUMBER) < 0
   OR NOT REGEXP_LIKE(yearmo, '^\d{6}$');
========================================================================================================================================

table_name: SDL_MDS_VN_SKU_BENCHMARKS
solution: 
1. Check for missing or null values in important fields like 'muid'.
2. Identify records with 'jj_target' as negative or zero, which may indicate incorrect data.
3. Ensure 'valid_from' is always earlier than 'valid_to'.
4. Detect records where 'lastchgdatetime' is before 'enterdatetime', which might indicate data entry errors.
5. Verify if 'versionflag' values are within a predefined set of expected values.

snowflake query: 
-- Detect missing or null values in 'muid'
SELECT * FROM SDL_MDS_VN_SKU_BENCHMARKS WHERE muid IS NULL;

-- Identify records with 'jj_target' as negative or zero
SELECT * FROM SDL_MDS_VN_SKU_BENCHMARKS WHERE jj_target <= 0;

-- Ensure 'valid_from' is earlier than 'valid_to'
SELECT * FROM SDL_MDS_VN_SKU_BENCHMARKS WHERE valid_from >= valid_to;

-- Detect records where 'lastchgdatetime' is before 'enterdatetime'
SELECT * FROM SDL_MDS_VN_SKU_BENCHMARKS WHERE lastchgdatetime < enterdatetime;

-- Verify 'versionflag' values
SELECT * FROM SDL_MDS_VN_SKU_BENCHMARKS WHERE versionflag NOT IN ('Updated', 'Beta', 'Nu', 'Omicron');
========================================================================================================================================

table_name: SDL_ECOM_AMS  
solution: Address negative quantities and verify deduction logic.  
snowflake query:  
SELECT *  
FROM SDL_ECOM_AMS  
WHERE QTY < 0  
   OR (DEDUCTION_STATUS = 'Completed' AND DEDUCTION_METHOD = 'Manual')  
   OR (VERIFIED_STATUS = 'No' AND ORDER_COMPLETED_TIME IS NOT NULL);
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_MERCHANDISING
solution: Identify anomalies by checking for null values, duplicates, and ensuring data type integrity. Consider implementing data validation checks and constraints to maintain data quality.
snowflake query: 
SELECT 
    DISTRIBUTOR_CODE, 
    DISTRIBUTOR_NAME, 
    SALES_REPCODE, 
    SALES_REPNAME, 
    CHANNEL_NAME, 
    SUB_CHANNEL_NAME, 
    RETAILER_CODE, 
    RETAILER_NAME, 
    MONTH, 
    SURVEYDATE, 
    AQ_NAME, 
    SRD_ANSWER, 
    LINK, 
    CDL_DTTM, 
    RUN_ID, 
    FILE_NAME
FROM SDL_DISTRIBUTOR_IVY_MERCHANDISING
WHERE 
    DISTRIBUTOR_CODE IS NULL OR 
    DISTRIBUTOR_NAME IS NULL OR 
    SALES_REPCODE IS NULL OR 
    SALES_REPNAME IS NULL OR 
    CHANNEL_NAME IS NULL OR 
    SUB_CHANNEL_NAME IS NULL OR 
    RETAILER_CODE IS NULL OR 
    RETAILER_NAME IS NULL OR 
    MONTH IS NULL OR 
    SURVEYDATE IS NULL OR 
    AQ_NAME IS NULL OR 
    SRD_ANSWER IS NULL OR 
    LINK IS NULL OR 
    CDL_DTTM IS NULL OR 
    FILE_NAME IS NULL OR 
    RUN_ID IS NULL OR 
    (SELECT COUNT(*) FROM SDL_DISTRIBUTOR_IVY_MERCHANDISING t1 WHERE t1.DISTRIBUTOR_CODE = SDL_DISTRIBUTOR_IVY_MERCHANDISING.DISTRIBUTOR_CODE) > 1;
========================================================================================================================================

table_name: SDL_MDS_MY_GT_PRODUCT_MAPPING
solution: 
1. Check for negative values in 'versionnumber' and 'enterversionnumber', as these should logically be non-negative.
2. Ensure 'enterdatetime' and 'lastchgdatetime' are not in the future.
3. Verify 'validationstatus' should only have valid values like 'Valid' or 'Invalid' and not any other unexpected text.
4. Check consistency between 'versionnumber' and 'version_id', ensuring 'version_id' is unique for each version.
5. Ensure 'muid' is unique across the table as it should represent a unique identifier.

snowflake query: 
SELECT * FROM SDL_MDS_MY_GT_PRODUCT_MAPPING 
WHERE versionnumber < 0 
   OR enterversionnumber < 0 
   OR enterdatetime > CURRENT_TIMESTAMP() 
   OR lastchgdatetime > CURRENT_TIMESTAMP() 
   OR validationstatus NOT IN ('Valid', 'Invalid')
   OR muid IN (SELECT muid FROM SDL_MDS_MY_GT_PRODUCT_MAPPING GROUP BY muid HAVING COUNT(*) > 1)
   OR version_id IN (SELECT version_id FROM SDL_MDS_MY_GT_PRODUCT_MAPPING GROUP BY version_id HAVING COUNT(*) > 1);
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_SUMMARY_WEEKLY
solution: The anomalies detected include negative rankings and inconsistent data types where a number is expected. To resolve this, ensure that the rankings are positive and validate data types during data ingestion.
snowflake query: 
SELECT *
FROM SDL_KR_COUPANG_PRODUCT_SUMMARY_WEEKLY
WHERE TRY_TO_NUMBER(RANKING) IS NULL OR TRY_TO_NUMBER(RANKING) < 0 OR RUN_ID IS NULL;
========================================================================================================================================

table_name: SDL_MDS_SG_SKU_BENCHMARKS
solution: 
1. Check for rows where `valid_from` is after `valid_to`.
2. Verify `variance` values are within an acceptable range based on business logic.
3. Ensure `validationstatus` is consistent across similar entries.

snowflake query: 
SELECT * FROM SDL_MDS_SG_SKU_BENCHMARKS
WHERE valid_from > valid_to
   OR variance < 0
   OR (validationstatus = 'invalid' AND versionflag = 'active')
   OR (validationstatus = 'valid' AND versionflag <> 'active');
========================================================================================================================================

Certainly! Below is the requested information:


table_name: SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
solution: Identify missing or null values, duplicate entries, and inconsistent or invalid data types. Ensure referential integrity and consistent naming conventions.
snowflake query: 
-- Query to check for NULL or missing values
SELECT *
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
WHERE id IS NULL OR muid IS NULL OR versionname IS NULL OR versionnumber IS NULL 
  OR version_id IS NULL OR versionflag IS NULL OR name IS NULL OR code IS NULL 
  OR changetrackingmask IS NULL OR group_shop_type_code IS NULL OR group_shop_type_name IS NULL 
  OR group_shop_type_id IS NULL OR re_code IS NULL OR re_name IS NULL OR re_id IS NULL 
  OR msl_re_code IS NULL OR msl_re_name IS NULL OR msl_re_id IS NULL OR channel_code IS NULL 
  OR channel_name IS NULL OR channel_id IS NULL OR enterdatetime IS NULL OR enterusername IS NULL 
  OR enterversionnumber IS NULL OR lastchgdatetime IS NULL OR lastchgusername IS NULL 
  OR lastchgversionnumber IS NULL OR validationstatus IS NULL;

-- Query to identify duplicate entries
SELECT id, COUNT(*)
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
GROUP BY id
HAVING COUNT(*) > 1;

-- Query to check for invalid data types (e.g., non-numeric values in numeric fields)
SELECT *
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
WHERE TRY_TO_NUMBER(versionnumber) IS NULL
  OR TRY_TO_NUMBER(re_id) IS NULL
  OR TRY_TO_NUMBER(channel_id) IS NULL;

-- Query to ensure referential integrity
-- Example: Verify if re_id exists in another related table (assuming a related table exists)
SELECT a.re_id
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING a
LEFT JOIN related_table b ON a.re_id = b.re_id
WHERE b.re_id IS NULL;

-- Query for consistent naming conventions (e.g., check for unexpected characters in codes)
SELECT *
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
WHERE code NOT RLIKE '^[A-Z0-9_]+$';


This set of queries will help identify potential anomalies and support data integrity verification within the `SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING` table.
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_CUST_CIW_PLAN
solution: The sample data is empty, which indicates a potential issue in data loading or extraction. Ensure the data pipeline is functioning correctly, verify the source data, and check for any filters or conditions that might be excluding data.
snowflake_query: 
SELECT *
FROM SDL_MDS_PACIFIC_CUST_CIW_PLAN
WHERE ID IS NULL OR MUID IS NULL OR VERSIONNAME IS NULL OR VERSIONNUMBER IS NULL OR VERSION_ID IS NULL OR VERSIONFLAG IS NULL OR NAME IS NULL OR CODE IS NULL OR CHANGETRACKINGMASK IS NULL OR TIME_PERIOD IS NULL OR SALES_GRP_CD IS NULL OR PROD_MJR_CD IS NULL OR GOAL_QTY IS NULL OR GOAL_GTS IS NULL OR GOAL_EFF_VAL IS NULL OR GOAL_JGF_SI_VAL IS NULL OR GOAL_PMT_TERMS_VAL IS NULL OR GOAL_DATAINS_VAL IS NULL OR GOAL_EXP_ADJ_VAL IS NULL OR GOAL_JGF_SD_VAL IS NULL OR GOAL_CIW_TOT IS NULL OR GOAL_COGS IS NULL OR GOAL_GP IS NULL OR LOCAL_CCY IS NULL OR TARGET_TYPE IS NULL OR ENTERDATETIME IS NULL OR ENTERUSERNAME IS NULL OR ENTERVERSIONNUMBER IS NULL OR LASTCHGDATETIME IS NULL OR LASTCHGUSERNAME IS NULL OR LASTCHGVERSIONNUMBER IS NULL OR VALIDATIONSTATUS IS NULL;
========================================================================================================================================

table_name: SDL_MARKET_SHARE_QSD
solution: Identify records with negative 'VALUE' which may indicate data entry errors or special cases. Consider reviewing and correcting these records or adding context if the negative value is valid.
snowflake query: 
SELECT * 
FROM SDL_MARKET_SHARE_QSD 
WHERE VALUE < 0;

solution: Check for discrepancies in 'period_date' and 'last period' to ensure temporal data consistency.
snowflake query: 
SELECT * 
FROM SDL_MARKET_SHARE_QSD 
WHERE PERIOD_DATE < LAST_PERIOD;

solution: Verify 'crtd_dttm' against the current date to ensure it's not set in the future.
snowflake query: 
SELECT * 
FROM SDL_MARKET_SHARE_QSD 
WHERE CRTD_DTTM > CURRENT_TIMESTAMP();
========================================================================================================================================

table_name: SDL_MDS_VN_CUSTOMER_SALES_ORGANIZATION
solution: Detect and address the following anomalies:
 1. Inconsistent `versionflag` values with `versionnumber`.
 2. Mismatched `status` and `validationstatus`.
 3. Future dates in `enterdatetime` and `lastchgdatetime`.

snowflake query: 
SELECT 
    id, 
    versionflag, 
    versionnumber, 
    status, 
    validationstatus, 
    enterdatetime, 
    lastchgdatetime 
FROM 
    SDL_MDS_VN_CUSTOMER_SALES_ORGANIZATION
WHERE 
    (versionflag = 'Inactive' AND versionnumber > 10) OR 
    (status = 'Active' AND validationstatus <> 'Valid') OR 
    (status = 'Pending' AND validationstatus = 'Valid') OR 
    enterdatetime > CURRENT_TIMESTAMP() OR 
    lastchgdatetime > CURRENT_TIMESTAMP();
========================================================================================================================================

table_name: SDL_POP6_SG_PLANNED_VISITS
solution: Detect negative run_id values and ensure all columns align with expected data types. Consider setting stricter data validation rules for run_id to prevent negative values, and ensure all data types are consistent with the schema.
snowflake query: 
SELECT * 
FROM SDL_POP6_SG_PLANNED_VISITS 
WHERE run_id < 0 OR 
      TRY_CAST(planned_visit_date AS DATE) IS NULL OR 
      TRY_CAST(crtd_dttm AS TIMESTAMP_NTZ) IS NULL OR 
      TRY_CAST(run_id AS NUMBER) IS NULL OR 
      TRY_CAST(popdb_id AS TEXT) IS NULL OR 
      TRY_CAST(pop_code AS TEXT) IS NULL OR 
      TRY_CAST(pop_name AS TEXT) IS NULL OR 
      TRY_CAST(address AS TEXT) IS NULL OR 
      TRY_CAST(username AS TEXT) IS NULL OR 
      TRY_CAST(user_full_name AS TEXT) IS NULL OR 
      TRY_CAST(file_name AS TEXT) IS NULL;
========================================================================================================================================

table_name: MS_MASTERSURVEY
solution: Identify entries with null or illogical values and ensure data consistency by validating Azure and CDL data against logical constraints. Implement checks and validation rules for data integrity and completeness.
snowflake query: 
SELECT * 
FROM MS_MASTERSURVEY 
WHERE CDL_SOURCE_FILE IS NULL 
   OR CDL_DATETIME IS NULL 
   OR AZUREFILE IS NULL 
   OR AZUREDATETIME IS NULL 
   OR CDL_DATETIME > AZUREDATETIME 
   OR AZUREDATETIME < FETCHEDDATETIME;
========================================================================================================================================

table_name: SDL_COMPETITIVE_BANNER_GROUP
solution: Detect negative 'unit' and 'dollar' values as anomalies. Ensure data integrity by checking for consistent data types and possible outliers.
snowflake query: 
SELECT 
    market, 
    banner, 
    banner_classification, 
    manufacturer, 
    brand, 
    sku_name, 
    apn, 
    time_period, 
    unit, 
    dollar, 
    file_name
FROM 
    SDL_COMPETITIVE_BANNER_GROUP
WHERE 
    TRY_TO_NUMBER(unit) < 0 OR 
    TRY_TO_NUMBER(dollar) < 0;
========================================================================================================================================

table_name: SDL_LA_GT_ROUTE_DETAIL
solution: Identify and resolve discrepancies in timestamps, dates, and potential duplicate records. Ensure data consistency by checking for missing or invalid entries, and cross-verify related fields for coherence.
snowflake_query: 
SELECT 
    route_id, 
    customer_id, 
    COUNT(*) AS record_count
FROM 
    SDL_LA_GT_ROUTE_DETAIL
WHERE 
    created_date IS NULL 
    OR file_upload_date IS NULL 
    OR crt_dttm IS NULL 
    OR created_date > file_upload_date 
    OR crt_dttm::DATE <> created_date
GROUP BY 
    route_id, 
    customer_id
HAVING 
    record_count > 1 
    OR COUNT(DISTINCT filename) < record_count;
========================================================================================================================================

sql
table_name: SDL_MDS_APAC_DCL_PRODUCTS
solution: Identify and resolve duplicate IDs, negative SAP codes, and validate missing MUIDs.
snowflake query: 
SELECT 
    id, 
    COUNT(*) OVER (PARTITION BY id) AS duplicate_id_count, 
    sap_code, 
    muid, 
    CASE WHEN sap_code < 0 THEN 'Negative SAP Code' ELSE 'Valid SAP Code' END AS sap_code_status,
    CASE WHEN muid IS NULL THEN 'Missing MUID' ELSE 'MUID Present' END AS muid_status
FROM 
    SDL_MDS_APAC_DCL_PRODUCTS
WHERE 
    duplicate_id_count > 1 OR 
    sap_code < 0 OR 
    muid IS NULL;


This query checks for duplicate IDs, negative SAP codes, and any missing MUID values, which are the identified anomalies.
========================================================================================================================================

sql
table_name: SDL_MDS_PH_ISE_PARENT
solution: Identify rows with missing or null values in crucial columns like 'code', 'name', and 'id'. Ensure data completeness and consistency by reviewing and populating these fields.
snowflake query: 
SELECT *
FROM SDL_MDS_PH_ISE_PARENT
WHERE code IS NULL OR name IS NULL OR id IS NULL
   OR code = '' OR name = '' OR id = '';


sql
table_name: SDL_MDS_PH_ISE_PARENT
solution: Detect rows where timestamps 'enterdatetime' or 'lastchgdatetime' are in the future, which could indicate incorrect data entry or timezone issues.
snowflake query: 
SELECT *
FROM SDL_MDS_PH_ISE_PARENT
WHERE enterdatetime > CURRENT_TIMESTAMP() OR lastchgdatetime > CURRENT_TIMESTAMP();


sql
table_name: SDL_MDS_PH_ISE_PARENT
solution: Find rows with duplicate 'code' values to ensure data uniqueness and integrity.
snowflake query: 
SELECT code, COUNT(*)
FROM SDL_MDS_PH_ISE_PARENT
GROUP BY code
HAVING COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_MDS_VN_ECOM_PRODUCT
solution: 
  - Anomalies detected in 'versionnumber' and 'version_id' suggest inconsistencies. Ensure 'versionnumber' is positive and 'version_id' should not have unreasonable negative values.
  - 'changetrackingmask' should be non-negative.
  - Ensure 'validationstatus' aligns with business rules (e.g., 'Validated' should be consistent with 'versionflag' being 'Active').
snowflake query: 
  SELECT 
    id, 
    versionnumber, 
    version_id, 
    changetrackingmask, 
    validationstatus, 
    versionflag 
  FROM 
    SDL_MDS_VN_ECOM_PRODUCT
  WHERE 
    versionnumber <= 0 
    OR version_id < -5000 
    OR changetrackingmask < 0 
    OR (validationstatus = 'Validated' AND versionflag != 'Active');
========================================================================================================================================

table_name: SDL_MDS_VN_DISTRIBUTOR_CUSTOMERS
solution: Detect and address anomalies such as negative IDs, inconsistent version numbers, mismatched data fields, and null values in critical columns.
snowflake query: 
SELECT * 
FROM SDL_MDS_VN_DISTRIBUTOR_CUSTOMERS
WHERE id < 0 
   OR versionnumber != version_id
   OR account_id < 0
   OR (muid IS NOT NULL AND (versionname IS NULL OR changetrackingmask IS NULL))
   OR (region_id IS NULL AND region_name IS NOT NULL)
   OR (province_id IS NULL AND province_name IS NOT NULL)
   OR (sub_channel_id IS NULL AND sub_channel_name IS NOT NULL)
   OR (account_code IS NOT NULL AND account_name IS NULL)
   OR (enterusername IS NOT NULL AND lastchgusername IS NULL)
   OR (enterdatetime IS NOT NULL AND lastchgdatetime IS NULL)
   OR (enterversionnumber IS NULL AND lastchgversionnumber IS NOT NULL)
   OR (validationstatus IS NOT NULL AND versionflag IS NULL);
========================================================================================================================================

table_name : SDL_HK_IMS_WINGKEUNG_INV
solution : Check for negative values in 'CLOSING' and 'AMOUNT' columns. Negative values in 'CLOSING' might indicate returns or errors, while negative 'AMOUNT' values need verification.
snowflake query : SELECT * FROM SDL_HK_IMS_WINGKEUNG_INV WHERE CLOSING < 0 OR AMOUNT < 0;
========================================================================================================================================

table_name: SDL_MDS_VN_GT_GTS_RATIO
solution: Detect anomalies in percentage values and validation status. Check for percentages exceeding 100 and ensure validation status is consistent with percentage logic.
snowflake_query: 
SELECT 
    id,
    muid,
    versionname,
    versionnumber,
    version_id,
    versionflag,
    name,
    code,
    changetrackingmask,
    distributor,
    "from month",
    "to month",
    percentage,
    enterdatetime,
    enterusername,
    enterversionnumber,
    lastchgdatetime,
    lastchgusername,
    lastchgversionnumber,
    validationstatus
FROM 
    SDL_MDS_VN_GT_GTS_RATIO
WHERE 
    percentage > 100 OR
    (percentage <= 100 AND validationstatus = 'Invalid');
========================================================================================================================================

table_name: SDL_IRI_SCAN_SALES
solution: 
- Ensure `scan_sales`, `numeric_distribution`, `weighted_distribution`, and `store_count_where_scanned` have valid positive values. 
- Handle negative values in `scan_sales` and other numeric fields, which may indicate data entry errors.
- Verify `store_count_where_scanned` and `weighted_distribution` for realistic positive values.
- Validate `numeric_distribution` and `weighted_distribution` are within expected bounds.
- Ensure data integrity and consistency across related fields.

snowflake query: 
SELECT 
    iri_market, 
    wk_end_dt, 
    iri_prod_desc, 
    scan_sales, 
    scan_units, 
    numeric_distribution, 
    weighted_distribution, 
    store_count_where_scanned 
FROM 
    SDL_IRI_SCAN_SALES 
WHERE 
    scan_sales < 0 
    OR numeric_distribution <= 0 
    OR weighted_distribution <= 0 
    OR store_count_where_scanned <= 0;
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_RANKING_DAILY
solution: Handle non-numeric values in the 'RANKING' column and ensure all rankings are numeric.
snowflake query: 
SELECT *
FROM SDL_KR_COUPANG_PRODUCT_RANKING_DAILY
WHERE TRY_TO_NUMBER(RANKING) IS NULL;



table_name: SDL_KR_COUPANG_PRODUCT_RANKING_DAILY
solution: Ensure 'DATA_GRANULARITY' values are consistent and valid, e.g., 'Daily', 'Weekly', etc.
snowflake query: 
SELECT DISTINCT DATA_GRANULARITY
FROM SDL_KR_COUPANG_PRODUCT_RANKING_DAILY
WHERE DATA_GRANULARITY NOT IN ('Daily', 'Weekly');
========================================================================================================================================

table_name: SDL_MDS_LOG
solution: Identify anomalies in job executions by checking for failed statuses and analyzing typical error messages to understand common issues.
snowflake query: 
SELECT 
    JOB_NAME, 
    STATUS, 
    RESULT, 
    QUERY, 
    CRTD_DTTM
FROM 
    SDL_MDS_LOG
WHERE 
    STATUS = 'Failed' 
    OR RESULT IN ('Missing values in mandatory fields', 'Invalid logic in date', 'Logical error found', 'Missing required information', 'Start date is after end date');
========================================================================================================================================

table_name: SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT
solution: Validate data types and ensure non-null constraints. Check for outliers or unexpected values in SLS_TRGT_VAL. Verify data relationships and use integrity checks.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    COUNT(DISTINCT JJ_MNTH_ID) AS distinct_months,
    COUNT(DISTINCT SLS_REP_CD) AS distinct_sales_rep_codes,
    COUNT(DISTINCT SLS_REP_NM) AS distinct_sales_rep_names,
    COUNT(DISTINCT BRAND) AS distinct_brands,
    COUNT(DISTINCT SLS_TRGT_VAL) AS distinct_target_values,
    SUM(CASE WHEN SLS_TRGT_VAL IS NULL THEN 1 ELSE 0 END) AS null_target_values,
    SUM(CASE WHEN SLS_REP_CD IS NULL THEN 1 ELSE 0 END) AS null_sales_rep_codes,
    SUM(CASE WHEN SLS_REP_NM IS NULL THEN 1 ELSE 0 END) AS null_sales_rep_names,
    SUM(CASE WHEN BRAND IS NULL THEN 1 ELSE 0 END) AS null_brands,
    SUM(CASE WHEN JJ_MNTH_ID IS NULL THEN 1 ELSE 0 END) AS null_month_ids,
    SUM(CASE WHEN SLS_TRGT_VAL < 0 THEN 1 ELSE 0 END) AS negative_target_values
FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT;
========================================================================================================================================

markdown
table_name: SDL_ID_POS_CARREFOUR_SELLOUT
solution: Detect anomalies in the 'SDL_ID_POS_CARREFOUR_SELLOUT' table by checking for null values, duplicates, and outliers. Recommend implementing data validation checks to ensure data integrity.
snowflake_query: 
sql
WITH anomalies AS (
    SELECT
        RUN_ID,
        POS_CUST,
        YEARMONTH,
        CRTD_DTTM,
        FILENAME,
        FDESC,
        SCC_NAME,
        SCC,
        SALES_QTY,
        NET_SALES,
        SHARE,
        CASE 
            WHEN CRTD_DTTM IS NULL THEN 'NULL_CRTD_DTTM'
            WHEN POS_CUST IS NULL THEN 'NULL_POS_CUST'
            WHEN YEARMONTH IS NULL THEN 'NULL_YEARMONTH'
            WHEN RUN_ID IS NULL THEN 'NULL_RUN_ID'
            WHEN FILENAME IS NULL THEN 'NULL_FILENAME'
            WHEN FDESC IS NULL THEN 'NULL_FDESC'
            WHEN SCC_NAME IS NULL THEN 'NULL_SCC_NAME'
            WHEN SCC IS NULL THEN 'NULL_SCC'
            WHEN SALES_QTY IS NULL THEN 'NULL_SALES_QTY'
            WHEN NET_SALES IS NULL THEN 'NULL_NET_SALES'
            WHEN SHARE IS NULL THEN 'NULL_SHARE'
            WHEN ROW_NUMBER() OVER (PARTITION BY RUN_ID, POS_CUST, YEARMONTH ORDER BY CRTD_DTTM) > 1 THEN 'DUPLICATE_RECORD'
            ELSE NULL
        END AS anomaly_type
    FROM SDL_ID_POS_CARREFOUR_SELLOUT
)
SELECT * FROM anomalies WHERE anomaly_type IS NOT NULL;
========================================================================================================================================

table_name: SDL_MDS_PH_NPI_PEG_ITEM
solution: Detect duplicate records and inconsistent timestamps.
snowflake query: 
SELECT * 
FROM SDL_MDS_PH_NPI_PEG_ITEM
WHERE (
    (versionnumber, version_id, versionflag, name, code, changetrackingmask, peg_itemcode_code, peg_itemcode_name, peg_itemcode_id, salescycle, enterversionnumber, lastchgversionnumber) IN
    (SELECT versionnumber, version_id, versionflag, name, code, changetrackingmask, peg_itemcode_code, peg_itemcode_name, peg_itemcode_id, salescycle, enterversionnumber, lastchgversionnumber
     FROM SDL_MDS_PH_NPI_PEG_ITEM
     GROUP BY versionnumber, version_id, versionflag, name, code, changetrackingmask, peg_itemcode_code, peg_itemcode_name, peg_itemcode_id, salescycle, enterversionnumber, lastchgversionnumber
     HAVING COUNT(*) > 1)
) OR (
    lastchgdatetime < enterdatetime
);
========================================================================================================================================

table_name: SDL_MDS_MY_GT_OUTLETATTRIBUTES
solution: 
1. Correct negative and future `cust_year` values.
2. Ensure `id` is positive.
3. Validate `customer_code` for non-null values where applicable.
4. Review `versionflag` consistency with `versionnumber`.
5. Check `validationstatus` for valid statuses.

snowflake query: 
SELECT * 
FROM SDL_MDS_MY_GT_OUTLETATTRIBUTES
WHERE 
    CAST(cust_year AS INTEGER) < 0 
    OR CAST(cust_year AS INTEGER) > YEAR(CURRENT_DATE) 
    OR id < 0 
    OR (customer_code IS NULL AND versionflag != 'Draft') 
    OR versionflag NOT IN ('Final', 'Draft') 
    OR validationstatus NOT IN ('Approved', 'Rejected', 'Pending');
========================================================================================================================================

table_name: SDL_MDS_VN_PS_STORE_TAGGING
solution: 
1. Anomaly in `versionnumber`: Value '99999' seems unusually high.
2. Anomaly in `changetrackingmask`: Negative value '-1' is suspicious.
3. Inconsistencies in `status`: 'Unknown' status should be verified.
4. `validationstatus` has 'Unknown' which needs clarification.
snowflake query:
SELECT *
FROM SDL_MDS_VN_PS_STORE_TAGGING
WHERE versionnumber = 99999
   OR changetrackingmask < 0
   OR status = 'Unknown'
   OR validationstatus = 'Unknown';


This solution and query will help identify anomalies in the provided sample data from the table `SDL_MDS_VN_PS_STORE_TAGGING`. The query is Snowflake-friendly and addresses potential data anomalies by filtering based on specific conditions.
========================================================================================================================================

table_name: SDL_CSL_DISTRIBUTORACTIVATION
solution: Check for missing or null values in important columns, validate date consistency, and ensure unique identifiers.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_CSL_DISTRIBUTORACTIVATION
WHERE 
    ACTIVATEDBY IS NULL 
    OR CREATEDDATE IS NULL 
    OR DISTCODE IS NULL 
    OR CRT_DTTM IS NULL 
    OR RUN_ID IS NULL 
    OR ACTIVESTATUS IS NULL 
    OR ACTIVEFROMDATE IS NULL 
    OR (INACTIVEFROMDATE IS NOT NULL AND INACTIVATEDBY IS NULL) 
    OR (ACTIVATEDON IS NOT NULL AND ACTIVATEDON < CREATEDDATE)
    OR (INACTIVATEDON IS NOT NULL AND INACTIVATEDON < CREATEDDATE)
    OR DISTCODE IN (
        SELECT 
            DISTCODE 
        FROM 
            SDL_CSL_DISTRIBUTORACTIVATION 
        GROUP BY 
            DISTCODE 
        HAVING 
            COUNT(*) > 1
    );
========================================================================================================================================

table_name: SDL_FPA_PROFIT_CENTER_MAPPING
solution: 
- Ensure numerical values are correctly formatted and logically correct (e.g., execution_order should be numerical and positive).
- Verify that dimensions and rule groups have valid and expected values.
- Check for duplicate entries based on a combination of critical columns like dimension, rulegroupname, and rule_type.

snowflake query: 
SELECT 
    dimension, 
    rulegroupname, 
    rule_type, 
    COUNT(*) AS duplicate_count
FROM SDL_FPA_PROFIT_CENTER_MAPPING
GROUP BY dimension, rulegroupname, rule_type
HAVING COUNT(*) > 1;

SELECT * 
FROM SDL_FPA_PROFIT_CENTER_MAPPING
WHERE TRY_TO_NUMBER(execution_order) IS NULL OR TRY_TO_NUMBER(execution_order) < 0;

SELECT * 
FROM SDL_FPA_PROFIT_CENTER_MAPPING
WHERE dimension NOT IN ('Dimension8', 'Dimension13', 'Dimension25', '99999')
   OR rulegroupname NOT IN ('Group8', 'Group11', 'Group13', 'Group25', 'Group39', 'Group41');


This solution identifies anomalies related to incorrect numerical formats, unexpected categorical values, and potential duplicates within the dataset. The provided Snowflake queries are designed to be executed in a Snowflake environment and are structured to efficiently find these anomalies.
========================================================================================================================================

table_name: SDL_JNJ_MER_SHARE_OF_SHELF
solution: 
1. Check for invalid 'run_id' values like -999999 and address them.
2. Validate 'yearmo' format and ensure it represents a valid date.
3. Identify and handle missing 'file_name' and 'merchandiser_name' entries.
snowflake query: 
SELECT 
    run_id, 
    yearmo, 
    file_name, 
    merchandiser_name 
FROM 
    SDL_JNJ_MER_SHARE_OF_SHELF 
WHERE 
    run_id = -999999 
    OR NOT REGEXP_LIKE(yearmo, '^[0-9]{6}$') 
    OR file_name IS NULL 
    OR merchandiser_name IS NULL;
========================================================================================================================================

table_name: SDL_ECOM_CPAS
solution: Identify negative spending values as anomalies and verify data integrity.
snowflake query: 
SELECT * 
FROM SDL_ECOM_CPAS 
WHERE SPENDING < 0;
========================================================================================================================================

sql
table_name: SDL_LA_GT_ROUTE_HEADER_TEMP

solution: 
1. Null check for the 'is_active' column.
2. Negative values check for 'routesale' and 'saleunit' columns.
3. Duplicate check for 'filename' column.
4. Check for null values in 'filename' column.

snowflake query: 
SELECT 
  hashkey, 
  route_id, 
  route_name, 
  route_desc, 
  is_active, 
  routesale, 
  saleunit, 
  route_code, 
  description, 
  last_updated_date, 
  file_upload_date, 
  filename, 
  run_id, 
  crt_dttm
FROM 
  SDL_LA_GT_ROUTE_HEADER_TEMP
WHERE 
  is_active IS NULL 
  OR CAST(routesale AS FLOAT) < 0 
  OR CAST(saleunit AS FLOAT) < 0 
  OR filename IS NULL
  OR filename IN (
    SELECT filename 
    FROM SDL_LA_GT_ROUTE_HEADER_TEMP 
    GROUP BY filename 
    HAVING COUNT(*) > 1
  );
========================================================================================================================================

table_name: SDL_MY_DSTRBTRR_DIM
solution: The table's sample data is missing for all columns, indicating potential data population issues. Ensure data is properly loaded into the table. Check ETL processes and data source connections.
snowflake query: 


sql
-- Check for missing data
SELECT * 
FROM SDL_MY_DSTRBTRR_DIM 
WHERE CUST_ID IS NULL 
   OR CUST_NM IS NULL 
   OR LVL1 IS NULL 
   OR LVL2 IS NULL 
   OR LVL3 IS NULL 
   OR LVL4 IS NULL 
   OR LVL5 IS NULL 
   OR TRDNG_TERM_VAL IS NULL 
   OR ABBREVATION IS NULL 
   OR BUYER_GLN IS NULL 
   OR LOCATION_GLN IS NULL 
   OR CHNL_MANAGER IS NULL 
   OR CDM IS NULL 
   OR REGION IS NULL 
   OR CDL_DTTM IS NULL 
   OR CURR_DT IS NULL 
   OR FILE_NAME IS NULL;
========================================================================================================================================

Certainly! Here's a solution for detecting potential anomalies in the `SDL_CSL_SCHEMEUTILIZATION` table based on the metadata and the structure provided:


table_name: SDL_CSL_SCHEMEUTILIZATION
solution: Identify records with missing or null values in essential columns, check for negative values in quantity and amount columns, and validate timestamp fields for logical consistency.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_CSL_SCHEMEUTILIZATION
WHERE 
    DISTCODE IS NULL 
    OR SCHEMECODE IS NULL 
    OR SCHEMEDESCRIPTION IS NULL 
    OR INVOICENO IS NULL 
    OR RTRCODE IS NULL 
    OR COMPANY IS NULL 
    OR SCHDATE IS NULL 
    OR SCHEMETYPE IS NULL 
    OR SCHEMEUTILIZEDAMT < 0 
    OR SCHEMEUTILIZEDQTY < 0 
    OR BILLEDQTY < 0 
    OR BILLEDRATE < 0 
    OR CREATEDDATE > MODIFIEDDATE 
    OR CRT_DTTM IS NULL 
    OR FILE_NAME IS NULL;


This query checks for missing values, negative numbers in fields that should logically be non-negative, and ensures that the `CREATEDDATE` is not after the `MODIFIEDDATE`. Adjust the conditions based on specific business rules if necessary.
========================================================================================================================================

sql
table_name: SDL_POP6_SG_GENERAL_AUDITS
solution: Check for NULL values and inconsistent data types in the text columns, and ensure unique constraints where applicable. Implement proper data validation and data governance processes.
snowflake_query: 
SELECT 
    'VISIT_ID' AS column_name, COUNT(*) AS null_count
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    VISIT_ID IS NULL
UNION ALL
SELECT 
    'SUBSECTION_ID', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    SUBSECTION_ID IS NULL
UNION ALL
SELECT 
    'RESPONSE', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    RESPONSE IS NULL
UNION ALL
SELECT 
    'FIELD_TYPE', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    FIELD_TYPE IS NULL
UNION ALL
SELECT 
    'DEPENDENT_ON_FIELD_ID', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    DEPENDENT_ON_FIELD_ID IS NULL
UNION ALL
SELECT 
    'FIELD_LABEL', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    FIELD_LABEL IS NULL
UNION ALL
SELECT 
    'SECTION_ID', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    SECTION_ID IS NULL
UNION ALL
SELECT 
    'SUBSECTION', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    SUBSECTION IS NULL
UNION ALL
SELECT 
    'FIELD_CODE', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    FIELD_CODE IS NULL
UNION ALL
SELECT 
    'FIELD_ID', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    FIELD_ID IS NULL
UNION ALL
SELECT 
    'AUDIT_FORM', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    AUDIT_FORM IS NULL
UNION ALL
SELECT 
    'FILE_NAME', COUNT(*)
FROM 
    SDL_POP6_SG_GENERAL_AUDITS
WHERE 
    FILE_NAME IS NULL;
========================================================================================================================================

table_name : SDL_MDS_PACIFIC_PERENSO_CYCLE_DATES
solution : Detect negative or invalid values in version identifiers and ensure consistency between related fields. Correct or investigate anomalies as needed.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_MDS_PACIFIC_PERENSO_CYCLE_DATES
WHERE 
    versionnumber < 0 
    OR version_id < 0 
    OR start_date > end_date 
    OR validationstatus NOT IN ('Validated', 'Pending', 'Invalid')
    OR (name IS NOT NULL AND code IS NULL)
    OR (name IS NULL AND code IS NOT NULL)
    OR versionnumber != enterversionnumber 
    OR versionnumber != lastchgversionnumber;
========================================================================================================================================

table_name: SDL_CUSTOMERPL_STDCOST_2022
solution: Identify and handle negative and zero standard costs or quantities, and ensure data integrity for valid market entries.
snowflake query: 
SELECT *
FROM SDL_CUSTOMERPL_STDCOST_2022
WHERE STDCOST <= 0 OR QTY <= 0 OR MARKET NOT IN ('EU', 'AS', 'US');
========================================================================================================================================

table_name : SDL_ID_MDS_LOG
solution : Identify and address NULL values, syntax errors, and delayed operations.
snowflake query : 
SELECT * 
FROM SDL_ID_MDS_LOG 
WHERE STATUS IS NULL 
   OR RESULT IS NULL 
   OR RESULT LIKE '%Syntax error%' 
   OR QUERY LIKE '%WAITFOR DELAY%' 
   OR CRTD_DTTM < '2023-01-01' 
   OR JOB_NAME IS NULL;
========================================================================================================================================

table_name : SDL_ID_POS_DAILY_SAT_SELLOUT
solution : Identify anomalies such as negative values, out-of-range dates, and unexpected data types; Implement checks for these anomalies.
snowflake query : 
SELECT *
FROM SDL_ID_POS_DAILY_SAT_SELLOUT
WHERE 
    VALUE < 0 
    OR TRY_TO_TIMESTAMP(TGL) IS NULL
    OR NOT REGEXP_LIKE(YEARMONTH, '^\d{6}$') 
    OR TRY_TO_NUMBER(VALUE) IS NULL
    OR TRY_TO_NUMBER(RUN_ID) IS NULL;
========================================================================================================================================

table_name: SDL_LA_GT_SCHEDULE
solution: Identify and handle missing or inconsistent data in the 'schedule_date', 'approved', 'saleunit', and 'filename' columns. Ensure that 'schedule_date' is in a valid date format, 'approved' has consistent values like 'YES' or 'NO', 'saleunit' follows a standard naming convention, and 'filename' has a valid file extension. Consider using data validation rules and constraints to maintain consistency.
snowflake query: 
SELECT 
    employee_id, 
    route_id, 
    schedule_date, 
    approved, 
    saleunit, 
    filename, 
    run_id, 
    crt_dttm
FROM 
    SDL_LA_GT_SCHEDULE
WHERE 
    schedule_date IS NULL 
    OR TRY_TO_DATE(schedule_date, 'YYYY-MM-DD') IS NULL
    OR approved NOT IN ('YES', 'NO')
    OR saleunit NOT LIKE 'UNIT%'
    OR filename NOT LIKE '%.%' 
    OR LENGTH(run_id) != 14;
========================================================================================================================================

table_name: SDL_GCGH_GEO_HIER
solution: Ensure 'cdl_datetime' is within a logical range and check for consistent 'country_code_iso2' and 'country_code_iso3' with the 'market'.
snowflake query: 
SELECT 
    *
FROM 
    SDL_GCGH_GEO_HIER
WHERE 
    TRY_TO_TIMESTAMP(CDL_DATETIME, 'YYYY-MM-DD HH24:MI:SS') IS NULL
    OR LENGTH(COUNTRY_CODE_ISO2) != 2
    OR LENGTH(COUNTRY_CODE_ISO3) != 3
    OR NOT EXISTS (
        SELECT 1
        FROM SDL_GCGH_GEO_HIER AS subquery
        WHERE subquery.COUNTRY_CODE_ISO2 = SDL_GCGH_GEO_HIER.COUNTRY_CODE_ISO2
          AND subquery.COUNTRY_CODE_ISO3 = SDL_GCGH_GEO_HIER.COUNTRY_CODE_ISO3
          AND subquery.MARKET = SDL_GCGH_GEO_HIER.MARKET
    );
========================================================================================================================================

table_name: SDL_LA_GT_INVENTORY_FACT
solution: The anomalies detected include negative quantities and amounts, which might indicate incorrect data entries or returns. Additionally, quantities of zero may need to be investigated to ensure they are valid. Recommend ensuring data validation rules are in place to prevent negative and zero quantities where not applicable.
snowflake query: 
SELECT *
FROM SDL_LA_GT_INVENTORY_FACT
WHERE TRY_TO_NUMBER(QTY) < 0 
   OR TRY_TO_NUMBER(QTY) = 0 
   OR TRY_TO_NUMBER(AMOUNT) < 0;


This query checks for negative and zero values in the `QTY` and negative values in the `AMOUNT` columns, which are common indicators of data anomalies.
========================================================================================================================================

table_name: SDL_CSL_SALESINVOICEORDERS
solution: 
1. Ensure all 'RUN_ID' values are positive.
2. Address 'UPLOADFLAG' null values, potentially setting default to 'N'.
snowflake query: 
SELECT * 
FROM SDL_CSL_SALESINVOICEORDERS 
WHERE RUN_ID < 0 
   OR UPLOADFLAG IS NULL;
========================================================================================================================================

table_name: SDL_ALL_DISTRIBUTOR_SELLIN_SALES_FACT
solution: Detect negative or zero values for 'numerator' and 'qty', and mismatched 'net_val' with respect to 'qty' and 'numerator'. Implement data validation checks to ensure data integrity before loading.
snowflake_query: 
SELECT * 
FROM SDL_ALL_DISTRIBUTOR_SELLIN_SALES_FACT 
WHERE numerator <= 0 
   OR qty <= 0 
   OR net_val <> (numerator * qty);
========================================================================================================================================

table_name: SDL_HK_POS_SCORECARD_MANNINGS
solution: The anomalies identified include negative sales values and zero sales quantities for certain records. To address this, ensure data integrity checks are implemented during data entry or data ingestion processes. This can include constraints or validation rules to prevent negative sales value entries and to handle zero sales quantities appropriately. Data cleaning processes should also be employed to correct or remove invalid data.

snowflake query: 
SELECT *
FROM SDL_HK_POS_SCORECARD_MANNINGS
WHERE salesvalue < 0 OR salesqty = 0;
========================================================================================================================================

sql
table_name: SDL_POP6_SG_PRODUCT_LISTS_ALLOCATION
solution: Identify and handle negative values in 'product_group_status' and check for discrepancies between 'product_group' and 'product_list_status'.
snowflake query: 
SELECT *
FROM SDL_POP6_SG_PRODUCT_LISTS_ALLOCATION
WHERE product_group_status < 0
   OR (product_group = 'Stationery' AND product_list_status NOT IN (26, 28));
========================================================================================================================================

table_name : SDL_KR_COUPANG_CUSTOMER_BRAND_TREND  
solution : Detect anomalies in the data by identifying negative values in the 'tot_user_avg_product_sales_price' column and inconsistent user counts. Consider data validation rules during data ingestion to prevent such anomalies.  
snowflake query :   
SELECT *  
FROM SDL_KR_COUPANG_CUSTOMER_BRAND_TREND  
WHERE tot_user_avg_product_sales_price < 0  
OR CAST(new_user_count AS NUMBER) + CAST(curr_user_count AS NUMBER) != CAST(tot_user_count AS NUMBER);
========================================================================================================================================

table_name: SDL_MDS_PH_ISE_SOS_TARGETS
solution: 
1. Check for negative 'id' and 'target' values and decide on correction strategy based on business rules.
2. Ensure all 'enterusername' and 'lastchgusername' fields are populated.
3. Validate 'cal_year' for reasonable future dates.

snowflake query: 
SELECT 
    id, 
    muid, 
    versionname, 
    versionnumber, 
    version_id, 
    versionflag, 
    name, 
    code, 
    changetrackingmask, 
    brand_id, 
    target, 
    cal_year, 
    enterdatetime, 
    enterusername, 
    enterversionnumber, 
    lastchgdatetime, 
    lastchgusername, 
    lastchgversionnumber, 
    validationstatus 
FROM SDL_MDS_PH_ISE_SOS_TARGETS
WHERE id < 0 
   OR target < 0 
   OR enterusername IS NULL 
   OR lastchgusername IS NULL 
   OR TRY_TO_NUMBER(cal_year) > YEAR(CURRENT_DATE) + 20;
========================================================================================================================================

table_name : SDL_ID_POS_GUARDIAN_STOCK
solution : Detect negative values in 'soh_stores' and 'soh_dc', check for NULLs in 'article_desc' and 'pos_cust', and ensure 'yearmonth' contains valid date formats. 
snowflake query : 
SELECT * 
FROM SDL_ID_POS_GUARDIAN_STOCK 
WHERE soh_stores < 0 
   OR soh_dc < 0 
   OR article_desc IS NULL 
   OR pos_cust IS NULL 
   OR NOT TRY_CAST(yearmonth AS DATE) IS NOT NULL;
========================================================================================================================================

sql
table_name: SDL_CCR_PRODUCT_MAPPING
solution: Identify anomalies such as negative execution order and ensure all columns adhere to expected data types and constraints.
snowflake query: 
SELECT 
    *
FROM 
    SDL_CCR_PRODUCT_MAPPING
WHERE 
    TRY_CAST(EXECUTION_ORDER AS INTEGER) IS NULL
    OR TRY_CAST(EXECUTION_ORDER AS INTEGER) < 0
    OR RULEGROUPNAME IS NULL
    OR RULE_TYPE IS NULL
    OR RULENAME_SOURCEVALUE IS NULL
    OR RULE_DESCRIPTION IS NULL
    OR RULE_EXPRESSION IS NULL
    OR TARGET_VALUE IS NULL
    OR LOGICAL_OPERATOR IS NULL
    OR DIMENSION IS NULL;
========================================================================================================================================

table_name: SDL_MY_AS_WATSONS_INVENTORY
solution: Identify and report anomalies in data types, negative inventory values, and future dates.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MY_AS_WATSONS_INVENTORY
WHERE 
    TRY_TO_NUMBER(INV_QTY_PC) IS NULL 
    OR TRY_TO_NUMBER(INV_VALUE) IS NULL 
    OR TRY_TO_NUMBER(YEAR) IS NULL 
    OR TRY_TO_NUMBER(MNTH_ID) IS NULL 
    OR TRY_TO_NUMBER(INV_VALUE) < 0 
    OR TRY_TO_NUMBER(YEAR) > EXTRACT(YEAR FROM CURRENT_DATE()) 
    OR TRY_TO_TIMESTAMP(CRTD_DTTM) IS NULL;
========================================================================================================================================

