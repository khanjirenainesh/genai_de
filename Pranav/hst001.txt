table_name: DAILYSALES
solution: The sample data provided for the DAILYSALES table is entirely empty, which suggests a potential issue with data extraction or loading. Ensure data is correctly extracted from the source and loaded into Snowflake. Check for any ETL pipeline issues and verify source connectivity and data mapping.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    COUNT(DISTINCT salesmancode) AS distinct_salesmancode,
    COUNT(DISTINCT salinvno) AS distinct_salinvno,
    COUNT(DISTINCT prdcode) AS distinct_prdcode,
    COUNT(DISTINCT rtrcode) AS distinct_rtrcode,
    COUNT(DISTINCT deliveryroutecode) AS distinct_deliveryroutecode
FROM 
    DAILYSALES;
========================================================================================================================================

sql
table_name: SDL_CSL_DAILYSALES
solution: Identify and fix missing or inconsistent data entries, such as null or anomalous values, using appropriate data cleaning techniques. Ensure proper constraints and data validation rules are applied to prevent future anomalies.
snowflake query: 
SELECT * 
FROM SDL_CSL_DAILYSALES 
WHERE distcode IS NULL OR 
      salinvno IS NULL OR 
      salinvdate IS NULL OR 
      saldlvdate IS NULL OR 
      salinvmode NOT IN ('Online', 'Offline') OR 
      salinvtype NOT IN ('Retail', 'Wholesale') OR 
      salgrossamt < 0 OR 
      salnetamt < 0 OR 
      rtrcode IS NULL OR 
      prdqty < 0 OR 
      prdgrossamt < 0 OR 
      prdnetamt < 0;
========================================================================================================================================

table_name: SDL_CSL_DAILYSALES_UNDELIVERED
solution: Ensure data consistency by checking for null or invalid values in critical columns, such as sales amounts and dates. Implement cleaning procedures to address missing or incorrect data.
snowflake_query: 
SELECT 
    * 
FROM 
    SDL_CSL_DAILYSALES_UNDELIVERED 
WHERE 
    salgrossamt IS NULL OR 
    salnetamt IS NULL OR 
    salinvdate IS NULL OR 
    saldlvdate IS NULL OR 
    salgrossamt < 0 OR 
    salnetamt < 0 OR 
    prdqty < 0;
========================================================================================================================================

table_name: SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
solution: Check for anomalies in target year consistency, target value distribution, status alignment, and missing weeks.
snowflake query: 
SELECT 
    distcode, 
    targetrefno, 
    targetdate, 
    smcode, 
    smname, 
    rmcode, 
    rmname, 
    targetyear, 
    targetmonth, 
    targetvalue, 
    targetname, 
    week1, 
    week2, 
    week3, 
    week4, 
    week5, 
    targetstatus, 
    targettype, 
    downloadstatus, 
    createddate, 
    run_id, 
    crt_dttm, 
    file_name
FROM SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
WHERE 
    targetyear < EXTRACT(YEAR FROM CURRENT_DATE())  -- Future year anomaly
    OR targetvalue < 0  -- Negative target value anomaly
    OR (targetstatus = 'Closed' AND targetvalue != week1 + week2 + week3 + week4 + week5) -- Status mismatch
    OR (targettype = 'Monthly' AND (week1 = 0 OR week2 = 0 OR week3 = 0 OR week4 = 0)) -- Missing weekly distribution
    OR (targettype = 'Annual' AND week5 = 0);  -- Incomplete annual distribution
========================================================================================================================================

table_name: SDL_JNJ_CONSUMERREACH_CVS
solution: Identify anomalies such as missing values in important columns (e.g., 'retail', 'retailprovince', 'jjcore', 'distribution', 'status', 'file_name'). Provide defaults or investigate missing data sources.
snowflake query: 
SELECT * 
FROM SDL_JNJ_CONSUMERREACH_CVS
WHERE retail IS NULL 
   OR retailprovince IS NULL 
   OR jjcore IS NULL 
   OR distribution IS NULL 
   OR status IS NULL 
   OR file_name IS NULL;
========================================================================================================================================

table_name: SDL_MDS_MY_PRODUCT_MASTER
solution: 
1. Detect and handle duplicate entries by identifying distinct records.
2. Address missing or null values by identifying columns with a high percentage of such values and decide on appropriate imputation or exclusion.
3. Validate data types and ranges to ensure they fit the expected format and range.

snowflake query: 
-- Detect duplicates
SELECT ID, COUNT(*) 
FROM SDL_MDS_MY_PRODUCT_MASTER 
GROUP BY ID 
HAVING COUNT(*) > 1;

-- Identify null or missing values
SELECT 
    SUM(CASE WHEN column_name IS NULL THEN 1 ELSE 0 END) AS null_count,
    COUNT(*) AS total_count
FROM SDL_MDS_MY_PRODUCT_MASTER;

-- Validate data types and ranges
SELECT *
FROM SDL_MDS_MY_PRODUCT_MASTER
WHERE 
    (CAST(CARTON_PRICE AS STRING) IS NULL OR CARTON_PRICE < 0) OR
    (CAST(QTY_SHRINK_WRAP AS STRING) IS NULL OR QTY_SHRINK_WRAP < 0);
========================================================================================================================================

sql
table_name: SDL_MDS_PACIFIC_ACCT_NIELSENCODE_MAPPING
solution: Identify records with missing or inconsistent data, such as NULL values in critical fields like 'versionname' and 'validationstatus'. Also, check for potential data integrity issues.
snowflake query: 
SELECT *
FROM SDL_MDS_PACIFIC_ACCT_NIELSENCODE_MAPPING
WHERE versionname IS NULL 
   OR validationstatus IS NULL 
   OR ac_code IS NULL 
   OR ac_nielsencode IS NULL 
   OR ac_longname IS NULL 
   OR enterusername IS NULL 
   OR lastchgusername IS NULL 
   OR validationstatus NOT IN ('Pending', 'Validated', 'Invalid');


In this solution, we are checking for NULL values in fields that are expected to have meaningful data and ensuring that the 'validationstatus' column contains only expected values ('Pending', 'Validated', 'Invalid'). These checks help maintain data integrity and identify potential anomalies.
========================================================================================================================================

table_name: SDL_MDS_VN_CUSTOMER_SEGMENTATION  
solution: Detect anomalies where changetrackingmask is negative, versionflag is neither 'active' nor 'inactive', and validationstatus is neither 'valid' nor 'invalid'. Ensure consistent data entry for these fields.  
snowflake query:  
SELECT *  
FROM SDL_MDS_VN_CUSTOMER_SEGMENTATION  
WHERE changetrackingmask < 0  
   OR NOT (versionflag IN ('active', 'inactive'))  
   OR NOT (validationstatus IN ('valid', 'invalid'));
========================================================================================================================================

table_name: SDL_ID_POS_CARREFOUR_STOCK
solution: Detect negative values in 'STOCK_QTY', 'STOCK_AMT', and 'STOCK_DAYS' columns, which are likely anomalies as stock quantities, amounts, and days should not be negative. Adjust data collection or input mechanisms to prevent such entries.
snowflake query: 
SELECT * 
FROM SDL_ID_POS_CARREFOUR_STOCK 
WHERE STOCK_QTY < 0 OR STOCK_AMT < 0 OR STOCK_DAYS < 0;
========================================================================================================================================

table_name: SDL_MDS_PH_MSL_DTLS
solution: Identify records with negative changetrackingmask values or mismatched version numbers, and ensure data integrity by reviewing data entry processes and implementing validation rules to prevent such anomalies.
snowflake query: 
SELECT *
FROM SDL_MDS_PH_MSL_DTLS
WHERE changetrackingmask < 0
   OR versionnumber != enterversionnumber
   OR versionnumber != lastchgversionnumber;
========================================================================================================================================

table_name: SDL_MDS_PH_NON_ISE_WEIGHTS
solution: The table contains negative weights which might be incorrect given the context. Verify if negative weights are valid. If not, update the records with correct positive values or flag them for review.
snowflake query: 
SELECT *
FROM SDL_MDS_PH_NON_ISE_WEIGHTS
WHERE WEIGHT < 0;
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_MASTER
solution: 
1. Ensure 'ranking' contains only valid numerical values.
2. Validate 'yearmo' format to ensure year and month are correct.
snowflake query:
SELECT 
    *
FROM 
    SDL_KR_COUPANG_PRODUCT_MASTER
WHERE 
    TRY_CAST(ranking AS NUMBER) IS NULL 
    OR NOT REGEXP_LIKE(yearmo, '^\d{4}(0[1-9]|1[0-2])$');
========================================================================================================================================

table_name: PRODBU_PRODUCTBUSINESSUNIT
solution: 
- Ensure all datetime fields are consistent and correct.
- Validate that all keys (product, business unit, remote, hierarchy) are unique and correctly mapped.
- Check for logical consistency in fields like 'isorderable', 'isreturnable', and 'islisted'.
- Verify that numerical fields like 'maximumorderquantity' are within expected ranges.
- Ensure no missing or null values are present in critical columns.

snowflake query: 
SELECT 
  *,
  CASE 
    WHEN fetcheddatetime IS NULL OR azuredatetime IS NULL OR cdl_datetime IS NULL THEN 'Datetime fields should not be NULL'
    WHEN productbusinessunitid IS NULL OR remotekey IS NULL OR productid IS NULL OR productremotekey IS NULL OR businessunitid IS NULL OR businessunitremotekey IS NULL THEN 'Key fields should not be NULL'
    WHEN (isorderable NOT IN ('Yes', 'No') OR isreturnable NOT IN ('Yes', 'No') OR islisted NOT IN ('Yes', 'No')) THEN 'Logical inconsistency in isorderable, isreturnable, or islisted fields'
    WHEN maximumorderquantity < 0 THEN 'Maximum order quantity should not be negative'
    ELSE NULL
  END AS anomaly
FROM 
  PRODBU_PRODUCTBUSINESSUNIT
WHERE 
  fetcheddatetime IS NULL OR 
  azuredatetime IS NULL OR 
  cdl_datetime IS NULL OR 
  productbusinessunitid IS NULL OR 
  remotekey IS NULL OR 
  productid IS NULL OR 
  productremotekey IS NULL OR 
  businessunitid IS NULL OR 
  businessunitremotekey IS NULL OR 
  (isorderable NOT IN ('Yes', 'No')) OR 
  (isreturnable NOT IN ('Yes', 'No')) OR 
  (islisted NOT IN ('Yes', 'No')) OR 
  maximumorderquantity < 0;
========================================================================================================================================

table_name: SDL_ECOM_GMV_KONVY
solution: Handle negative and zero values in metrics like sales_amount, total_unit_sold, current_price, pro_price, pro_cost, cost_in_vat, cost, and conversion. Ensure stock values are valid numbers. Address status inconsistencies (e.g., 'for sale' with zero stock). Validate timestamps for accuracy.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_ECOM_GMV_KONVY 
WHERE 
    sales_amount <= 0 
    OR total_unit_sold <= 0 
    OR current_price <= 0 
    OR pro_price <= 0 
    OR pro_cost <= 0 
    OR cost_in_vat <= 0 
    OR cost <= 0 
    OR conversion <= 0 
    OR tstock = 'unknown' 
    OR CAST(tstock AS INTEGER) <= 0 
    OR status = 'for sale' AND (total_unit_sold <= 0 OR tstock = 'unknown' OR CAST(tstock AS INTEGER) <= 0)
    OR NOT TRY_CAST(crtd_dttm AS TIMESTAMP_NTZ) IS NOT NULL;
========================================================================================================================================

table_name: SDL_CSL_UDCMASTER  
solution: Identify and correct negative or unexpected values for columns like `masterid`, `columnsize`, `editable`, `columnmandatory`, `udcstatus`, and `run_id`. Ensure consistency in data types and maintain proper validation rules.  
snowflake query:  
SELECT *  
FROM SDL_CSL_UDCMASTER  
WHERE masterid < 0  
   OR columnsize < 0  
   OR editable NOT IN (0, 1)  
   OR columnmandatory NOT IN (0, 1)  
   OR udcstatus < 0  
   OR run_id < 0;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_INVOICE
solution: To detect anomalies such as missing values, incorrect data types, or outliers in numerical columns, run the following Snowflake query. Review and correct the data entries based on business rules and data quality standards.
snowflake query: 
SELECT 
    distributor_code, 
    user_code, 
    retailer_code, 
    invoice_date, 
    order_id, 
    invoice_no, 
    product_code, 
    uom, 
    uom_count, 
    qty, 
    piece_price, 
    line_value, 
    invoice_amount, 
    lines_per_call, 
    scheme_code, 
    scheme_description, 
    scheme_discount, 
    scheme_percentage, 
    billdiscount, 
    billdisc_percentage, 
    po_number, 
    payment_type, 
    exp_delivery_date, 
    invoice_address, 
    shipping_address, 
    invoice_status, 
    efaktur_no, 
    tax_value, 
    batch_no, 
    cdl_dttm, 
    run_id, 
    file_name
FROM SDL_DISTRIBUTOR_IVY_INVOICE
WHERE 
    distributor_code IS NULL OR 
    user_code IS NULL OR 
    retailer_code IS NULL OR 
    invoice_date IS NULL OR 
    order_id IS NULL OR 
    invoice_no IS NULL OR 
    product_code IS NULL OR 
    qty < 0 OR 
    piece_price < 0 OR 
    line_value < 0 OR 
    invoice_amount < 0 OR 
    scheme_discount < 0 OR 
    scheme_percentage < 0 OR 
    billdiscount < 0 OR 
    billdisc_percentage < 0 OR 
    tax_value < 0;
========================================================================================================================================

table_name: SDL_HK_IMS_VIVA_SEL_OUT
solution: Check for missing or null values, identify outliers in numerical columns, and validate data consistency across related columns.
snowflake query: 
SELECT 
  'Missing or Null Values' AS anomaly_type,
  column_name,
  COUNT(*) AS anomaly_count
FROM 
  SDL_HK_IMS_VIVA_SEL_OUT
UNPIVOT (value FOR column_name IN (
  SALES_OFFICE, CUSTOMER_NAME, BASE_PRODUCT, CUSTOMER_NUMBER, SALES_GROUP, SALES_OFFICE_NAME,
  EMPLOYEE, MVGR2_VARIANT, SALES_GROUP_NAME, MVGR4_MEGA, ACCOUNT_TYPES, LOCAL_CURR_EXCH_RATE,
  SALES_VOLUME, MEGA_BRAND, MVGR1_BASE, CALENDAR_SID, SALES_ORDER_QUANTITY, TRANSACTIONTYPE,
  CRT_DTTM, UPDT_DTTM, FILE_NAME, MVGR5_BRAND, RETURN_REASON, COUNTRY_CODE, BRAND, VARIANT,
  CURRENCY, NET_TRADE_SALES, PRODUCT_NUMBER, PRODUCT_DESCRIPTION, EMPLOYEE_NAME
)) 
WHERE value IS NULL
GROUP BY column_name

UNION ALL

SELECT 
  'Outliers' AS anomaly_type,
  'SALES_VOLUME' AS column_name,
  COUNT(*) AS anomaly_count
FROM 
  SDL_HK_IMS_VIVA_SEL_OUT
WHERE 
  SALES_VOLUME > (SELECT AVG(SALES_VOLUME) + 3 * STDDEV(SALES_VOLUME) FROM SDL_HK_IMS_VIVA_SEL_OUT)
  OR SALES_VOLUME < (SELECT AVG(SALES_VOLUME) - 3 * STDDEV(SALES_VOLUME) FROM SDL_HK_IMS_VIVA_SEL_OUT)

UNION ALL

SELECT 
  'Inconsistent Data' AS anomaly_type,
  'CURRENCY' AS column_name,
  COUNT(*) AS anomaly_count
FROM 
  SDL_HK_IMS_VIVA_SEL_OUT
WHERE 
  CURRENCY NOT IN ('USD', 'EUR', 'HKD') -- Assuming these are the only valid currencies
GROUP BY CURRENCY;
========================================================================================================================================

table_name: SDL_KR_COUPANG_PA_REPORT
solution: Identify negative sales and ad return values, which are anomalies. Ensure data integrity by verifying source data and correcting negative values. Monitor data input processes to prevent recurrence.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_KR_COUPANG_PA_REPORT 
WHERE 
    CAST(total_conversion_sales_1d AS FLOAT) < 0 
    OR CAST(total_ad_return_14d AS FLOAT) < 0;
========================================================================================================================================

Certainly! Based on the provided metadata and sample data, here is a concise solution and a Snowflake query to identify anomalies in the `SDL_LA_GT_SALES_ORDER_FACT` table:

**Table Name**: SDL_LA_GT_SALES_ORDER_FACT

**Solution**:  
Identify anomalies such as missing data, inconsistent data types, and unexpected values (e.g., negative quantities, canceled orders with non-zero totals). Use queries to detect these anomalies and consider implementing data validation checks, constraints, or data cleansing processes to address these issues.

**Snowflake Query**:
sql
SELECT
    orderid,
    orderdate,
    customer_id,
    qty,
    total,
    canceled,
    crt_dttm
FROM
    SDL_LA_GT_SALES_ORDER_FACT
WHERE
    orderid IS NULL OR
    orderdate IS NULL OR
    customer_id IS NULL OR
    TRY_CAST(qty AS NUMBER) IS NULL OR
    TRY_CAST(total AS NUMBER) IS NULL OR
    TRY_CAST(canceled AS BOOLEAN) IS NULL OR
    qty < 0 OR
    (canceled = 'TRUE' AND TRY_CAST(total AS NUMBER) > 0);


This query checks for null values in critical fields, invalid number and boolean conversions, negative quantities, and canceled orders with non-zero totals. Consider using data cleaning techniques or enforcing constraints based on these findings.
========================================================================================================================================

table_name: SDL_MDS_PH_POS_CUSTOMERS
solution: 
- Check for NULL values in critical columns and ensure data completeness.
- Identify duplicate entries based on primary or unique key columns.
- Validate data types and ranges for numerical columns like latitude, longitude, and timestamps.
- Ensure referential integrity for foreign key columns.

snowflake query: 
-- Check for NULL values in critical columns
SELECT * FROM SDL_MDS_PH_POS_CUSTOMERS 
WHERE address1 IS NULL 
   OR city_nm IS NULL 
   OR cust_cd IS NULL 
   OR region_nm IS NULL;

-- Identify duplicate entries based on unique columns like 'id'
SELECT id, COUNT(*) 
FROM SDL_MDS_PH_POS_CUSTOMERS 
GROUP BY id 
HAVING COUNT(*) > 1;

-- Validate numerical data types and ranges
SELECT * FROM SDL_MDS_PH_POS_CUSTOMERS 
WHERE latitude NOT BETWEEN -90 AND 90 
   OR longitude NOT BETWEEN -180 AND 180;

-- Check for invalid timestamp formats
SELECT * FROM SDL_MDS_PH_POS_CUSTOMERS 
WHERE TRY_TO_TIMESTAMP(enterdatetime) IS NULL 
   OR TRY_TO_TIMESTAMP(lastchgdatetime) IS NULL;

-- Ensure referential integrity
SELECT * FROM SDL_MDS_PH_POS_CUSTOMERS 
WHERE prov_cd_id NOT IN (SELECT DISTINCT id FROM PROVINCE_TABLE)
   OR region_cd_id NOT IN (SELECT DISTINCT id FROM REGION_TABLE);
========================================================================================================================================

table_name: SDL_MDS_VN_DISTRIBUTOR_PRODUCTS
solution: Check for null or inconsistent data entries in critical columns. Validate data consistency across related fields such as 'versionnumber', 'version_id', and 'enterversionnumber'.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MDS_VN_DISTRIBUTOR_PRODUCTS 
WHERE 
    id IS NULL 
    OR muid IS NULL 
    OR versionname IS NULL 
    OR versionnumber IS NULL 
    OR version_id IS NULL 
    OR versionflag IS NULL 
    OR name IS NULL 
    OR code IS NULL 
    OR changetrackingmask IS NULL 
    OR barcode IS NULL 
    OR jnj_sap_code IS NULL 
    OR franchise IS NULL 
    OR category IS NULL 
    OR sub_category IS NULL 
    OR sub_brand IS NULL 
    OR base_bundle IS NULL 
    OR size IS NULL 
    OR product_name IS NULL 
    OR enterdatetime IS NULL 
    OR enterusername IS NULL 
    OR enterversionnumber IS NULL 
    OR lastchgdatetime IS NULL 
    OR lastchgusername IS NULL 
    OR lastchgversionnumber IS NULL 
    OR validationstatus IS NULL 
    OR versionnumber <> enterversionnumber 
    OR version_id <> versionnumber;
========================================================================================================================================

table_name: SDL_GCPH_BRAND
solution: 
1. Check for negative and zero values in numeric fields like width, height, length, volume, gross_weight, and net_weight. These should be flagged as anomalies.
2. Ensure unique_id should be unique. Duplicates indicate an anomaly.
3. Validate EAN_UPC format and length as it should typically be 12 or 13 digits.

snowflake query: 
SELECT * 
FROM SDL_GCPH_BRAND 
WHERE 
    width <= 0 OR 
    height <= 0 OR 
    length <= 0 OR 
    volume <= 0 OR 
    gross_weight <= 0 OR 
    net_weight <= 0 OR 
    unique_id IN (SELECT unique_id FROM SDL_GCPH_BRAND GROUP BY unique_id HAVING COUNT(*) > 1) OR
    LENGTH(ean_upc) NOT IN (12, 13) OR 
    NOT ean_upc RLIKE '^[0-9]+$';
========================================================================================================================================

table_name: SDL_MDS_SG_PRODUCT_EXCEPTIONS
solution: Check for anomalies like duplicate IDs, invalid timestamps, missing or inconsistent data in critical columns like 'barcode', 'versionnumber', or 'muid'. Ensure data consistency and integrity.
snowflake query: 
SELECT
    id,
    COUNT(*) AS count
FROM
    SDL_MDS_SG_PRODUCT_EXCEPTIONS
GROUP BY
    id
HAVING
    COUNT(*) > 1;

SELECT
    *
FROM
    SDL_MDS_SG_PRODUCT_EXCEPTIONS
WHERE
    barcode IS NULL
    OR muid IS NULL
    OR versionnumber IS NULL
    OR enterdatetime > lastchgdatetime
    OR validationstatus NOT IN ('In progress', 'Completed');

SELECT
    id,
    enterusername,
    enterversionnumber
FROM
    SDL_MDS_SG_PRODUCT_EXCEPTIONS
WHERE
    enterversionnumber <> versionnumber;
========================================================================================================================================

table_name : SDL_CLAVIS_GB_PRODUCTS
solution : Detect missing or inconsistent data entries. Address potential data quality issues by reviewing ETL processes and implementing data validation checks.
snowflake query : 
SELECT
    product_id,
    CASE WHEN region IS NULL THEN 'Missing Region' END AS anomaly_type,
    CASE WHEN category IS NULL THEN 'Missing Category' END AS anomaly_type,
    CASE WHEN observed_price < min_price OR observed_price > max_price THEN 'Price Out of Range' END AS anomaly_type
FROM
    SDL_CLAVIS_GB_PRODUCTS
WHERE
    region IS NULL
    OR category IS NULL
    OR observed_price < min_price
    OR observed_price > max_price;
========================================================================================================================================

table_name: SDL_CHS_DSTR
solution: Address negative values in 'LAST_COST', 'SOO_QTY', and 'BACK_ORDER_QTY'. Ensure 'STATUS' is consistently applied per business rules.
snowflake query:
SELECT 
    * 
FROM 
    SDL_CHS_DSTR 
WHERE 
    LAST_COST < 0 
    OR SOO_QTY < 0 
    OR BACK_ORDER_QTY < 0 
    OR STATUS NOT IN ('Active', 'Inactive')
    OR ABC_CODE NOT IN ('A', 'B', 'C')
    OR SOH_QTY < 0 
    OR SOH_AMT < 0;
========================================================================================================================================

table_name: SDL_MY_ACCRUALS
solution: Identify columns with numeric values stored as TEXT and convert them to appropriate numeric data types. Check for negative values in monthly accruals and handle them according to business logic.
snowflake_query: 
SELECT * 
FROM SDL_MY_ACCRUALS 
WHERE TRY_TO_NUMBER(JAN_VAL) IS NULL 
OR TRY_TO_NUMBER(FEB_VAL) IS NULL 
OR TRY_TO_NUMBER(MAR_VAL) IS NULL 
OR TRY_TO_NUMBER(APR_VAL) IS NULL 
OR TRY_TO_NUMBER(MAY_VAL) IS NULL 
OR TRY_TO_NUMBER(JUN_VAL) IS NULL 
OR TRY_TO_NUMBER(JUL_VAL) IS NULL 
OR TRY_TO_NUMBER(AUG_VAL) IS NULL 
OR TRY_TO_NUMBER(SEP_VAL) IS NULL 
OR TRY_TO_NUMBER(OCT_VAL) IS NULL 
OR TRY_TO_NUMBER(NOV_VAL) IS NULL 
OR TRY_TO_NUMBER(DEC_VAL) IS NULL 
OR TRY_TO_NUMBER(JAN_VAL) < 0 
OR TRY_TO_NUMBER(FEB_VAL) < 0 
OR TRY_TO_NUMBER(MAR_VAL) < 0 
OR TRY_TO_NUMBER(APR_VAL) < 0 
OR TRY_TO_NUMBER(MAY_VAL) < 0 
OR TRY_TO_NUMBER(JUN_VAL) < 0 
OR TRY_TO_NUMBER(JUL_VAL) < 0 
OR TRY_TO_NUMBER(AUG_VAL) < 0 
OR TRY_TO_NUMBER(SEP_VAL) < 0 
OR TRY_TO_NUMBER(OCT_VAL) < 0 
OR TRY_TO_NUMBER(NOV_VAL) < 0 
OR TRY_TO_NUMBER(DEC_VAL) < 0;
========================================================================================================================================

sql
table_name : SDL_MDS_VN_PS_TARGETS
solution : Detect duplicate 'muid' values and ensure unique constraints; address any data integrity issues.
snowflake query : 
SELECT 
    muid, 
    COUNT(*) AS occurrences 
FROM 
    SDL_MDS_VN_PS_TARGETS 
GROUP BY 
    muid 
HAVING 
    COUNT(*) > 1;

solution : Identify records with 'validationstatus' marked as 'Invalid' and investigate the reasons for invalid status.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_MDS_VN_PS_TARGETS 
WHERE 
    validationstatus = 'Invalid';


This provides a concise solution to detect anomalies related to duplicate `muid` values and records with an 'Invalid' validation status.
========================================================================================================================================

table_name : SDL_CSL_UDCDETAILS
solution : Identify rows where 'uploadflag' is not 'Y', 'createddate' and 'crt_dttm' have time mismatch, duplicate entries based on unique columns like 'syncid', 'run_id', 'distcode', or mismatches in 'mastervaluecode' and 'mastervaluename'.
snowflake query : 
SELECT *
FROM SDL_CSL_UDCDETAILS
WHERE uploadflag != 'Y'
   OR createddate != crt_dttm
   OR (syncid, run_id, distcode) IN (
       SELECT syncid, run_id, distcode
       FROM SDL_CSL_UDCDETAILS
       GROUP BY syncid, run_id, distcode
       HAVING COUNT(*) > 1
   )
   OR mastervaluecode IS DISTINCT FROM mastervaluename;
========================================================================================================================================

table_name: SDL_GCPH_CATEGORY
solution: Identify negative values in numeric fields and ensure data integrity by cleaning or correcting them. Verify data source for accurate extraction.
snowflake query: 
SELECT * 
FROM SDL_GCPH_CATEGORY
WHERE LENGTH < 0
   OR NET_WEIGHT < 0
   OR VOLUME < 0
   OR GROSS_WEIGHT < 0
   OR HEIGHT < 0
   OR WIDTH < 0;
========================================================================================================================================

table_name: SDL_MDS_PH_DISTRIBUTOR_SUPERVISORS
solution: Analyze the following anomalies:
1. Null or missing data in critical fields like 'ID', 'NAME', 'SLSSPID', 'MUID', etc.
2. Duplicate records based on unique fields like 'ID' or 'SLSSPID'.
3. Inconsistent data types or formats in fields like 'ENTERDATETIME', 'LASTCHGDATETIME', which should be valid timestamps.

snowflake query: 
WITH Anomalies AS (
  SELECT 
    ID,
    COUNT(*) OVER (PARTITION BY ID) AS duplicate_count,
    CASE WHEN ID IS NULL THEN 1 ELSE 0 END AS is_id_null,
    CASE WHEN NAME IS NULL THEN 1 ELSE 0 END AS is_name_null,
    CASE WHEN SLSSPID IS NULL THEN 1 ELSE 0 END AS is_slsspid_null,
    CASE WHEN MUID IS NULL THEN 1 ELSE 0 END AS is_muid_null,
    CASE WHEN TRY_CAST(ENTERDATETIME AS TIMESTAMP_NTZ) IS NULL AND ENTERDATETIME IS NOT NULL THEN 1 ELSE 0 END AS is_enterdatetime_invalid,
    CASE WHEN TRY_CAST(LASTCHGDATETIME AS TIMESTAMP_NTZ) IS NULL AND LASTCHGDATETIME IS NOT NULL THEN 1 ELSE 0 END AS is_lastchgdatetime_invalid
  FROM SDL_MDS_PH_DISTRIBUTOR_SUPERVISORS
)
SELECT 
  * 
FROM 
  Anomalies
WHERE 
  duplicate_count > 1 OR 
  is_id_null = 1 OR 
  is_name_null = 1 OR 
  is_slsspid_null = 1 OR 
  is_muid_null = 1 OR 
  is_enterdatetime_invalid = 1 OR 
  is_lastchgdatetime_invalid = 1;
========================================================================================================================================

table_name: SDL_CSL_RETAILERMASTER
solution: The sample data provided is empty, making it impossible to detect anomalies directly from the sample. However, you can perform general data integrity checks to identify potential anomalies such as NULL values, duplicate entries, and invalid data formats in the table. Below are some SQL queries to help identify these anomalies.

snowflake query: 
-- Query to find NULL values in critical columns
SELECT *
FROM SDL_CSL_RETAILERMASTER
WHERE RTRCODE IS NULL
   OR RTRNAME IS NULL
   OR REGDATE IS NULL;

-- Query to find duplicate retailer codes
SELECT RTRCODE, COUNT(*)
FROM SDL_CSL_RETAILERMASTER
GROUP BY RTRCODE
HAVING COUNT(*) > 1;

-- Query to check for invalid data formats or outliers in numerical fields
SELECT *
FROM SDL_CSL_RETAILERMASTER
WHERE RTRCRLIMIT < 0
   OR RTRCRDAYS < 0;

-- Query to check for expired licenses
SELECT *
FROM SDL_CSL_RETAILERMASTER
WHERE RTRLICEXPIRYDATE < CURRENT_DATE
   OR RTRDRUGEXPIRYDATE < CURRENT_DATE
   OR RTRPESTEXPIRYDATE < CURRENT_DATE;


Ensure that these queries are adapted based on the actual data and business rules specific to your organization.
========================================================================================================================================

table_name: SDL_ECOM_SHOPEE_COMPENSATION
solution: Identify records with extreme values and inconsistencies in compensation data.
snowflake query: 
SELECT * 
FROM SDL_ECOM_SHOPEE_COMPENSATION 
WHERE 
    SUM_OF_QTY <= 0 OR 
    SUM_OF_RSPXQTY <= 0 OR 
    SUM_OF_TOTAL_NET_SELLING_PRICE <= 0 OR 
    SUM_OF_DIS_SHOPEE <= 0 OR 
    SUM_OF_LTPXQTY <= 0 OR 
    SUM_OF_FRONT_MARGIN <= 0 OR 
    SUM_OF_ENABLER_MARGIN <= 0 OR 
    SUM_OF_COMPENSATION <= 0 OR 
    SUM_OF_QTY > 1000000 OR 
    SUM_OF_RSPXQTY > 1000000 OR 
    SUM_OF_TOTAL_NET_SELLING_PRICE > 1000000 OR 
    SUM_OF_DIS_SHOPEE > 1000000 OR 
    SUM_OF_LTPXQTY > 1000000 OR 
    SUM_OF_FRONT_MARGIN > 1000000 OR 
    SUM_OF_ENABLER_MARGIN > 1000000 OR 
    SUM_OF_COMPENSATION > 1000000;
========================================================================================================================================

table_name: SDL_CSL_RETAILERROUTE
solution: Ensure all `rtrid`, `rmid`, `run_id`, and `syncid` are non-null and unique. Check `uploadflag` consistency and ensure all timestamps are valid.
snowflake query: 
SELECT *
FROM SDL_CSL_RETAILERROUTE
WHERE rtrid IS NULL
   OR rmid IS NULL
   OR run_id IS NULL
   OR syncid IS NULL
   OR uploadflag NOT IN ('Y', 'N')
   OR createddate IS NULL
   OR crt_dttm IS NULL
   OR rtrid IN (SELECT rtrid FROM SDL_CSL_RETAILERROUTE GROUP BY rtrid HAVING COUNT(*) > 1)
   OR rmid IN (SELECT rmid FROM SDL_CSL_RETAILERROUTE GROUP BY rmid HAVING COUNT(*) > 1)
   OR run_id IN (SELECT run_id FROM SDL_CSL_RETAILERROUTE GROUP BY run_id HAVING COUNT(*) > 1)
   OR syncid IN (SELECT syncid FROM SDL_CSL_RETAILERROUTE GROUP BY syncid HAVING COUNT(*) > 1);
========================================================================================================================================

table_name : SDL_GCCH_CUST_HIER
solution : Identify and resolve anomalies related to missing data, invalid data, and data inconsistencies. Enhance data validation and cleaning processes for future data loads.
snowflake query : 
SELECT 
    *
FROM 
    SDL_GCCH_CUST_HIER
WHERE 
    unique_id IS NULL
    OR tamr_id IS NULL 
    OR suggestedclassificationscore NOT BETWEEN 0 AND 100 
    OR postal_code NOT REGEXP '^[0-9]{5}$'
    OR cdl_datetime IS NULL 
    OR dateofextract IS NULL
    OR cdl_datetime NOT BETWEEN DATEADD(DAY, -30, CURRENT_DATE()) AND CURRENT_DATE()
    OR dateofextract NOT BETWEEN DATEADD(DAY, -30, CURRENT_DATE()) AND CURRENT_DATE()
    OR country IS NULL 
    OR region IS NULL 
    OR city IS NULL
    OR state IS NULL
    OR manualclassificationid IS NULL;
========================================================================================================================================

sql
table_name: SDL_JNJ_MER_COP
solution: Identify anomalies such as missing data, inconsistent data types, and logical inconsistencies.
snowflake_query: 
SELECT * FROM SDL_JNJ_MER_COP
WHERE
  -- Check for missing or NULL values in critical columns
  emp_address_pc IS NULL OR
  store_id IS NULL OR
  store_name IS NULL OR
  supervisor_name IS NULL OR
  start_date IS NULL OR
  end_date IS NULL OR
  
  -- Check for logical inconsistencies
  start_date > end_date OR
  compliance NOT IN ('Yes', 'No') OR
  cop_priority NOT IN ('Low', 'Medium', 'High') OR
  
  -- Check for invalid data formats or lengths
  LENGTH(store_id) <> 8 OR
  LENGTH(yearmo) <> 6 OR
  LENGTH(cop_date) <> 10 OR
  
  -- Check for invalid data types
  TRY_CAST(run_id AS NUMBER) IS NULL OR
  TRY_CAST(yearmo AS NUMBER) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_SG_PRODUCT_MAPPING
solution: Identify anomalies like duplicate entries, missing data, or inconsistent data types. Implement checks on unique constraints and mandatory fields. Ensure data type consistency and validate relationships between fields.
snowflake query: 
-- Detecting duplicate entries based on unique fields
SELECT 
    muid, COUNT(*)
FROM 
    SDL_MDS_SG_PRODUCT_MAPPING
GROUP BY 
    muid
HAVING 
    COUNT(*) > 1;

-- Checking for missing or null values in critical columns
SELECT 
    *
FROM 
    SDL_MDS_SG_PRODUCT_MAPPING
WHERE 
    muid IS NULL OR 
    versionname IS NULL OR 
    code IS NULL;

-- Ensuring data type consistency, assuming 'versionnumber' should always be a valid number
SELECT 
    *
FROM 
    SDL_MDS_SG_PRODUCT_MAPPING
WHERE 
    TRY_CAST(versionnumber AS NUMBER) IS NULL;

-- Validating relationships, e.g., 'customer_name_id' should exist if 'customer_name_code' is present
SELECT 
    *
FROM 
    SDL_MDS_SG_PRODUCT_MAPPING
WHERE 
    customer_name_code IS NOT NULL AND 
    customer_name_id IS NULL;
========================================================================================================================================

table_name: SDL_POP6_SG_PRODUCT_LISTS_POPS
solution: Validate data types and check for NULL values or inconsistencies in critical columns to ensure data integrity.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    SUM(CASE WHEN CRTD_DTTM IS NULL THEN 1 ELSE 0 END) AS crt_dttm_nulls,
    SUM(CASE WHEN FILE_NAME IS NULL OR FILE_NAME = '' THEN 1 ELSE 0 END) AS file_name_issues,
    SUM(CASE WHEN POP_NAME IS NULL OR POP_NAME = '' THEN 1 ELSE 0 END) AS pop_name_issues,
    SUM(CASE WHEN PROD_GRP_DATE IS NULL THEN 1 ELSE 0 END) AS prod_grp_date_nulls,
    SUM(CASE WHEN PRODUCT_LIST IS NULL OR PRODUCT_LIST = '' THEN 1 ELSE 0 END) AS product_list_issues,
    SUM(CASE WHEN POP_CODE IS NULL OR POP_CODE = '' THEN 1 ELSE 0 END) AS pop_code_issues,
    SUM(CASE WHEN RUN_ID IS NULL THEN 1 ELSE 0 END) AS run_id_nulls,
    SUM(CASE WHEN POPDB_ID IS NULL OR POPDB_ID = '' THEN 1 ELSE 0 END) AS popdb_id_issues,
    SUM(CASE WHEN HASHKEY IS NULL OR HASHKEY = '' THEN 1 ELSE 0 END) AS hashkey_issues
FROM SDL_POP6_SG_PRODUCT_LISTS_POPS;
========================================================================================================================================

table_name: SDL_CBD_GT_SALES_REPORT_FACT

solution: 
1. Ensure unique `billing_no` or handle duplicates appropriately.
2. Validate `foc_qty` for negative values; ensure logical consistency.
3. Verify `billing_date` and `expiry_date` alignment; expiry should be after billing.
4. Cross-check `sales_qty` and `net_sales` for logical pricing consistency.
5. Check for missing or inconsistent `sales_rep_no` and `order_no`.
6. Confirm `crt_dttm` timestamps are correctly logged and in sequence.

snowflake query: 
SELECT 
    billing_no, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
GROUP BY 
    billing_no
HAVING 
    COUNT(*) > 1;

SELECT 
    *
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
WHERE 
    foc_qty < 0;

SELECT 
    *
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
WHERE 
    billing_date >= expiry_date;

SELECT 
    *
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
WHERE 
    sales_qty * net_price != net_sales;

SELECT 
    *
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
WHERE 
    sales_rep_no IS NULL 
    OR order_no IS NULL;

SELECT 
    *
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT
ORDER BY 
    crt_dttm ASC;
========================================================================================================================================

table_name : SDL_KR_COUPANG_PRODUCT_SUMMARY_MONTHLY
solution : 
1. Ensure `RUN_ID` is non-negative.
2. Validate `yearmo` follows 'YYYYMM' format.
3. Handle NULL values in `CATEGORY_DEPTH3`.
4. Verify `RANKING` is numeric.

snowflake query : 
SELECT 
  coupang_sku_id, 
  coupang_sku_name, 
  run_id, 
  yearmo, 
  category_depth3, 
  ranking 
FROM 
  SDL_KR_COUPANG_PRODUCT_SUMMARY_MONTHLY
WHERE 
  run_id < 0 
  OR NOT TRY_TO_NUMBER(yearmo) IS NOT NULL 
  OR LENGTH(yearmo) != 6 
  OR category_depth3 IS NULL 
  OR NOT TRY_TO_NUMBER(ranking) IS NOT NULL;
========================================================================================================================================

table_name: SDL_LA_GT_SELLOUT_FACT
solution: Identify negative or zero totals and discounts, ensure order dates are valid, and verify non-null fields for critical columns.
snowflake query:
SELECT *
FROM SDL_LA_GT_SELLOUT_FACT
WHERE TOTAL <= 0
   OR DISCOUNT < 0
   OR ORDERDATE IS NULL
   OR DISTRIBUTORID IS NULL
   OR ORDERNO IS NULL
   OR PRODUCTCODE IS NULL
   OR QTY IS NULL
   OR GROSSPRICE IS NULL
   OR TOTALBEFOREVAT IS NULL
   OR ISNULL(ISCANCEL, 0) NOT IN (0, 1);
========================================================================================================================================

table_name : SDL_MDS_PH_LAV_CUSTOMER
solution : Identify and address potential anomalies such as NULL values, duplicate entries, and inconsistent data types. Ensure data integrity by standardizing formats and removing or correcting erroneous data.
snowflake query : 
-- Detect NULL values in critical columns
SELECT *
FROM SDL_MDS_PH_LAV_CUSTOMER
WHERE DISTCODE_NAME IS NULL 
   OR PROVINCECODE_CODE IS NULL 
   OR NAME IS NULL;

-- Detect duplicate entries based on a combination of columns likely to represent unique records
SELECT NAME, COUNT(*)
FROM SDL_MDS_PH_LAV_CUSTOMER
GROUP BY NAME
HAVING COUNT(*) > 1;

-- Check for inconsistent data types or formats (e.g., if any IDs are stored as text)
SELECT *
FROM SDL_MDS_PH_LAV_CUSTOMER
WHERE TRY_TO_NUMBER(MUID) IS NULL AND MUID IS NOT NULL
   OR TRY_TO_NUMBER(ID) IS NULL AND ID IS NOT NULL;
========================================================================================================================================

table_name: SDL_MDS_PH_LAV_PRODUCT
solution: Identify missing or inconsistent data entries, such as NULL values or duplicate entries.
snowflake query:

-- Detect NULL values across all columns
SELECT * 
FROM SDL_MDS_PH_LAV_PRODUCT
WHERE ID IS NULL OR MUID IS NULL OR VERSIONNAME IS NULL OR VERSIONNUMBER IS NULL OR VERSION_ID IS NULL OR VERSIONFLAG IS NULL 
OR NAME IS NULL OR CODE IS NULL OR CHANGETRACKINGMASK IS NULL OR SCARDFRANCHISECODE_CODE IS NULL OR SCARDFRANCHISECODE_NAME IS NULL 
OR SCARDFRANCHISECODE_ID IS NULL OR SCARDBRANDCODE_CODE IS NULL OR SCARDBRANDCODE_NAME IS NULL OR SCARDBRANDCODE_ID IS NULL 
OR SCARDVARIANTCODE_CODE IS NULL OR SCARDVARIANTCODE_NAME IS NULL OR SCARDVARIANTCODE_ID IS NULL OR SCARDPUTUPCODE_CODE IS NULL 
OR SCARDPUTUPCODE_NAME IS NULL OR SCARDPUTUPCODE_ID IS NULL OR REPORTGROUP1DESC_CODE IS NULL OR REPORTGROUP1DESC_NAME IS NULL 
OR REPORTGROUP1DESC_ID IS NULL OR REPORTGROUP2DESC_CODE IS NULL OR REPORTGROUP2DESC_NAME IS NULL OR REPORTGROUP2DESC_ID IS NULL 
OR REPORTGROUP3DESC_CODE IS NULL OR REPORTGROUP3DESC_NAME IS NULL OR REPORTGROUP3DESC_ID IS NULL OR REPORTGROUP4DESC_CODE IS NULL 
OR REPORTGROUP4DESC_NAME IS NULL OR REPORTGROUP4DESC_ID IS NULL OR REPORTGROUP5DESC_CODE IS NULL OR REPORTGROUP5DESC_NAME IS NULL 
OR REPORTGROUP5DESC_ID IS NULL OR PROMOREG_CODE IS NULL OR PROMOREG_NAME IS NULL OR PROMOREG_ID IS NULL OR IMSOTCTAG_CODE IS NULL 
OR IMSOTCTAG_NAME IS NULL OR IMSOTCTAG_ID IS NULL OR PROMOSTARTPERIOD IS NULL OR PROMOENDPERIOD IS NULL OR NPISTARTPERIOD IS NULL 
OR PRICELASTPERIOD IS NULL OR HERO_SKU_CODE IS NULL OR HERO_SKU_NAME IS NULL OR HERO_SKU_ID IS NULL OR $SOURCENATURALKEY IS NULL 
OR ENTERDATETIME IS NULL OR ENTERUSERNAME IS NULL OR ENTERVERSIONNUMBER IS NULL OR LASTCHGDATETIME IS NULL OR LASTCHGUSERNAME IS NULL 
OR LASTCHGVERSIONNUMBER IS NULL OR VALIDATIONSTATUS IS NULL;

-- Detect duplicate entries based on unique columns
SELECT ID, COUNT(*) AS count
FROM SDL_MDS_PH_LAV_PRODUCT
GROUP BY ID
HAVING COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_LA_GT_CUSTOMER
solution: The table exhibits several anomalies, notably missing data in numerous columns, and negative values in the 'ACTIVESTATUS' column, which likely indicates an error or placeholder. To address these issues, consider setting default values for columns that frequently contain nulls, implementing data validation constraints to prevent invalid data entry, and performing regular data audits.

snowflake query: 
SELECT 
    *
FROM 
    SDL_LA_GT_CUSTOMER
WHERE 
    ARNAME IS NULL 
    OR ARADDRESS IS NULL 
    OR TELEPHONE IS NULL 
    OR FAX IS NULL 
    OR CITY IS NULL 
    OR REGION IS NULL 
    OR SALEEMPLOYEE IS NULL 
    OR ACTIVATESTATUS < 0;
========================================================================================================================================

table_name: SDL_IG_INVENTORY_DATA
solution: The sample data for the table is entirely empty. Verify the data ingestion process, ensure data sources are active and correctly connected, and check for any data pipeline issues. Once the source and pipeline issues are resolved, rerun the data load process to populate the table.
snowflake query: 
SELECT 
    COUNT(*) AS total_records, 
    COUNT(CASE WHEN COLUMN_NAME IS NULL THEN 1 END) AS null_count 
FROM SDL_IG_INVENTORY_DATA;
========================================================================================================================================

table_name: SDL_HK_IMS_WINGKEUNG_SEL_OUT
solution: Detect negative sales volumes, zero net trade sales, and ensure exchange rates and timestamps are reasonable.
snowflake query: 
SELECT
    *,
    CASE WHEN SALES_VOLUME < 0 THEN 'Negative Sales Volume' END AS SALES_VOLUME_ANOMALY,
    CASE WHEN NET_TRADE_SALES = 0 THEN 'Zero Net Trade Sales' END AS NET_TRADE_SALES_ANOMALY,
    CASE WHEN LOCAL_CURR_EXCH_RATE <= 0 THEN 'Invalid Exchange Rate' END AS EXCHANGE_RATE_ANOMALY,
    CASE WHEN CRT_DTTM > CURRENT_TIMESTAMP() THEN 'Future Creation Timestamp' END AS CRT_DTTM_ANOMALY,
    CASE WHEN UPDT_DTTM > CURRENT_TIMESTAMP() THEN 'Future Update Timestamp' END AS UPDT_DTTM_ANOMALY
FROM SDL_HK_IMS_WINGKEUNG_SEL_OUT
WHERE SALES_VOLUME < 0 OR NET_TRADE_SALES = 0 OR LOCAL_CURR_EXCH_RATE <= 0
OR CRT_DTTM > CURRENT_TIMESTAMP() OR UPDT_DTTM > CURRENT_TIMESTAMP();
========================================================================================================================================

table_name: SDL_ID_POS_IDM_SELLOUT
solution: The anomalies include negative RUN_ID values and incorrect YEARMONTH formats. For RUN_ID, ensure that only positive integers are allowed. For YEARMONTH, ensure it follows YYYYMM format without exceeding valid month numbers. Implement data validation and transformation checks before data ingestion.
snowflake query: 
SELECT *
FROM SDL_ID_POS_IDM_SELLOUT
WHERE RUN_ID < 0
   OR YEARMONTH NOT LIKE '____%'
   OR TRY_CAST(SUBSTRING(YEARMONTH, 5, 2) AS INTEGER) NOT BETWEEN 1 AND 12;
========================================================================================================================================

table_name : CUST_CUSTOMER
solution : Correct negative 'fetchedsequence' values, validate country codes, ensure unique 'customerid'.
snowflake query : 
SELECT * 
FROM CUST_CUSTOMER 
WHERE fetchedsequence < 0 
   OR country NOT IN ('USA', 'WAK', 'ValidCountryCodes') 
   OR customerid IN (
       SELECT customerid 
       FROM CUST_CUSTOMER 
       GROUP BY customerid 
       HAVING COUNT(*) > 1
   );
========================================================================================================================================

table_name: SDL_CHW_ECOMM_DATA
solution: Investigate negative sales and units, correct MAT_YEAR discrepancies, and validate category consistency with NEC2_DESC.
snowflake_query: 
SELECT 
    pfc, skuname, nec1_desc, nec2_desc, nec3_desc, brand, owner, manufacturer, category, mat_year, periodid, sales_online, unit_online, week_end, file_name, crt_dttm
FROM 
    SDL_CHW_ECOMM_DATA
WHERE 
    CAST(sales_online AS FLOAT) < 0 
    OR CAST(unit_online AS FLOAT) < 0 
    OR mat_year NOT BETWEEN '1900' AND '2100'
    OR category != nec2_desc;
========================================================================================================================================

table_name: SDL_ID_POS_DAILY_BASEDLINE_SELLOUT
solution: Identify and address anomalies where expected values deviate significantly. Ensure data consistency and validate with historical trends.
snowflake query: 
SELECT 
    KEY_ACCOUNT, 
    PLU, 
    MONTH, 
    YEAR, 
    ROI_MONTH, 
    QTY_TRX, 
    CUM_YTM_QTY, 
    PROMO_QTY, 
    CUM_PROMO_QTY, 
    BASEDLINE_TOTAL_QTY, 
    CUM_BASEDLINE_TOTAL_QTY, 
    TOTAL_DAYS, 
    CUM_TOTAL_DAYS, 
    PROMO_DAYS, 
    CUM_PROMO_DAYS, 
    BASELINED_TOTAL_DAYS, 
    CUM_BASELINED_TOTAL_DAYS, 
    TOTAL_QTY_BASELINED, 
    INDIRECT_QTY_TRX, 
    INDIRECT_CUM_QTY, 
    INDIRECT_PROMO_QTY, 
    INDIRECT_CUM_PROMO_QTY, 
    INDIRECT_BASEDLINE_TOTAL_QTY, 
    INDIRECT_CUM_BASEDLINE_TOTAL_QTY, 
    INDIRECT_QTY_BASELINED, 
    POS_CUST, 
    YEARMONTH, 
    RUN_ID, 
    CRTD_DTTM, 
    FILE_NAME
FROM SDL_ID_POS_DAILY_BASEDLINE_SELLOUT
WHERE 
    (QTY_TRX < 0 OR CUM_YTM_QTY < 0 OR PROMO_QTY < 0 OR CUM_PROMO_QTY < 0 OR 
    BASEDLINE_TOTAL_QTY < 0 OR CUM_BASEDLINE_TOTAL_QTY < 0 OR TOTAL_DAYS < 0 OR 
    CUM_TOTAL_DAYS < 0 OR PROMO_DAYS < 0 OR CUM_PROMO_DAYS < 0 OR BASELINED_TOTAL_DAYS < 0 OR 
    CUM_BASELINED_TOTAL_DAYS < 0 OR TOTAL_QTY_BASELINED < 0 OR INDIRECT_QTY_TRX < 0 OR 
    INDIRECT_CUM_QTY < 0 OR INDIRECT_PROMO_QTY < 0 OR INDIRECT_CUM_PROMO_QTY < 0 OR 
    INDIRECT_BASEDLINE_TOTAL_QTY < 0 OR INDIRECT_CUM_BASEDLINE_TOTAL_QTY < 0 OR 
    INDIRECT_QTY_BASELINED < 0) OR 
    (YEAR < 2023 OR YEAR > 2100) OR 
    (MONTH < 1 OR MONTH > 12);
========================================================================================================================================

table_name: SDL_MDS_MY_SKU_BENCHMARKS
solution: Identify and address anomalies such as negative values in columns where they are not expected, ensure consistency in reference data, and validate the presence of expected data. For instance, negative `versionnumber` or `comp_packsize` might indicate data entry errors. Additionally, ensure timestamps are logically ordered and not identical for `valid_from` and `valid_to`.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MDS_MY_SKU_BENCHMARKS 
WHERE 
    versionnumber < 0 
    OR comp_packsize < 0 
    OR version_id IS NULL 
    OR changetrackingmask IS NULL 
    OR jj_upc IS NULL 
    OR valid_to < valid_from 
    OR valid_from = valid_to 
    OR validationstatus NOT IN ('Approved', 'Rejected', 'Valid', 'Under Review', 'Invalid') 
    OR enterusername IS NULL 
    OR lastchgusername IS NULL;
========================================================================================================================================

table_name: SDL_CSL_PRODUCTWISESTOCK
solution: Check for missing or inconsistent data in stock-related columns, especially for transactions related to stocks (e.g., purchase, sales, stock-in, stock-out) where values might be unexpectedly zero or null. Ensure transaction dates are not null and fall within expected ranges. Validate that product codes and location codes are consistent and exist in reference tables.
snowflake query: 
SELECT 
    distcode, 
    transdate, 
    lcnid, 
    lcncode, 
    prdid, 
    prdcode, 
    salopenstock, 
    unsalopenstock, 
    offeropenstock, 
    salpurchase, 
    unsalpurchase, 
    offerpurchase, 
    salpurreturn, 
    unsalpurreturn, 
    offerpurreturn, 
    salsales, 
    unsalsales, 
    offersales, 
    salstockin, 
    unsalstockin, 
    offerstockin, 
    salstockout, 
    unsalstockout, 
    offerstockout, 
    damagein, 
    damageout, 
    salsalesreturn, 
    unsalsalesreturn, 
    offersalesreturn, 
    salstkjurin, 
    unsalstkjurin, 
    offerstkjurin, 
    salstkjurout, 
    unsalstkjurout, 
    offerstkjurout, 
    salbattfrin, 
    unsalbattfrin, 
    offerbattfrin, 
    salbattfrout, 
    unsalbattfrout, 
    offerbattfrout, 
    sallcntfrin, 
    unsallcntfrin, 
    offerlcntfrin, 
    sallcntfrout, 
    unsallcntfrout, 
    offerlcntfrout, 
    salreplacement, 
    offerreplacement, 
    salclsstock, 
    unsalclsstock, 
    offerclsstock, 
    uploaddate, 
    uploadflag, 
    createddate, 
    syncid, 
    run_id, 
    crt_dttm, 
    file_name
FROM SDL_CSL_PRODUCTWISESTOCK
WHERE transdate IS NULL 
    OR salopenstock IS NULL 
    OR unsalopenstock IS NULL 
    OR offeropenstock IS NULL 
    OR salpurchase IS NULL 
    OR unsalpurchase IS NULL 
    OR offerpurchase IS NULL 
    OR salsales IS NULL 
    OR unsalsales IS NULL 
    OR offersales IS NULL 
    OR salstockin IS NULL 
    OR unsalstockin IS NULL 
    OR offerstockin IS NULL 
    OR salstockout IS NULL 
    OR unsalstockout IS NULL 
    OR offerstockout IS NULL 
    OR damagein IS NULL 
    OR damageout IS NULL 
    OR salsalesreturn IS NULL 
    OR unsalsalesreturn IS NULL 
    OR offersalesreturn IS NULL 
    OR salstkjurin IS NULL 
    OR unsalstkjurin IS NULL 
    OR offerstkjurin IS NULL 
    OR salstkjurout IS NULL 
    OR unsalstkjurout IS NULL 
    OR offerstkjurout IS NULL 
    OR salbattfrin IS NULL 
    OR unsalbattfrin IS NULL 
    OR offerbattfrin IS NULL 
    OR salbattfrout IS NULL 
    OR unsalbattfrout IS NULL 
    OR offerbattfrout IS NULL 
    OR sallcntfrin IS NULL 
    OR unsallcntfrin IS NULL 
    OR offerlcntfrin IS NULL 
    OR sallcntfrout IS NULL 
    OR unsallcntfrout IS NULL 
    OR offerlcntfrout IS NULL 
    OR salreplacement IS NULL 
    OR offerreplacement IS NULL 
    OR salclsstock IS NULL 
    OR unsalclsstock IS NULL 
    OR offerclsstock IS NULL 
    OR uploaddate IS NULL 
    OR createddate IS NULL 
    OR syncid IS NULL 
    OR run_id IS NULL 
    OR crt_dttm IS NULL;
========================================================================================================================================

table_name: SDL_KR_BO_YOUNG_JONG_HAP_LOGISTICS_GT_SELLOUT
solution: Check for negative or zero values in 'QTY' and 'UNIT_PRICE', and ensure 'EAN' codes are consistent for the same 'TRADE_NAME'.
snowflake query: 
SELECT *
FROM SDL_KR_BO_YOUNG_JONG_HAP_LOGISTICS_GT_SELLOUT
WHERE CAST(QTY AS NUMBER) <= 0
   OR CAST(UNIT_PRICE AS NUMBER) <= 0
   OR TRADE_NAME IN (
       SELECT TRADE_NAME
       FROM SDL_KR_BO_YOUNG_JONG_HAP_LOGISTICS_GT_SELLOUT
       GROUP BY TRADE_NAME, EAN
       HAVING COUNT(DISTINCT EAN) > 1
   );
========================================================================================================================================

table_name: SDL_DAILYSALES_DEL
solution: Detect negative or unusual values and ensure data integrity. Check for logical inconsistencies in timestamps and numerical values. Implement data validation rules to prevent such anomalies.
snowflake_query: 
SELECT 
  *,
  CASE WHEN salinvlinecount < 0 THEN 'Negative Line Count' END AS anomaly_line_count,
  CASE WHEN prdqty < 0 THEN 'Negative Product Quantity' END AS anomaly_product_quantity,
  CASE WHEN salgrossamt != salnetamt THEN 'Gross and Net Amount Mismatch' END AS anomaly_amount_mismatch,
  CASE WHEN salinvdate > saldlvdate THEN 'Invoice Date After Delivery Date' END AS anomaly_date_mismatch
FROM SDL_DAILYSALES_DEL
WHERE 
  salinvlinecount < 0 
  OR prdqty < 0 
  OR salgrossamt != salnetamt 
  OR salinvdate > saldlvdate;
========================================================================================================================================

sql
table_name : SDL_CSL_SALESRETURN
solution : Check for missing or null values, verify data types, and ensure correct relationships between columns.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_CSL_SALESRETURN
WHERE 
    distcode IS NULL 
    OR srnrefno IS NULL 
    OR srnreftype IS NULL 
    OR srndate IS NULL 
    OR srnmode IS NULL 
    OR srntype IS NULL 
    OR srngrossamt < 0 
    OR srnspldiscamt < 0 
    OR srnschdiscamt < 0 
    OR srncashdiscamt < 0 
    OR srndbdiscamt < 0 
    OR srntaxamt < 0 
    OR srnroundoffamt < 0 
    OR srnnetamt < 0 
    OR prdgrossamt < 0 
    OR prdspldiscamt < 0 
    OR prdschdiscamt < 0 
    OR prdcashdiscamt < 0 
    OR prddbdiscamt < 0 
    OR prdtaxamt < 0 
    OR prdnetamt < 0 
    OR mrp < 0 
    OR prdsalqty < 0 
    OR prdunsalqty < 0 
    OR prdofferqty < 0 
    OR rtnfreeqtyvalue < 0 
    OR rtnlinecount < 0 
    OR prdselrate < 0 
    OR prdselrateaftertax < 0 
    OR salesmancode IS NULL 
    OR salesroutecode IS NULL 
    OR salesmancode NOT IN (SELECT DISTINCT salesmancode FROM SDL_CSL_SALESROUTE)
    OR salesroutecode NOT IN (SELECT DISTINCT salesroutecode FROM SDL_CSL_SALESROUTE);
========================================================================================================================================

table_name: SDL_ECOM_SEARCH_ADS_BY_CHANNEL
solution: Review and clean empty data fields, ensure data integrity and consistency.
snowflake_query: 
SELECT *
FROM SDL_ECOM_SEARCH_ADS_BY_CHANNEL
WHERE SALES_USD IS NULL OR SALES_LCY IS NULL OR ORDERS IS NULL OR UNITS_SOLD IS NULL OR VISITS IS NULL OR UNIQUE_VISITORS IS NULL OR ADD_TO_CART_UNITS IS NULL OR ADD_TO_CART_VALUE_USD IS NULL OR ADD_TO_CART_VALUE_LCY IS NULL OR BUYERS IS NULL OR NEW_BUYERS IS NULL OR ITEM_CONVERSION_RATE IS NULL OR CRTD_DTTM IS NULL OR FILENAME IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PH_MSL_HDR
solution: The table contains numerous NULL values across multiple columns. Review and determine if these NULLs are expected or if data needs to be populated. Ensure data integrity by implementing checks and validation rules during data entry or migration.
snowflake query: 
SELECT * 
FROM SDL_MDS_PH_MSL_HDR 
WHERE 
  muid IS NULL OR 
  versionname IS NULL OR 
  versionflag IS NULL OR 
  name IS NULL OR 
  code IS NULL OR 
  csg_code_code IS NULL OR 
  csg_code_name IS NULL OR 
  fr_salescycle IS NULL OR 
  to_salescycle IS NULL OR 
  enterusername IS NULL OR 
  lastchgusername IS NULL OR 
  validationstatus IS NULL;
========================================================================================================================================

table_name: SDL_JNJ_CONSUMERREACH_711
solution: Identify and correct anomalies such as missing values, inconsistent date formats, and invalid data. Ensure data consistency and integrity.
snowflake query: 
SELECT * 
FROM SDL_JNJ_CONSUMERREACH_711
WHERE 
    retailbranch IS NULL OR
    jjskubarcode IS NULL OR
    cdate NOT LIKE '____-__-__' OR
    yearmo NOT LIKE '____-__' OR
    status NOT IN ('Active', 'Inactive') OR
    run_id < 0 OR
    yearmo = '9999-12';
========================================================================================================================================

table_name : SDL_CBD_GT_SALES_REPORT_FACT_TEMP
solution : 
- Review negative values in 'sales_qty', 'foc_qty', 'net_price', and 'net_sales'. Confirm if negative values are valid or due to errors.
- Validate 'expiry_date' for correctness and check if any expired products are recorded.
- Verify if 'return_reason' aligns with negative sales data.
- Ensure consistency between 'crt_dttm' and 'updt_dttm'.

snowflake query : 
SELECT 
    * 
FROM 
    SDL_CBD_GT_SALES_REPORT_FACT_TEMP
WHERE 
    sales_qty < 0 
    OR foc_qty < 0 
    OR net_price < 0 
    OR net_sales < 0 
    OR expiry_date < CURRENT_DATE()
    OR crt_dttm <> updt_dttm;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_CUSTOMER_DIM
solution: Detect null or inconsistent values in key columns like 'key_outlet', 'address', 'city', 'cust_grp', and 'chnl_grp2'. Ensure data consistency and fill in missing values or correct inconsistencies where applicable.
snowflake query: 
SELECT 
    *
FROM 
    SDL_DISTRIBUTOR_CUSTOMER_DIM
WHERE 
    key_outlet IS NULL
    OR address IS NULL
    OR city IS NULL
    OR cust_grp IS NULL
    OR chnl_grp2 IS NULL
    OR key_outlet = ''
    OR address = ''
    OR city = ''
    OR cust_grp = ''
    OR chnl_grp2 = '';
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_OUTLET_MASTER
solution: Identify columns with potential anomalies such as missing data, erroneous data types, and incorrect values. Address these by implementing data validation, enforcing constraints, and cleaning the dataset.
snowflake_query: 
SELECT 
    DISTRIBUTORCODE, USERCODE, LOCATIONCODE, OUTLETCODE, OUTLETNAME, OUTLETADDRESS, PINCODE, CHANNELCODE, CHANNELNAME, SUBCHANNELCODE, SUBCHANNELNAME, TIERINGCODE, TIERINGNAME, CLASSCODE, ROUTECODE, VISIT_FREQUENCY, VISITDAY, JNJ_ID, CONTACTPERSON, CREDIT_LIMIT, INVOICE_LIMIT, CREDIT_PERIOD, TIN, IS_DIAMOND_STORE, ID_NO, MASTER_CODE, STORE_CLUSTER, LATTITUDE, LONGITUDE, CDL_DTTM, RUN_ID, FILE_NAME
FROM 
    SDL_DISTRIBUTOR_IVY_OUTLET_MASTER
WHERE 
    DISTRIBUTORCODE IS NULL OR 
    USERCODE IS NULL OR 
    LOCATIONCODE IS NULL OR 
    OUTLETCODE IS NULL OR 
    OUTLETNAME IS NULL OR 
    OUTLETADDRESS IS NULL OR 
    PINCODE IS NULL OR 
    CHANNELCODE IS NULL OR 
    CHANNELNAME IS NULL OR 
    SUBCHANNELCODE IS NULL OR 
    SUBCHANNELNAME IS NULL OR 
    TIERINGCODE IS NULL OR 
    TIERINGNAME IS NULL OR 
    CLASSCODE IS NULL OR 
    ROUTECODE IS NULL OR 
    LATTITUDE IS NULL OR 
    LONGITUDE IS NULL OR 
    CREDIT_LIMIT < 0 OR 
    INVOICE_LIMIT < 0 OR 
    CREDIT_PERIOD < 0 OR 
    IS_DIAMOND_STORE NOT IN ('YES', 'NO');
========================================================================================================================================

table_name: SDL_MDS_APAC_DCL_TARGETS
solution: Check for null values in critical columns and unusual value ranges. Ensure all target months have valid data. Verify datatype consistency.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MDS_APAC_DCL_TARGETS 
WHERE 
    ID IS NULL 
    OR MUID IS NULL 
    OR VERSIONNAME IS NULL 
    OR VERSIONNUMBER IS NULL 
    OR VERSION_ID IS NULL 
    OR COUNTRY_CODE IS NULL 
    OR COUNTRY_NAME IS NULL 
    OR SALES_CHANNEL_CODE IS NULL 
    OR SALES_CHANNEL_NAME IS NULL 
    OR YEAR_CODE IS NULL 
    OR YEAR_NAME IS NULL 
    OR (JAN IS NULL OR FEB IS NULL OR MAR IS NULL OR APR IS NULL OR MAY IS NULL OR JUN IS NULL OR JUL IS NULL OR AUG IS NULL OR SEP IS NULL OR OCT IS NULL OR NOV IS NULL OR DEC IS NULL)
    OR YEAR_ID IS NULL 
    OR TARGET_TYPE_CODE IS NULL 
    OR TARGET_TYPE_NAME IS NULL 
    OR TARGET_TYPE_ID IS NULL 
    OR SALES_CHANNEL_ID IS NULL 
    OR COUNTRY_ID IS NULL 
    OR ENTERDATETIME IS NULL 
    OR LASTCHGDATETIME IS NULL 
    OR ENTERUSERNAME IS NULL 
    OR LASTCHGUSERNAME IS NULL 
    OR VALIDATIONSTATUS IS NULL
    OR JAN < 0 OR FEB < 0 OR MAR < 0 OR APR < 0 OR MAY < 0 OR JUN < 0 OR JUL < 0 OR AUG < 0 OR SEP < 0 OR OCT < 0 OR NOV < 0 OR DEC < 0;
========================================================================================================================================

table_name: SDL_MDS_SG_CUSTOMER_HIERARCHY
solution: There are anomalies with negative IDs and version numbers. Ensure all IDs and version numbers are positive as they should logically represent positive values. Also, the validation status should ideally be consistent with business rules (e.g., "Invalid" and "Pending" statuses need review).

snowflake query: 
SELECT * 
FROM SDL_MDS_SG_CUSTOMER_HIERARCHY
WHERE id < 0
   OR versionnumber < 0
   OR validationstatus IN ('Invalid', 'Pending');
========================================================================================================================================

table_name : SDL_ECOM_BACKMARGIN
solution : Identify negative values in rebate columns. Ensure rebates are positive or zero.
snowflake query : 
SELECT *
FROM SDL_ECOM_BACKMARGIN
WHERE SELLER_VOUCHER_REBATE < 0 
   OR PLATFORM_VOUCHER_SELLER_REBATE < 0 
   OR PLATFORM_VOUCHER_SHOPEE_REBATE < 0 
   OR COIN_USED < 0 
   OR SELLER_VOUCHER_COIN_EARN < 0 
   OR PLATFORM_VOUCHER_COIN_EARN < 0;

table_name : SDL_ECOM_BACKMARGIN
solution : Check if item price with discounts applied matches order value.
snowflake query : 
SELECT *
FROM SDL_ECOM_BACKMARGIN
WHERE ORDER_VALUE != ITEM_PRICE * QUANTITY 
      - (SELLER_VOUCHER_REBATE + PLATFORM_VOUCHER_SELLER_REBATE + PLATFORM_VOUCHER_SHOPEE_REBATE 
      + FREE_SHIPPING_REBATE + SHOPEE_VOUCHER_REBATE);

table_name : SDL_ECOM_BACKMARGIN
solution : Verify item price is not greater than price before discount.
snowflake query : 
SELECT *
FROM SDL_ECOM_BACKMARGIN
WHERE ITEM_PRICE > PRICE_BEFORE_DISCOUNT;
========================================================================================================================================

table_name: PROD_PRODUCT
solution: Check for missing or null values in key columns and ensure data type consistency. Remove duplicates and outliers in numeric fields.
snowflake query: 
SELECT 
    PRODUCTID, 
    PRODUCTNAME, 
    WIDTH, 
    MATERIALNUMBER, 
    MAXIMUMORDERQUANTITY 
FROM 
    PROD_PRODUCT 
WHERE 
    PRODUCTID IS NULL 
    OR PRODUCTNAME IS NULL 
    OR MATERIALNUMBER IS NULL 
    OR WIDTH < 0 
    OR MAXIMUMORDERQUANTITY < 0 
    OR LENGTH(PRODUCTID) = 0 
    OR LENGTH(PRODUCTNAME) = 0 
    OR LENGTH(MATERIALNUMBER) = 0 
    OR WIDTH IS NULL 
    OR MAXIMUMORDERQUANTITY IS NULL 
    OR PRODUCTID IN (SELECT PRODUCTID FROM PROD_PRODUCT GROUP BY PRODUCTID HAVING COUNT(*) > 1)
    OR (REGEXP_LIKE(WIDTH::STRING, '[^0-9.]') OR REGEXP_LIKE(MAXIMUMORDERQUANTITY::STRING, '[^0-9.]'));
========================================================================================================================================

table_name: SDL_ECOM_COGS
solution: Address missing data in columns by ensuring data completeness and integrity checks during data ingestion. Consider adding default values or imputation strategies for numeric fields. For text fields, ensure proper validation and preprocessing.
snowflake query: 
SELECT 
    COUNT(*) AS total_rows,
    SUM(CASE WHEN PLANT IS NULL THEN 1 ELSE 0 END) AS missing_plant,
    SUM(CASE WHEN MAT_TYPE IS NULL THEN 1 ELSE 0 END) AS missing_mat_type,
    SUM(CASE WHEN PROC_TYPE IS NULL THEN 1 ELSE 0 END) AS missing_proc_type,
    SUM(CASE WHEN PROFIT_CENTER IS NULL THEN 1 ELSE 0 END) AS missing_profit_center,
    SUM(CASE WHEN PROFIT_CENTER_DESC IS NULL THEN 1 ELSE 0 END) AS missing_profit_center_desc,
    SUM(CASE WHEN COST_RELEASE_DT IS NULL THEN 1 ELSE 0 END) AS missing_cost_release_dt,
    SUM(CASE WHEN COST_REL_YR IS NULL THEN 1 ELSE 0 END) AS missing_cost_rel_yr,
    SUM(CASE WHEN VENDOR_NO IS NULL THEN 1 ELSE 0 END) AS missing_vendor_no,
    SUM(CASE WHEN VENDOR_NAME IS NULL THEN 1 ELSE 0 END) AS missing_vendor_name,
    SUM(CASE WHEN MAT_GROUP IS NULL THEN 1 ELSE 0 END) AS missing_mat_group,
    SUM(CASE WHEN MATERIAL_GRP_DESC IS NULL THEN 1 ELSE 0 END) AS missing_material_grp_desc,
    SUM(CASE WHEN PUT_UP IS NULL THEN 1 ELSE 0 END) AS missing_put_up,
    SUM(CASE WHEN PUT_UP_DESC IS NULL THEN 1 ELSE 0 END) AS missing_put_up_desc,
    SUM(CASE WHEN TECHNOLOGY IS NULL THEN 1 ELSE 0 END) AS missing_technology,
    SUM(CASE WHEN BRAND IS NULL THEN 1 ELSE 0 END) AS missing_brand,
    SUM(CASE WHEN BRAND_DESC IS NULL THEN 1 ELSE 0 END) AS missing_brand_desc,
    SUM(CASE WHEN SITE_ID IS NULL THEN 1 ELSE 0 END) AS missing_site_id,
    SUM(CASE WHEN FRANCHISE IS NULL THEN 1 ELSE 0 END) AS missing_franchise,
    SUM(CASE WHEN FRANCHISE_DESC IS NULL THEN 1 ELSE 0 END) AS missing_franchise_desc,
    SUM(CASE WHEN BOL IS NULL THEN 1 ELSE 0 END) AS missing_bol,
    SUM(CASE WHEN MATERIAL_NO IS NULL THEN 1 ELSE 0 END) AS missing_material_no,
    SUM(CASE WHEN MATERIAL_DESC IS NULL THEN 1 ELSE 0 END) AS missing_material_desc,
    SUM(CASE WHEN UOM IS NULL THEN 1 ELSE 0 END) AS missing_uom,
    SUM(CASE WHEN BOM_QTY IS NULL THEN 1 ELSE 0 END) AS missing_bom_qty,
    SUM(CASE WHEN UOM_1 IS NULL THEN 1 ELSE 0 END) AS missing_uom_1,
    SUM(CASE WHEN SCRAP IS NULL THEN 1 ELSE 0 END) AS missing_scrap,
    SUM(CASE WHEN STD_COST IS NULL THEN 1 ELSE 0 END) AS missing_std_cost,
    SUM(CASE WHEN UNIT IS NULL THEN 1 ELSE 0 END) AS missing_unit,
    SUM(CASE WHEN CUR IS NULL THEN 1 ELSE 0 END) AS missing_cur,
    SUM(CASE WHEN COST_SIZE IS NULL THEN 1 ELSE 0 END) AS missing_cost_size,
    SUM(CASE WHEN UOM_2 IS NULL THEN 1 ELSE 0 END) AS missing_uom_2,
    SUM(CASE WHEN TOTAL_COST IS NULL THEN 1 ELSE 0 END) AS missing_total_cost,
    SUM(CASE WHEN RAW_PACK IS NULL THEN 1 ELSE 0 END) AS missing_raw_pack,
    SUM(CASE WHEN PACKAGING IS NULL THEN 1 ELSE 0 END) AS missing_packaging,
    SUM(CASE WHEN LABOUR IS NULL THEN 1 ELSE 0 END) AS missing_labour,
    SUM(CASE WHEN OH_DIRECT IS NULL THEN 1 ELSE 0 END) AS missing_oh_direct,
    SUM(CASE WHEN OH_DIR_VAR IS NULL THEN 1 ELSE 0 END) AS missing_oh_dir_var,
    SUM(CASE WHEN OH_DIR_FIX IS NULL THEN 1 ELSE 0 END) AS missing_oh_dir_fix,
    SUM(CASE WHEN OH_INDIRECT IS NULL THEN 1 ELSE 0 END) AS missing_oh_indirect,
    SUM(CASE WHEN OH_IND_VAR IS NULL THEN 1 ELSE 0 END) AS missing_oh_ind_var,
    SUM(CASE WHEN OH_IND_FIX IS NULL THEN 1 ELSE 0 END) AS missing_oh_ind_fix,
    SUM(CASE WHEN DEPRECIATION IS NULL THEN 1 ELSE 0 END) AS missing_depreciation,
    SUM(CASE WHEN SUB_CONTRACT IS NULL THEN 1 ELSE 0 END) AS missing_sub_contract,
    SUM(CASE WHEN PFG_MATERIAL IS NULL THEN 1 ELSE 0 END) AS missing_pfg_material,
    SUM(CASE WHEN FREIGHT IS NULL THEN 1 ELSE 0 END) AS missing_freight,
    SUM(CASE WHEN DUTY IS NULL THEN 1 ELSE 0 END) AS missing_duty,
    SUM(CASE WHEN OTHER_PFG IS NULL THEN 1 ELSE 0 END) AS missing_other_pfg,
    SUM(CASE WHEN OH_SUBCONTR IS NULL THEN 1 ELSE 0 END) AS missing_oh_subcontr,
    SUM(CASE WHEN OH_PFG IS NULL THEN 1 ELSE 0 END) AS missing_oh_pfg,
    SUM(CASE WHEN PROMOT_COST IS NULL THEN 1 ELSE 0 END) AS missing_promot_cost,
    SUM(CASE WHEN PROMOT_SUBC IS NULL THEN 1 ELSE 0 END) AS missing_promot_subc,
    SUM(CASE WHEN TOLL_FEE_MK_UP IS NULL THEN 1 ELSE 0 END) AS missing_toll_fee_mk_up,
    SUM(CASE WHEN IC_MARK_UP IS NULL THEN 1 ELSE 0 END) AS missing_ic_mark_up,
    SUM(CASE WHEN OTHER_OH IS NULL THEN 1 ELSE 0 END) AS missing_other_oh,
    SUM(CASE WHEN OTHER_OH_VAR IS NULL THEN 1 ELSE 0 END) AS missing_other_oh_var,
    SUM(CASE WHEN OTHER_OH_FIX IS NULL THEN 1 ELSE 0 END) AS missing_other_oh_fix,
    SUM(CASE WHEN FINAL_COST IS NULL THEN 1 ELSE 0 END) AS missing_final_cost,
    SUM(CASE WHEN PER_PIECE IS NULL THEN 1 ELSE 0 END) AS missing_per_piece,
    SUM(CASE WHEN PER_DOZEN IS NULL THEN 1 ELSE 0 END) AS missing_per_dozen,
    SUM(CASE WHEN CRTD_DTTM IS NULL THEN 1 ELSE 0 END) AS missing_crtd_dttm,
    SUM(CASE WHEN FILENAME IS NULL THEN 1 ELSE 0 END) AS missing_filename
FROM 
    SDL_ECOM_COGS;
========================================================================================================================================

Certainly! Here is the structured solution based on the anomalies identified in the provided sample data:


table_name: SDL_CLAVIS_GB_SEARCH_TERMS_RESULTS
solution: 
- Ensure `search_results_rank`, `search_results_basic_score`, `search_results_weighted_score`, and `search_results_priority_score` are non-negative. Negative values are anomalous.
- Verify that `ext_page_no` is non-negative since page numbers should not be negative.
- Check that `is_competitor` and `is_priority_search_term` have valid categorical values.
- Confirm that `search_results_max_rank` is greater than or equal to zero.
snowflake query:
SELECT *
FROM SDL_CLAVIS_GB_SEARCH_TERMS_RESULTS
WHERE search_results_rank < 0
   OR search_results_basic_score < 0
   OR search_results_weighted_score < 0
   OR search_results_priority_score < 0
   OR ext_page_no < 0
   OR search_results_max_rank < 0
   OR is_competitor NOT IN ('yes', 'no', 'unknown') -- Assuming valid values
   OR is_priority_search_term NOT IN ('yes', 'no', 'unknown'); -- Assuming valid values


This SQL query is designed to identify the anomalies based on the conditions specified and is structured to be compatible with Snowflake's SQL syntax.
========================================================================================================================================

table_name: MRCHR_RESPONSES
solution: 
- Ensure all numeric fields contain only valid positive or zero values where applicable.
- Verify data consistency for categorical fields.
- Correct negative or invalid values for fields such as `stockcount`, `categorylength`, `categoryfacings`, etc.
- Implement validation checks during data ingestion to prevent future anomalies.

snowflake query: 
SELECT 
    * 
FROM 
    MRCHR_RESPONSES 
WHERE 
    stockcount < 0 
    OR categorylength < 0 
    OR categoryfacings < 0 
    OR pricedetails < 0 
    OR (presence NOT IN ('Yes', 'No')) 
    OR (mustcarryitem NOT IN ('Yes', 'No')) 
    OR (outofstock NOT IN ('Yes', 'No')) 
    OR (pricepresence NOT IN ('Yes', 'No')) 
    OR (promopresence NOT IN ('Yes', 'No')) 
    OR (promopackpresence NOT IN ('Yes', 'No'));
========================================================================================================================================

table_name: SDL_MDS_PH_DISTRIBUTOR_PRODUCT  
solution: Detecting anomalies in the `PROMOENDPERIOD` and `PROMOSTARTPERIOD` where the end period is before the start period. Anomaly in `VALIDATIONSTATUS` where it is not 'valid' or 'invalid'.  
snowflake_query:  
sql  
SELECT *  
FROM SDL_MDS_PH_DISTRIBUTOR_PRODUCT  
WHERE PROMOENDPERIOD < PROMOSTARTPERIOD  
   OR VALIDATIONSTATUS NOT IN ('valid', 'invalid');
========================================================================================================================================

table_name: SDL_DSTR_WOOLWORTH_INV
solution: The data contains several anomalies, such as negative values for fields that should only have positive values (e.g., 'lt', 'soh_oms', 'demand_oms', 'total_wholesale_demand_om'). Missing values (e.g., 'articledesc', 'oos_comments') and logically inconsistent values (e.g., 'sl_perc' being negative) are also evident. To address these, implement data validation rules and default values for missing data.

snowflake query: 
SELECT *
FROM SDL_DSTR_WOOLWORTH_INV
WHERE 
    CAST(lt AS FLOAT) < 0 OR
    CAST(soh_oms AS FLOAT) < 0 OR
    CAST(demand_oms AS FLOAT) < 0 OR
    CAST(total_wholesale_demand_om AS FLOAT) < 0 OR
    sl_perc IS NULL OR
    articledesc IS NULL OR
    oos_comments IS NULL;
========================================================================================================================================

table_name : SDL_MDS_PH_CLOBOTICS_SOS_REF
solution : Detect rows with same 'MUID' and 'VERSION_ID' but different 'VERSIONNUMBER' indicating potential versioning inconsistency.
snowflake query : 
SELECT * 
FROM SDL_MDS_PH_CLOBOTICS_SOS_REF 
WHERE (MUID, VERSION_ID) IN (
    SELECT MUID, VERSION_ID 
    FROM SDL_MDS_PH_CLOBOTICS_SOS_REF 
    GROUP BY MUID, VERSION_ID 
    HAVING COUNT(DISTINCT VERSIONNUMBER) > 1
);



table_name : SDL_MDS_PH_CLOBOTICS_SOS_REF
solution : Identify entries with 'VERSIONFLAG' as 'Inactive' yet having 'VALIDATIONSTATUS' as 'Invalid', which might indicate a need for re-evaluation or update.
snowflake query : 
SELECT * 
FROM SDL_MDS_PH_CLOBOTICS_SOS_REF 
WHERE VERSIONFLAG = 'Inactive' AND VALIDATIONSTATUS = 'Invalid';



table_name : SDL_MDS_PH_CLOBOTICS_SOS_REF
solution : Find entries where 'ENTERDATETIME' is after 'LASTCHGDATETIME', which can indicate incorrect timestamps.
snowflake query : 
SELECT * 
FROM SDL_MDS_PH_CLOBOTICS_SOS_REF 
WHERE ENTERDATETIME > LASTCHGDATETIME;



table_name : SDL_MDS_PH_CLOBOTICS_SOS_REF
solution : Check for entries with 'CHANGETRACKINGMASK' values that seem inconsistent or misaligned (e.g., unexpected value patterns).
snowflake query : 
SELECT * 
FROM SDL_MDS_PH_CLOBOTICS_SOS_REF 
WHERE CHANGETRACKINGMASK NOT IN (0, 1, 2);  -- Assuming known valid values are 0, 1, 2.
========================================================================================================================================

table_name: SDL_MDS_PH_GT_CUSTOMER
solution: Detect missing or null values in critical columns and identify outliers or inconsistencies in data.
snowflake query: 
SELECT 
    COUNT(*) AS total_records,
    COUNT(CASE WHEN id IS NULL THEN 1 END) AS missing_id,
    COUNT(CASE WHEN muid IS NULL THEN 1 END) AS missing_muid,
    COUNT(CASE WHEN versionname IS NULL THEN 1 END) AS missing_versionname,
    COUNT(CASE WHEN name IS NULL THEN 1 END) AS missing_name,
    COUNT(CASE WHEN code IS NULL THEN 1 END) AS missing_code,
    COUNT(CASE WHEN latitude IS NULL OR latitude NOT BETWEEN -90 AND 90 THEN 1 END) AS invalid_latitude,
    COUNT(CASE WHEN longitude IS NULL OR longitude NOT BETWEEN -180 AND 180 THEN 1 END) AS invalid_longitude,
    COUNT(CASE WHEN status NOT IN ('Active', 'Inactive') THEN 1 END) AS invalid_status
FROM SDL_MDS_PH_GT_CUSTOMER;


This query checks for missing or null values in critical columns like `id`, `muid`, `versionname`, `name`, and `code`. It also checks for invalid latitude and longitude values and invalid entries in the `status` column. The solution aims to identify data quality issues that need to be addressed to ensure data integrity.
========================================================================================================================================

table_name: SDL_LA_GT_ROUTE_DETAIL_TEMP
solution: Identify and address the following anomalies: missing values, duplicate records, incorrect data types, and inconsistent data. Ensure data consistency and accuracy.

snowflake query:
-- Detecting missing values
SELECT *
FROM SDL_LA_GT_ROUTE_DETAIL_TEMP
WHERE FILE_UPLOAD_DATE IS NULL
   OR SHIP_TO IS NULL
   OR CONTACT_PERSON IS NULL
   OR ROUTE_NO IS NULL
   OR SALEUNIT IS NULL
   OR RUN_ID IS NULL
   OR ROUTE_ID IS NULL
   OR CRT_DTTM IS NULL
   OR CUSTOMER_ID IS NULL
   OR FILENAME IS NULL
   OR HASHKEY IS NULL
   OR CREATED_DATE IS NULL;

-- Detecting duplicate records based on unique identifiers (e.g., HASHKEY)
SELECT HASHKEY, COUNT(*)
FROM SDL_LA_GT_ROUTE_DETAIL_TEMP
GROUP BY HASHKEY
HAVING COUNT(*) > 1;

-- Detecting incorrect data types, if applicable
-- Assuming all data types are correctly defined in the schema, this step may be checked manually.

-- Detecting inconsistent data (e.g., mismatched ROUTE_NO and ROUTE_ID)
SELECT *
FROM SDL_LA_GT_ROUTE_DETAIL_TEMP
WHERE ROUTE_NO NOT IN (SELECT DISTINCT ROUTE_NO FROM SDL_LA_GT_ROUTE_DETAIL_TEMP WHERE ROUTE_ID = ROUTE_ID);

-- Ensure data consistency and accuracy checks
-- Example: Check if CREATED_DATE is always greater than FILE_UPLOAD_DATE
SELECT *
FROM SDL_LA_GT_ROUTE_DETAIL_TEMP
WHERE CREATED_DATE < FILE_UPLOAD_DATE;
========================================================================================================================================

sql
table_name: SDL_MDS_PH_POS_PRICELIST
solution: Check for mismatches between status_code and status_name, and versionflag inconsistencies. Validate price consistency.
snowflake query: 
SELECT 
    *,
    CASE 
        WHEN (status_code = 'I' AND status_name <> 'Inactive') OR (status_code = 'A' AND status_name <> 'Active') THEN 'Status mismatch'
        ELSE NULL
    END AS status_anomaly,
    CASE 
        WHEN (versionflag = 'active' AND status_code = 'I') OR (versionflag = 'inactive' AND status_code = 'A') THEN 'Version flag inconsistency'
        ELSE NULL
    END AS version_flag_anomaly,
    CASE 
        WHEN listpricedz * dzpercase::NUMBER <> listpricecase THEN 'Price inconsistency'
        ELSE NULL
    END AS price_anomaly
FROM SDL_MDS_PH_POS_PRICELIST
WHERE 
    (status_code = 'I' AND status_name <> 'Inactive') OR 
    (status_code = 'A' AND status_name <> 'Active') OR 
    (versionflag = 'active' AND status_code = 'I') OR 
    (versionflag = 'inactive' AND status_code = 'A') OR 
    (listpricedz * dzpercase::NUMBER <> listpricecase);
========================================================================================================================================

table_name: SDL_ALL_DISTRIBUTOR_SELLOUT_SALES_FACT
solution: Address negative values in sales and gross values as they indicate potential data entry errors. Correct or validate these values with source data.
snowflake_query: 
SELECT *
FROM SDL_ALL_DISTRIBUTOR_SELLOUT_SALES_FACT
WHERE sls_qty < 0 OR grs_val < 0;
========================================================================================================================================

table_name: SDL_AU_DSTR_CHS_HEADER
solution: Detect numerical columns with TEXT data type and convert them to appropriate numerical types. Identify inconsistent data such as negative inventory values and fix them.
snowflake query: 
-- Detect columns with TEXT data type that should be numerical
SELECT 
  column_name, 
  data_type 
FROM 
  information_schema.columns 
WHERE 
  table_name = 'SDL_AU_DSTR_CHS_HEADER' 
  AND data_type = 'TEXT';

-- Identify negative inventory values
SELECT 
  * 
FROM 
  SDL_AU_DSTR_CHS_HEADER 
WHERE 
  TRY_TO_NUMBER(SOH_QTY) < 0 
  OR TRY_TO_NUMBER(SOH_AMT) < 0 
  OR TRY_TO_NUMBER(SOO_QTY) < 0 
  OR TRY_TO_NUMBER(SOO_AMT) < 0;

-- Detect discrepancies between SOH_QTY and SOO_QTY
SELECT 
  * 
FROM 
  SDL_AU_DSTR_CHS_HEADER 
WHERE 
  TRY_TO_NUMBER(SOH_QTY) < TRY_TO_NUMBER(SOO_QTY);
========================================================================================================================================

table_name: SDL_AU_DSTR_API_HEADER
solution: Detect negative quantities, especially in 'dc_soo_qty' and 'so_backorder_qty', and ensure all required fields are populated. Update or alert when anomalies are found.
snowflake query: 
SELECT *
FROM SDL_AU_DSTR_API_HEADER
WHERE dc_soo_qty < 0
   OR so_backorder_qty < 0
   OR NULL_COLOUMN IS NULL;
========================================================================================================================================

table_name: SDL_CSL_ORDERBOOKING
solution: To identify anomalies such as negative product selling rates, non-matching order and delivery dates, and missing product codes, perform data validation and implement data quality checks. Consider setting constraints or rules to prevent such anomalies in the future.
snowflake query: 
SELECT 
  ORDERNO, 
  PRDSELRATE, 
  ORDERDATE, 
  ORDDLVDATE, 
  PRDCODE, 
  ALLOWBACKORDER, 
  ORDPRIORITY 
FROM 
  SDL_CSL_ORDERBOOKING 
WHERE 
  PRDSELRATE < 0 
  OR ORDERDATE > ORDDLVDATE 
  OR PRDCODE IS NULL;
========================================================================================================================================

table_name : SDL_KR_COUPANG_BPA_REPORT
solution : 
1. Set click_count and ctr to always be non-negative as these represent count and percentages.
2. Implement a validation rule to check for negative values in columns that should be positive.
3. Ensure data consistency by adding constraints or using data validation checks during data entry.

snowflake query : 
SELECT 
    *
FROM 
    SDL_KR_COUPANG_BPA_REPORT
WHERE 
    TRY_CAST(click_count AS INTEGER) < 0
    OR TRY_CAST(ctr AS FLOAT) < 0;
========================================================================================================================================

table_name : SDL_MDS_VN_POS_PRODUCTS
solution : Check for NULL values in columns that should not have them, such as 'code'. Ensure that 'versionnumber', 'version_id', 'changetrackingmask', 'enterversionnumber', and 'lastchgversionnumber' are consistent across the rows. Validate that 'enterdatetime' and 'lastchgdatetime' are correct and follow the expected sequence.
snowflake query : 
SELECT *
FROM SDL_MDS_VN_POS_PRODUCTS
WHERE code IS NULL
   OR versionnumber != version_id
   OR versionnumber != changetrackingmask
   OR versionnumber != enterversionnumber
   OR versionnumber != lastchgversionnumber
   OR enterdatetime >= lastchgdatetime;
========================================================================================================================================

table_name : SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN
solution : Detect anomalies like missing or duplicate values in key columns, and validate data types.
snowflake query : 
    -- Check for missing values in key columns
    SELECT 
        COUNT(*) AS missing_sls_rep_cd_nm
    FROM 
        SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN 
    WHERE 
        SLS_REP_CD_NM IS NULL
    UNION ALL
    SELECT 
        COUNT(*) AS missing_store_cd
    FROM 
        SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN 
    WHERE 
        STORE_CD IS NULL;

    -- Check for duplicate entries based on SL_NO
    SELECT 
        SL_NO, COUNT(*) AS duplicate_count
    FROM 
        SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN 
    GROUP BY 
        SL_NO
    HAVING 
        COUNT(*) > 1;

    -- Validate data types (e.g., ensuring NUMBER fields have numeric values)
    SELECT 
        COUNT(*) AS invalid_week
    FROM 
        SDL_HK_WINGKEUNG_DIRECT_SALES_REP_ROUTE_PLAN 
    WHERE 
        TRY_CAST(WEEK AS NUMBER) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_MY_TARGETS
solution: 
1. Identify missing or null values in critical columns to ensure data completeness.
2. Detect duplicate rows based on unique identifiers to maintain data integrity.
3. Check for out-of-range or unexpected values in numeric columns to ensure data validity.

snowflake query: 
-- Query to find rows with NULL values in critical columns
SELECT *
FROM SDL_MDS_MY_TARGETS
WHERE id IS NULL 
   OR muid IS NULL 
   OR versionname IS NULL 
   OR year_code IS NULL 
   OR type_code IS NULL;

-- Query to find duplicate rows based on 'id'
SELECT id, COUNT(*)
FROM SDL_MDS_MY_TARGETS
GROUP BY id
HAVING COUNT(*) > 1;

-- Query to check for out-of-range values (Assuming valid range for 'jan' to 'dec' is 0 to 100)
SELECT *
FROM SDL_MDS_MY_TARGETS
WHERE jan < 0 OR jan > 100
   OR feb < 0 OR feb > 100
   OR mar < 0 OR mar > 100
   OR apr < 0 OR apr > 100
   OR may < 0 OR may > 100
   OR jun < 0 OR jun > 100
   OR jul < 0 OR jul > 100
   OR aug < 0 OR aug > 100
   OR sep < 0 OR sep > 100
   OR oct < 0 OR oct > 100
   OR nov < 0 OR nov > 100
   OR dec < 0 OR dec > 100;
========================================================================================================================================

table_name: SDL_LA_GT_ROUTE_HEADER
solution: Identify rows with NULL or inconsistent data types that may indicate anomalies. Focus on ensuring 'IS_ACTIVE' contains consistent and valid values, check for non-NULL 'ROUTE_ID', and ensure 'FILE_UPLOAD_DATE' and 'LAST_UPDATED_DATE' are valid dates.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_LA_GT_ROUTE_HEADER 
WHERE 
    IS_ACTIVE NOT IN ('Y', 'N') OR 
    ROUTE_ID IS NULL OR 
    FILE_UPLOAD_DATE IS NULL OR 
    TRY_TO_DATE(FILE_UPLOAD_DATE::TEXT, 'YYYY-MM-DD') IS NULL OR 
    TRY_TO_DATE(LAST_UPDATED_DATE::TEXT, 'YYYY-MM-DD') IS NULL;
========================================================================================================================================

table_name: SDL_ID_POS_DAILY_IDM_SELLOUT
solution: 
1. Detect negative or zero sales values, which are suspicious in a sales dataset.
2. Check for missing or inconsistent data entries, such as missing branch names or invalid PLU codes.
3. Identify duplicate entries based on a combination of key fields like account, kode_branch, tgl, and plu.

snowflake query: 
WITH Anomalies AS (
    SELECT 
        account, kode_branch, branch_name, tgl, plu, descp, type, value, pos_cust, yearmonth, run_id, crtd_dttm, filename
    FROM SDL_ID_POS_DAILY_IDM_SELLOUT
    WHERE value <= 0
    OR branch_name IS NULL
    OR plu IS NULL
    OR (account, kode_branch, tgl, plu) IN (
        SELECT account, kode_branch, tgl, plu
        FROM SDL_ID_POS_DAILY_IDM_SELLOUT
        GROUP BY account, kode_branch, tgl, plu
        HAVING COUNT(*) > 1
    )
)
SELECT * FROM Anomalies;
========================================================================================================================================

table_name: SDL_MDS_VN_POS_CUSTOMERS
solution: Detect inconsistencies in status and versionflag, null values in customer_name, and closed stores with active status.
snowflake_query: 
SELECT 
    ID, 
    STATUS, 
    VERSIONFLAG, 
    CUSTOMER_NAME, 
    NOTE_CLOSED_STORE 
FROM 
    SDL_MDS_VN_POS_CUSTOMERS 
WHERE 
    (STATUS = 'Active' AND VERSIONFLAG = 'inactive') 
    OR CUSTOMER_NAME IS NULL 
    OR (STATUS = 'Active' AND NOTE_CLOSED_STORE = 'Closed');
========================================================================================================================================

table_name: SDL_MDS_VN_PRICE_PRODUCTS
solution: Identify anomalies such as NULL values in critical columns and inconsistent data entries like duplicate IDs or unexpected data ranges. Recommend data validation rules and data cleansing for consistent data integrity and accuracy.
snowflake query: 
SELECT 
  id,
  muid,
  versionname,
  versionnumber,
  version_id,
  versionflag,
  name,
  code,
  changetrackingmask,
  jnj_sap_code,
  franchise,
  brand,
  sku,
  bar_code,
  pc_per_case,
  price,
  product_id_concung,
  enterdatetime,
  enterusername,
  enterversionnumber,
  lastchgdatetime,
  lastchgusername,
  lastchgversionnumber,
  validationstatus
FROM SDL_MDS_VN_PRICE_PRODUCTS
WHERE 
  id IS NULL OR
  muid IS NULL OR
  versionname IS NULL OR
  versionnumber IS NULL OR
  price IS NULL OR
  price < 0 OR
  pc_per_case <= 0 OR
  validationstatus != 'Valid' OR
  (SELECT COUNT(*) FROM SDL_MDS_VN_PRICE_PRODUCTS GROUP BY id HAVING COUNT(id) > 1) > 0;
========================================================================================================================================

table_name : SDL_MDS_PACIFIC_PRODUCT_MAPPING_COLES  
solution : Check for duplicate IDs and ensure referential integrity for version numbers.  
snowflake query :  
SELECT  
    id, COUNT(*) AS count  
FROM  
    SDL_MDS_PACIFIC_PRODUCT_MAPPING_COLES  
GROUP BY  
    id  
HAVING  
    COUNT(*) > 1;  

SELECT  
    versionnumber  
FROM  
    SDL_MDS_PACIFIC_PRODUCT_MAPPING_COLES  
WHERE  
    versionnumber NOT IN (SELECT DISTINCT version_id FROM SDL_MDS_PACIFIC_PRODUCT_MAPPING_COLES);
========================================================================================================================================

table_name: SDL_MDS_MY_ECOM_PRODUCT
solution: 
1. Negative version numbers are unexpected; ensure versioning logic is correct.
2. Null values in primary keys or unique identifiers like 'muid' should be avoided; ensure data integrity.
3. Duplicate records in 'id' or 'code' may indicate data consistency issues; implement unique constraints.
4. Ensure 'lastchgdatetime' is always greater than 'enterdatetime' for valid chronological order.

snowflake query: 
SELECT 
    id, 
    muid, 
    versionnumber, 
    code, 
    enterusername, 
    enterdatetime, 
    lastchgdatetime 
FROM 
    SDL_MDS_MY_ECOM_PRODUCT 
WHERE 
    versionnumber < 0
    OR muid IS NULL 
    OR id IN (SELECT id FROM SDL_MDS_MY_ECOM_PRODUCT GROUP BY id HAVING COUNT(*) > 1)
    OR code IN (SELECT code FROM SDL_MDS_MY_ECOM_PRODUCT GROUP BY code HAVING COUNT(*) > 1)
    OR lastchgdatetime <= enterdatetime;
========================================================================================================================================

table_name: SDL_MDS_SG_ECOM_PRODUCT
solution: Identify records with invalid data or inconsistencies, such as inactive products with valid status, version inconsistencies, and missing mandatory fields. Validate UPC format and check for duplicate SKUs.
snowflake_query: 
SELECT *
FROM SDL_MDS_SG_ECOM_PRODUCT
WHERE 
    (versionflag = 'inactive' AND validationstatus = 'valid') OR
    (versionnumber != enterversionnumber AND version_id != lastchgversionnumber) OR
    (name IS NULL OR code IS NULL OR sku_name IS NULL OR upc IS NULL) OR
    (NOT REGEXP_LIKE(upc, '^\d{13}$')) OR
    (sku_name IN (SELECT sku_name FROM SDL_MDS_SG_ECOM_PRODUCT GROUP BY sku_name HAVING COUNT(*) > 1));
========================================================================================================================================

table_name: SDL_MY_CUSTOMER_DIM
solution: The anomalies present include negative values in 'ullage' and 'trdng_term_val', potentially incorrect 'cdl_dttm' status values, and text data types where numeric types might be more appropriate. Implement data validation checks, correct data types, and implement constraints.
snowflake query: 
SELECT 
  CUST_ID, 
  CUST_NM, 
  DSTRBTR_GRP_CD, 
  DSTRBTR_GRP_NM, 
  ULLAGE, 
  CHNL, 
  TERRITORY, 
  RETAIL_ENV, 
  TRDNG_TERM_VAL, 
  RDD_IND, 
  CDL_DTTM, 
  CURR_DT, 
  FILE_NAME 
FROM SDL_MY_CUSTOMER_DIM
WHERE 
  TRY_TO_NUMBER(ULLAGE) < 0 
  OR TRY_TO_NUMBER(TRDNG_TERM_VAL) < 0 
  OR CDL_DTTM NOT IN ('Active', 'Pending', 'Inactive');
========================================================================================================================================

table_name: SDL_MY_AFGR
solution: 
- Ensure all monetary values are positive or provide context for negative values. 
- Validate date consistency and ensure all required fields are populated.
- Address invalid SC validation status.
snowflake query: 
SELECT * FROM SDL_MY_AFGR
WHERE 
  TRY_TO_NUMBER(CN_AMT) < 0 OR
  TRY_TO_NUMBER(DN_AMT_EXC_GST_VAL) < 0 OR
  TRY_TO_NUMBER(AFGR_AMT) < 0 OR
  TRY_TO_NUMBER(RTN_ORD_AMT) < 0 OR
  SC_VALIDATION = 'Invalid' OR
  RTN_ORD_DT IS NULL OR
  (TRY_TO_TIMESTAMP_NTZ(BILL_DT) IS NULL OR 
   TRY_TO_TIMESTAMP_NTZ(CN_EXP_ISSUE_DT) IS NULL OR 
   TRY_TO_TIMESTAMP_NTZ(DT_TO_SC) IS NULL OR
   TRY_TO_TIMESTAMP_NTZ(CDL_DTTM) IS NULL);
========================================================================================================================================

table_name: ITG_SFA_PM
solution: Several anomalies were identified in the data such as missing values in important columns and potentially invalid file names and paths. The solution involves creating a query to detect these anomalies: missing customer names, missing brands, and invalid file paths.
snowflake query: 
SELECT 
    taskid,
    filename,
    path,
    brand,
    mrchr_visitdate,
    customerid,
    remotekey,
    customername,
    salesgroup,
    storetype,
    dist_chnl,
    country,
    salescyclename,
    salescampaignname,
    mastertaskname,
    salesperson_firstname,
    salesperson_lastname,
    secondarytradecode,
    secondarytradename
FROM 
    ITG_SFA_PM
WHERE 
    brand IS NULL OR
    customername IS NULL OR
    path LIKE '/invalid/%';
========================================================================================================================================

table_name: SDL_AU_DSTR_SIGMA_HEADER  
solution: Identify and handle negative values in columns that should logically have only positive values (e.g., quantities and amounts). Implement data validation to prevent negative values and correct existing data where necessary.  
snowflake query:  
SELECT *  
FROM SDL_AU_DSTR_SIGMA_HEADER  
WHERE CAST(SOH_QTY AS INTEGER) < 0  
   OR CAST(SOH_AMT AS INTEGER) < 0  
   OR CAST(STOCK_IN_TRANSIT_QTY AS INTEGER) < 0  
   OR CAST(STOCK_IN_TRANSIT_AMT AS INTEGER) < 0  
   OR CAST(RESTRICTED_STOCK_QTY AS INTEGER) < 0  
   OR CAST(RESTRICTED_STOCK_AMT AS INTEGER) < 0  
   OR CAST(SOO_QTY AS INTEGER) < 0  
   OR CAST(SOO_AMT AS INTEGER) < 0  
   OR CAST(BACK_ORDER_QTY AS INTEGER) < 0  
   OR CAST(BACK_ORDER_AMT AS INTEGER) < 0;
========================================================================================================================================

table_name: SDL_HK_WINGKEUNG_INDIRECT_SALES_REP_ROUTE_PLAN
solution: Detect anomalies by checking for inconsistent store class, abnormal visit frequencies, and duplicate store-representative mappings. Recommend maintaining data integrity by enforcing constraints on store class and visit frequency.
snowflake_query: 
SELECT 
    STORE_CD, 
    SLS_REP_NM, 
    SLS_REP_CD, 
    STORE_CLASS, 
    VISIT_FREQ, 
    COUNT(*) OVER (PARTITION BY STORE_CD, SLS_REP_CD) AS DUPLICATE_COUNT
FROM SDL_HK_WINGKEUNG_INDIRECT_SALES_REP_ROUTE_PLAN
WHERE 
    STORE_CLASS NOT IN ('J', 'R', 'W', 'X') OR
    VISIT_FREQ < 0 OR
    DUPLICATE_COUNT > 1;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_OUTLET_MASTER_ADFTEMP
solution: Detect anomalies such as missing or incorrectly formatted geographical data (latitude and longitude), check for missing primary identifiers like OUTLETCODE or USERCODE, and validate numerical constraints on CREDIT_LIMIT, INVOICE_LIMIT, and CREDIT_PERIOD.
snowflake query: 
SELECT 
    OUTLETCODE, 
    USERCODE, 
    LOCATIONCODE, 
    OUTLETNAME, 
    OUTLETADDRESS, 
    PINCODE, 
    CHANNELCODE, 
    CHANNELNAME, 
    SUBCHANNELCODE, 
    SUBCHANNELNAME, 
    TIERINGCODE, 
    TIERINGNAME, 
    CLASSCODE, 
    ROUTECODE, 
    VISIT_FREQUENCY, 
    VISITDAY, 
    JNJ_ID, 
    CONTACTPERSON, 
    CREDIT_LIMIT, 
    INVOICE_LIMIT, 
    CREDIT_PERIOD, 
    TIN, 
    IS_DIAMOND_STORE, 
    ID_NO, 
    MASTER_CODE, 
    STORE_CLUSTER, 
    LATTITUDE, 
    LONGITUDE, 
    CDL_DTTM, 
    RUN_ID, 
    FILE_NAME 
FROM SDL_DISTRIBUTOR_IVY_OUTLET_MASTER_ADFTEMP 
WHERE 
    OUTLETCODE IS NULL 
    OR USERCODE IS NULL 
    OR LATTITUDE NOT SIMILAR TO '^[+-]?\d{1,2}\.\d{1,6}$' 
    OR LONGITUDE NOT SIMILAR TO '^[+-]?\d{1,3}\.\d{1,6}$' 
    OR CREDIT_LIMIT < 0 
    OR INVOICE_LIMIT < 0 
    OR CREDIT_PERIOD < 0 
    OR (IS_DIAMOND_STORE IS NOT NULL AND IS_DIAMOND_STORE NOT IN ('Y', 'N'));
========================================================================================================================================

table_name: SDL_MDS_PH_ECOM_PRODUCT
solution: Check for negative IDs, inconsistent version flags, and validation status mismatches. Ensure ID is positive, version flags are consistent, and validation statuses match expected values. 
snowflake query: 
SELECT * 
FROM SDL_MDS_PH_ECOM_PRODUCT 
WHERE id < 0 
   OR (versionflag = 'inactive' AND validationstatus = 'valid') 
   OR enterversionnumber <> lastchgversionnumber 
   OR (enterdatetime > lastchgdatetime);
========================================================================================================================================

sql
table_name: SDL_POP6_SG_POPS
solution: The table contains anomalies in latitude, longitude, and status. Latitude and longitude values are outside valid ranges (-90 to 90 for latitude and -180 to 180 for longitude). Status values are negative, which might not be expected.

snowflake query: 
SELECT * 
FROM SDL_POP6_SG_POPS 
WHERE (LATITUDE < -90 OR LATITUDE > 90) 
   OR (LONGITUDE < -180 OR LONGITUDE > 180) 
   OR STATUS < 0;
========================================================================================================================================

table_name : PRODTR_PRODUCTTRANSLATION
solution : Detect anomalies where there are NULL values in critical columns like 'PRODUCTID' or 'PRODUCTTRANSLATIONNAME', and ensure 'fetcheddatetime' matches 'azuredatetime' and 'cdl_datetime'.
snowflake query : 
SELECT * 
FROM PRODTR_PRODUCTTRANSLATION
WHERE PRODUCTID IS NULL 
   OR PRODUCTTRANSLATIONNAME IS NULL 
   OR fetcheddatetime != azuredatetime 
   OR fetcheddatetime != cdl_datetime;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_ORDER
solution: Detect and address negative quantities, ensure order consistency, and validate discount logic.
snowflake query: 
SELECT 
    order_id, 
    qty, 
    order_value, 
    line_value, 
    scheme_discount, 
    scheme_precentage, 
    billdiscount, 
    billdisc_percentage 
FROM 
    SDL_DISTRIBUTOR_IVY_ORDER
WHERE 
    qty < 0 OR 
    line_value < 0 OR 
    order_value < 0 OR 
    scheme_discount < 0 OR 
    scheme_precentage < 0 OR 
    billdiscount < 0 OR 
    billdisc_percentage < 0 OR
    order_value != line_value + scheme_discount + billdiscount;


This query identifies anomalies such as negative quantities or values, and discrepancies in calculated order values compared to line values and discounts. The solution involves detecting these anomalies for corrective measures.
========================================================================================================================================

sql
table_name: SDL_LA_GT_SALES_ORDER_FACT_TEMP
solution: Identify missing or incomplete data, duplicates, and inconsistent data types. Ensure all expected data is populated, check for duplicate records, and verify data types are consistent with schema definitions.
snowflake query: 
SELECT 
    *
FROM 
    SDL_LA_GT_SALES_ORDER_FACT_TEMP
WHERE 
    (hashkey IS NULL OR saleunit IS NULL OR orderid IS NULL OR orderdate IS NULL OR customer_id IS NULL OR customer_name IS NULL OR city IS NULL OR region IS NULL OR saledistrict IS NULL OR saleoffice IS NULL OR salegroup IS NULL OR customertype IS NULL OR storetype IS NULL OR saletype IS NULL OR salesemployee IS NULL OR salename IS NULL OR productid IS NULL OR productname IS NULL OR megabrand IS NULL OR brand IS NULL OR baseproduct IS NULL OR variant IS NULL OR putup IS NULL OR priceref IS NULL OR backlog IS NULL OR qty IS NULL OR subamt1 IS NULL OR discount IS NULL OR subamt2 IS NULL OR discountbtline IS NULL OR totalbeforevat IS NULL OR total IS NULL OR sales_order_line_no IS NULL OR canceled IS NULL OR documentid IS NULL OR return_reason IS NULL OR promotioncode IS NULL OR promotioncode1 IS NULL OR promotioncode2 IS NULL OR promotioncode3 IS NULL OR promotioncode4 IS NULL OR promotioncode5 IS NULL OR promotion_code IS NULL OR promotion_code2 IS NULL OR promotion_code3 IS NULL OR avgdiscount IS NULL OR ordertype IS NULL OR approverstatus IS NULL OR pricelevel IS NULL OR optional3 IS NULL OR deliverydate IS NULL OR ordertime IS NULL OR shipto IS NULL OR billto IS NULL OR deliveryrouteid IS NULL OR approved_date IS NULL OR approved_time IS NULL OR ref_15 IS NULL OR paymenttype IS NULL OR filename IS NULL OR run_id IS NULL OR crt_dttm IS NULL OR updt_dttm IS NULL)
    OR
    EXISTS (
        SELECT 
            hashkey, COUNT(*) 
        FROM 
            SDL_LA_GT_SALES_ORDER_FACT_TEMP
        GROUP BY 
            hashkey
        HAVING 
            COUNT(*) > 1
    )
    OR
    EXISTS (
        SELECT 
            *
        FROM 
            SDL_LA_GT_SALES_ORDER_FACT_TEMP
        WHERE 
            NOT (CAST(orderdate AS TEXT) LIKE '%-%-%')
            OR NOT (CAST(deliverydate AS TEXT) LIKE '%-%-%')
            OR NOT (CAST(approved_date AS TEXT) LIKE '%-%-%')
    );
========================================================================================================================================

table_name: SDL_MDS_PH_ISE_WEIGHTS
solution: Identify negative and zero weights, inactive version flags with valid status, and mismatched timestamps. Ensure weight is positive, statuses align, and timestamps are properly updated.
snowflake query: 
SELECT 
    *
FROM 
    SDL_MDS_PH_ISE_WEIGHTS
WHERE 
    WEIGHT <= 0
    OR (VERSIONFLAG = 'inactive' AND VALIDATIONSTATUS = 'valid')
    OR ENTERDATETIME >= LASTCHGDATETIME;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_INVENTORY
solution: 
- Ensure no duplicate distributor codes unless intentional; add unique constraints or checks.
- Validate and correct negative quantities, possibly by implementing checks or business rules.
- Adjust batch expiry dates to ensure they are not in the past unless intended for historical data.
- Regularly audit data entries for accuracy.
snowflake query: 
SELECT DISTINCT
    distributor_code,
    warehouse_code,
    product_code,
    batch_code,
    batch_expiry_date,
    uom,
    qty,
    cdl_dttm,
    run_id,
    file_name
FROM SDL_DISTRIBUTOR_IVY_INVENTORY
WHERE 
    distributor_code IN (SELECT distributor_code FROM SDL_DISTRIBUTOR_IVY_INVENTORY GROUP BY distributor_code HAVING COUNT(*) > 1)
    OR qty < 0
    OR TRY_TO_DATE(batch_expiry_date, 'YYYY-MM-DD') < CURRENT_DATE;
========================================================================================================================================

sql
table_name : SDL_POP6_SG_POP_LISTS
solution : Check for invalid status values, ensure unique hash keys, and validate date consistency.
snowflake query : 
SELECT * 
FROM SDL_POP6_SG_POP_LISTS 
WHERE status NOT IN (10, 36) 
   OR hashkey IS NULL 
   OR pop_list_date > CURRENT_DATE 
   OR pop_list_date IS NULL 
   OR crtd_dttm IS NULL 
   OR popdb_id IS NULL 
   OR pop_code IS NULL;
========================================================================================================================================

table_name: SDL_ECOM_GMV_SHOPEE
solution: Identify anomalies where values should not be negative, such as gross_sales, gross_orders, gross_avg_basket_size, and product_visitors. These anomalies indicate potential data entry errors or issues with data processing.
snowflake_query: 
SELECT 
    *
FROM 
    SDL_ECOM_GMV_SHOPEE
WHERE 
    gross_sales < 0 OR
    gross_orders < 0 OR
    gross_avg_basket_size < 0 OR
    product_visitors < 0;
========================================================================================================================================

table_name: SDL_MDS_MY_PS_TARGETS
solution: Review and validate the data integrity, focusing on identifying missing or inconsistent data, duplicates, and incorrect formats. Implement data quality checks and validation rules.
snowflake query: 
SELECT 
    ID, 
    COUNT(*) AS occurrence_count 
FROM 
    SDL_MDS_MY_PS_TARGETS 
GROUP BY 
    ID 
HAVING 
    occurrence_count > 1;

SELECT 
    * 
FROM 
    SDL_MDS_MY_PS_TARGETS 
WHERE 
    NAME IS NULL 
    OR CHANNEL IS NULL 
    OR VERSION_ID IS NULL 
    OR VALUE IS NULL 
    OR ENTERDATETIME IS NULL 
    OR LASTCHGDATETIME IS NULL;

SELECT 
    * 
FROM 
    SDL_MDS_MY_PS_TARGETS 
WHERE 
    VALUE < 0 
    OR VALUE IS NULL 
    OR (VALIDATIONSTATUS NOT IN ('VALID', 'INVALID') AND VALIDATIONSTATUS IS NOT NULL);
========================================================================================================================================

table_name: SDL_MDS_SG_PRODUCT_HIERARCHY
solution: Check for duplicate entries based on unique identifiers and validate consistency of related fields.
snowflake query: 
-- Detect duplicate 'id'
SELECT id, COUNT(*) AS count
FROM SDL_MDS_SG_PRODUCT_HIERARCHY
GROUP BY id
HAVING COUNT(*) > 1;

-- Find inconsistencies in 'versionnumber' and 'enterversionnumber'
SELECT *
FROM SDL_MDS_SG_PRODUCT_HIERARCHY
WHERE versionnumber != enterversionnumber;

-- Identify records with identical 'enterdatetime' and 'lastchgdatetime'
SELECT *
FROM SDL_MDS_SG_PRODUCT_HIERARCHY
WHERE enterdatetime = lastchgdatetime;
========================================================================================================================================

table_name: SDL_ECOM_SEARCH_ADS_BY_DATE
solution: 
1. Check for negative values in add_to_cart_units as they are generally not expected.
2. Verify consistency between sales_usd and sales_lcy values.
3. Identify unusually high item_conversion_rate values.
4. Ensure add_to_cart_value_usd and add_to_cart_value_lcy are consistent.
snowflake query:
SELECT 
    DATE, REGION, SHOP_NAME, SHOP_ID, TERMINAL, SALES_USD, SALES_LCY, ORDERS, UNITS_SOLD, VISITS, 
    UNIQUE_VISITORS, ADD_TO_CART_UNITS, ADD_TO_CART_VALUE_USD, ADD_TO_CART_VALUE_LCY, BUYERS, 
    NEW_BUYERS, ITEM_CONVERSION_RATE, CRTD_DTTM, FILENAME 
FROM 
    SDL_ECOM_SEARCH_ADS_BY_DATE
WHERE 
    ADD_TO_CART_UNITS < 0
    OR SALES_USD * 2 <> SALES_LCY
    OR ITEM_CONVERSION_RATE > 1
    OR ADD_TO_CART_VALUE_USD <> ADD_TO_CART_VALUE_LCY;
========================================================================================================================================

table_name: SDL_CSL_CLASSMASTER
solution: Check for duplicate records, ensure non-nullability for key columns, verify data type integrity, and validate business logic constraints (e.g., AVAILABILTY should not exceed TURNOVER).
snowflake query: 
WITH DuplicateRecords AS (
    SELECT pkey, COUNT(*) AS record_count
    FROM SDL_CSL_CLASSMASTER
    GROUP BY pkey
    HAVING COUNT(*) > 1
),
NullKeyColumns AS (
    SELECT *
    FROM SDL_CSL_CLASSMASTER
    WHERE pkey IS NULL OR classid IS NULL
),
InvalidDataTypes AS (
    SELECT *
    FROM SDL_CSL_CLASSMASTER
    WHERE TRY_CAST(availabilty AS NUMBER) IS NULL
       OR TRY_CAST(turnover AS NUMBER) IS NULL
),
BusinessLogicViolations AS (
    SELECT *
    FROM SDL_CSL_CLASSMASTER
    WHERE availabilty > turnover
)
SELECT * FROM DuplicateRecords
UNION ALL
SELECT * FROM NullKeyColumns
UNION ALL
SELECT * FROM InvalidDataTypes
UNION ALL
SELECT * FROM BusinessLogicViolations;
========================================================================================================================================

table_name: SDL_MDS_MY_CUSTOMER_HIERARCHY
solution: Check for missing data, duplicates, and invalid data types. Validate foreign key constraints, and ensure data consistency for hierarchical relationships.
snowflake query: 
-- Check for missing or NULL values in critical columns
SELECT * FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
WHERE ID IS NULL OR MUID IS NULL OR VERSION_ID IS NULL;

-- Check for duplicate records based on unique identifiers
SELECT ID, COUNT(*)
FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
GROUP BY ID
HAVING COUNT(*) > 1;

-- Validate data types and referential integrity
SELECT * FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
WHERE NOT (REGEXP_LIKE(CHANNEL_ID, '^[0-9]+$') AND REGEXP_LIKE(VERSION_ID, '^[0-9]+$'));

-- Check for hierarchical consistency (e.g., territory and channel relationships)
SELECT * FROM SDL_MDS_MY_CUSTOMER_HIERARCHY
WHERE TERRITORY_ID IS NOT NULL AND CHANNEL_ID IS NULL;
========================================================================================================================================

table_name: SDL_MDS_VN_SKU_BENCHMARKS
solution: 
1. Detect negative or zero values in 'jj_packsize' which are logically improbable.
2. Identify mismatched 'jj_packsize' and 'comp_packsize' that significantly differ.
3. Find records with 'valid_from' greater than 'valid_to', which is logically incorrect.

snowflake query: 
SELECT * 
FROM SDL_MDS_VN_SKU_BENCHMARKS 
WHERE jj_packsize <= 0 
   OR ABS(jj_packsize - comp_packsize) > 50 
   OR valid_from > valid_to;
========================================================================================================================================

table_name : SDL_ECOM_AMS
solution : Identify anomalies such as zero purchase values, non-numeric expenses, and missing promotion IDs.
snowflake query : 
SELECT 
    order_id,
    CASE 
        WHEN purchase_value = 0 THEN 'Zero Purchase Value'
        WHEN TRY_TO_NUMBER(expense) IS NULL THEN 'Non-Numeric Expense'
        WHEN promotion_id IS NULL THEN 'Missing Promotion ID'
    END AS anomaly_type
FROM SDL_ECOM_AMS
WHERE 
    purchase_value = 0 
    OR TRY_TO_NUMBER(expense) IS NULL 
    OR promotion_id IS NULL;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_MERCHANDISING
solution: Identify missing or null values, check for duplicate entries, and validate data type constraints.
snowflake_query: 
SELECT 
    distributor_code, 
    distributor_name, 
    sales_repcode, 
    sales_repname, 
    channel_name, 
    sub_channel_name, 
    retailer_code, 
    retailer_name, 
    month, 
    surveydate, 
    aq_name, 
    srd_answer, 
    link, 
    cdl_dttm, 
    run_id, 
    file_name
FROM SDL_DISTRIBUTOR_IVY_MERCHANDISING
WHERE 
    distributor_code IS NULL OR 
    distributor_name IS NULL OR 
    sales_repcode IS NULL OR 
    sales_repname IS NULL OR 
    channel_name IS NULL OR 
    sub_channel_name IS NULL OR 
    retailer_code IS NULL OR 
    retailer_name IS NULL OR 
    month IS NULL OR 
    surveydate IS NULL OR 
    aq_name IS NULL OR 
    srd_answer IS NULL OR 
    link IS NULL OR 
    cdl_dttm IS NULL OR 
    run_id IS NULL OR 
    file_name IS NULL
UNION ALL
SELECT 
    distributor_code, 
    distributor_name, 
    sales_repcode, 
    sales_repname, 
    channel_name, 
    sub_channel_name, 
    retailer_code, 
    retailer_name, 
    month, 
    surveydate, 
    aq_name, 
    srd_answer, 
    link, 
    cdl_dttm, 
    run_id, 
    file_name
FROM (
    SELECT 
        distributor_code, 
        distributor_name, 
        sales_repcode, 
        sales_repname, 
        channel_name, 
        sub_channel_name, 
        retailer_code, 
        retailer_name, 
        month, 
        surveydate, 
        aq_name, 
        srd_answer, 
        link, 
        cdl_dttm, 
        run_id, 
        file_name,
        COUNT(*) OVER (PARTITION BY distributor_code, retailer_code, surveydate) AS duplicate_count
    FROM SDL_DISTRIBUTOR_IVY_MERCHANDISING
) AS subquery
WHERE duplicate_count > 1;
========================================================================================================================================

table_name: SDL_MDS_MY_GT_PRODUCT_MAPPING
solution: Address the anomalies in the dataset by identifying and handling missing values, ensuring data consistency, and validating data integrity.
snowflake query: 
SELECT *
FROM SDL_MDS_MY_GT_PRODUCT_MAPPING
WHERE 
    versionnumber IS NULL OR
    changetrackingmask IS NULL OR
    product_description IS NULL OR
    sap_material_id IS NULL OR
    (validationstatus NOT IN ('Valid', 'Invalid')) OR
    (non_sap NOT IN ('Yes', 'No')) OR
    (enterdatetime != lastchgdatetime OR 
     enterusername != lastchgusername OR 
     enterversionnumber != lastchgversionnumber);
========================================================================================================================================

table_name: SDL_ECOMMERCE_6PAI
solution: Identify and address anomalies in SCORE_WEIGHTED and SCORE_NON_WEIGHTED with respect to PLAN and GAP_VS_PLAN. Use statistical thresholds to detect outliers and apply consistent data validation checks to ensure accuracy.
snowflake query: 
SELECT *
FROM SDL_ECOMMERCE_6PAI
WHERE (SCORE_WEIGHTED < 0 OR SCORE_WEIGHTED > 1)
   OR (SCORE_NON_WEIGHTED < 0 OR SCORE_NON_WEIGHTED > 1)
   OR (GAP_VS_PLAN < -PLAN OR GAP_VS_PLAN > PLAN)
   OR (YEAR NOT BETWEEN '2020' AND '2023')
   OR (MONTH NOT IN ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
   OR (PLAN IS NULL OR SCORE_WEIGHTED IS NULL OR SCORE_NON_WEIGHTED IS NULL);
========================================================================================================================================

table_name: SDL_MDS_PH_NPI_SALES_GROUPINGS  
solution: Detect negative values and invalid entries in columns like 'id', 'versionnumber', and 'changetrackingmask'. Implement constraints or data validation to prevent such anomalies during data entry.  
snowflake query:  
SELECT *  
FROM SDL_MDS_PH_NPI_SALES_GROUPINGS  
WHERE id < 0  
   OR versionnumber < 0  
   OR changetrackingmask < 0  
   OR validationstatus NOT IN ('Pending', 'Validated', 'Invalid')  
   OR versionflag NOT IN ('active', 'inactive', 'deprecated');
========================================================================================================================================

table_name: SDL_POP6_SG_EXECUTED_VISITS
solution: Check for inconsistencies in the visit data, such as missing timestamps or mismatched check-in/check-out coordinates.
snowflake query: 
SELECT 
    VISIT_ID,
    VISIT_DATE,
    CHECK_IN_DATETIME,
    CHECK_OUT_DATETIME,
    POPDB_ID,
    POP_CODE,
    POP_NAME,
    ADDRESS,
    CHECK_IN_LONGITUDE,
    CHECK_IN_LATITUDE,
    CHECK_OUT_LONGITUDE,
    CHECK_OUT_LATITUDE,
    USERNAME,
    USER_FULL_NAME,
    SUPERIOR_USERNAME,
    SUPERIOR_NAME,
    PLANNED_VISIT,
    CANCELLED_VISIT,
    CANCELLATION_REASON,
    CANCELLATION_NOTE,
    FILE_NAME,
    RUN_ID,
    CRTD_DTTM
FROM SDL_POP6_SG_EXECUTED_VISITS
WHERE 
    CHECK_IN_DATETIME IS NULL OR
    CHECK_OUT_DATETIME IS NULL OR
    CHECK_IN_LONGITUDE IS NULL OR 
    CHECK_IN_LATITUDE IS NULL OR
    CHECK_OUT_LONGITUDE IS NULL OR
    CHECK_OUT_LATITUDE IS NULL OR
    CHECK_IN_DATETIME > CHECK_OUT_DATETIME OR
    (CHECK_IN_LONGITUDE != CHECK_OUT_LONGITUDE AND CHECK_IN_LATITUDE != CHECK_OUT_LATITUDE);
========================================================================================================================================

table_name: SDL_SPIRAL_MTI_OFFTAKE
solution: Detect anomalies by identifying negative 'amount', 'quantity', and 'amountusd' values, as well as future 'year' values. Correct the data by verifying source records and ensuring accurate data entry.
snowflake query: 
SELECT *
FROM SDL_SPIRAL_MTI_OFFTAKE
WHERE 
  CAST(quantity AS INTEGER) < 0 
  OR CAST(amount AS INTEGER) < 0 
  OR CAST(amountusd AS INTEGER) < 0 
  OR CAST(year AS INTEGER) > YEAR(CURRENT_DATE);
========================================================================================================================================

table_name: SDL_MDS_VN_ECOM_NTS
solution: To identify anomalies, we need to check for duplicate entries, invalid dates, and mismatches in related fields (e.g., 'versionnumber' and 'versionname'). We can also look for any NULL values in critical fields like 'ID', 'NAME', 'CODE', etc.

snowflake query: 
SELECT 
    ID, NAME, VERSIONNUMBER, VERSIONNAME, ENTERDATETIME, LASTCHGDATETIME, CODE
FROM 
    SDL_MDS_VN_ECOM_NTS
WHERE 
    ID IS NULL 
    OR NAME IS NULL 
    OR CODE IS NULL 
    OR ENTERDATETIME > CURRENT_TIMESTAMP
    OR LASTCHGDATETIME > CURRENT_TIMESTAMP
    OR VERSIONNUMBER <> VERSION_ID
    OR VERSIONNUMBER <> ENTERVERSIONNUMBER
    OR VERSIONNAME IS NULL
    OR (YEAR < 2000 OR YEAR > 2100)
GROUP BY 
    ID, NAME, VERSIONNUMBER, VERSIONNAME, ENTERDATETIME, LASTCHGDATETIME, CODE
HAVING 
    COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_SUMMARY_WEEKLY
solution: 
- Ranking has negative values which are not typical for ranking. Consider setting constraints to ensure rankings are positive.
- Use a consistent data type for ranking, possibly INTEGER, to prevent negative values.
- Validate the data for YEARMO to ensure it follows a valid YYYYMM format, and handle any discrepancies.
snowflake query: 
SELECT 
    *
FROM 
    SDL_KR_COUPANG_PRODUCT_SUMMARY_WEEKLY
WHERE 
    CAST(ranking AS INTEGER) < 0 
    OR LENGTH(yearmo) != 6 
    OR NOT REGEXP_LIKE(yearmo, '^[0-9]{6}$');
========================================================================================================================================

Certainly! Here is the requested information in the specified format:


table_name: SDL_MDS_PH_POS_PRODUCT_TEMP
solution: The sample data provided is empty, making it challenging to identify specific anomalies directly. However, based on the schema, common anomalies might include missing values, duplicates, or inconsistency in data types. Below are generic strategies and queries to detect such anomalies.

snowflake query: 
-- Check for missing values in critical columns
SELECT *
FROM SDL_MDS_PH_POS_PRODUCT_TEMP
WHERE VERSIONNAME IS NULL
   OR ID IS NULL
   OR BARCODE IS NULL;

-- Check for duplicate records based on unique identifiers
SELECT ID, COUNT(*)
FROM SDL_MDS_PH_POS_PRODUCT_TEMP
GROUP BY ID
HAVING COUNT(*) > 1;

-- Check for inconsistencies in data types, e.g., numerical fields with text values
SELECT *
FROM SDL_MDS_PH_POS_PRODUCT_TEMP
WHERE TRY_TO_NUMBER(CUST_ITEM_PRC) IS NULL AND CUST_ITEM_PRC IS NOT NULL;


These queries are designed to detect basic anomalies such as missing values, duplicates, and data type inconsistencies within the table `SDL_MDS_PH_POS_PRODUCT_TEMP`.
========================================================================================================================================

table_name: SDL_MDS_SG_SKU_BENCHMARKS
solution: Check for inconsistent data in 'validationstatus', 'comp_packsize', and 'variance'. Consider adding constraints or validations to ensure data integrity.
snowflake query: 
SELECT 
    id, 
    validationstatus, 
    comp_packsize, 
    variance, 
    jj_target 
FROM 
    SDL_MDS_SG_SKU_BENCHMARKS 
WHERE 
    validationstatus NOT IN ('valid', 'invalid')
    OR comp_packsize <= 0 
    OR variance < 0 
    OR variance > jj_target;
========================================================================================================================================

table_name: SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
solution: Identify missing or null values, ensure unique constraints, and validate data types.
snowflake query: 
SELECT 
    'Missing or Null Values' AS anomaly_type, 
    COUNT(*) AS anomaly_count
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
WHERE 
    ID IS NULL OR 
    MUID IS NULL OR
    VERSIONNAME IS NULL OR 
    VERSIONNUMBER IS NULL OR 
    VERSION_ID IS NULL OR 
    VERSIONFLAG IS NULL OR 
    NAME IS NULL OR 
    CODE IS NULL OR 
    CHANGETRACKINGMASK IS NULL OR 
    GROUP_SHOP_TYPE_CODE IS NULL OR 
    GROUP_SHOP_TYPE_NAME IS NULL OR 
    GROUP_SHOP_TYPE_ID IS NULL OR 
    RE_CODE IS NULL OR 
    RE_NAME IS NULL OR 
    RE_ID IS NULL OR 
    MSL_RE_CODE IS NULL OR 
    MSL_RE_NAME IS NULL OR 
    MSL_RE_ID IS NULL OR 
    CHANNEL_CODE IS NULL OR 
    CHANNEL_NAME IS NULL OR 
    CHANNEL_ID IS NULL OR 
    ENTERDATETIME IS NULL OR 
    ENTERUSERNAME IS NULL OR 
    ENTERVERSIONNUMBER IS NULL OR 
    LASTCHGDATETIME IS NULL OR 
    LASTCHGUSERNAME IS NULL OR 
    LASTCHGVERSIONNUMBER IS NULL OR 
    VALIDATIONSTATUS IS NULL
UNION ALL
SELECT 
    'Duplicate ID Values' AS anomaly_type, 
    COUNT(*) - COUNT(DISTINCT ID) AS anomaly_count
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
UNION ALL
SELECT 
    'Invalid Data Types' AS anomaly_type, 
    COUNT(*) AS anomaly_count
FROM SDL_MDS_VN_STORE_RETAIL_ENVIRONMENT_MAPPING
WHERE 
    TRY_CAST(ID AS NUMBER) IS NULL OR 
    TRY_CAST(RE_ID AS NUMBER) IS NULL OR 
    TRY_CAST(CHANNEL_ID AS NUMBER) IS NULL OR
    TRY_CAST(MSL_RE_ID AS NUMBER) IS NULL OR 
    TRY_CAST(VERSIONNUMBER AS NUMBER) IS NULL OR 
    TRY_CAST(LASTCHGVERSIONNUMBER AS NUMBER) IS NULL OR 
    TRY_CAST(ENTERVERSIONNUMBER AS NUMBER) IS NULL OR 
    TRY_CAST(VERSION_ID AS NUMBER) IS NULL OR 
    TRY_CAST(GROUP_SHOP_TYPE_ID AS NUMBER) IS NULL OR 
    TRY_CAST(CHANGETRACKINGMASK AS NUMBER) IS NULL;
========================================================================================================================================

table_name: SDL_POP6_SG_DISPLAY_PLANS
solution: Address negative values in 'status' and 'required_number_of_displays' by validating or correcting data entry processes. Ensure 'end_date' is always after 'start_date'.
snowflake query: 
SELECT
    display_plan_id,
    status,
    required_number_of_displays,
    start_date,
    end_date
FROM
    SDL_POP6_SG_DISPLAY_PLANS
WHERE
    status < 0
    OR required_number_of_displays < 0
    OR end_date <= start_date;
========================================================================================================================================

table_name: SDL_CSL_SCHEME_HEADER  
solution: Identify rows with missing or null values in critical fields and ensure data integrity. Implement constraints or data validation checks.  
snowflake query:  
SELECT *  
FROM SDL_CSL_SCHEME_HEADER  
WHERE SCHID IS NULL  
   OR SCHCODE IS NULL  
   OR SCHDSC IS NULL  
   OR CLAIMABLE IS NULL  
   OR CLMAMTON IS NULL  
   OR CMPSCHCODE IS NULL  
   OR SCHLEVEL_ID IS NULL  
   OR SCHTYPE IS NULL;
========================================================================================================================================

Certainly! Based on the metadata and sample data provided, here is an analysis of potential anomalies and the solutions in the required format:


table_name: SDL_CSL_TBL_SCHEMEWISE_APNO
solution: Detect and handle anomalies such as negative or invalid 'SCHID' values and 'NULL' values in 'SCHCATEGORYTYPE1CODE'.
snowflake query: 
SELECT * 
FROM SDL_CSL_TBL_SCHEMEWISE_APNO 
WHERE SCHID < 0 
   OR SCHCATEGORYTYPE1CODE IS NULL;


This SQL query is designed to efficiently identify rows with a negative `SCHID` or `NULL` values in `SCHCATEGORYTYPE1CODE`, which are potential anomalies in the dataset. The solution involves reviewing these rows and determining appropriate corrective actions, such as updating or removing invalid entries.
========================================================================================================================================

table_name : SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING
solution : Detect anomalies in the data such as negative version numbers, duplicate IDs, and inactive entries marked as active.
snowflake query : 
SELECT *
FROM SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING
WHERE VERSIONNUMBER < 0
   OR ID IN (SELECT ID FROM SDL_MDS_VN_GT_MSL_SHOPTYPE_MAPPING GROUP BY ID HAVING COUNT(*) > 1)
   OR (ACTIVE = 1 AND VERSIONFLAG = 'inactive');
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_CUST_CIW_PLAN
solution: The data contains negative values for IDs, quantities, and financial measures, which are likely invalid. Duplicate MUIDs should be eliminated, and validation status should be checked to ensure data integrity. Adjust values based on domain knowledge and ensure positive values where applicable.
snowflake query:
SELECT *
FROM SDL_MDS_PACIFIC_CUST_CIW_PLAN
WHERE id < 0 
   OR goal_qty < 0 
   OR goal_gts < 0 
   OR goal_eff_val < 0 
   OR goal_jgf_si_val < 0 
   OR goal_pmt_terms_val < 0 
   OR goal_datains_val < 0 
   OR goal_exp_adj_val < 0 
   OR goal_jgf_sd_val < 0 
   OR goal_ciw_tot < 0 
   OR goal_cogs < 0 
   OR goal_gp < 0 
   OR muid IN (
       SELECT muid
       FROM SDL_MDS_PACIFIC_CUST_CIW_PLAN
       GROUP BY muid
       HAVING COUNT(*) > 1
   )
   OR validationstatus = 'invalid';
========================================================================================================================================

table_name: SDL_JNJ_OSA_OOS_REPORT
solution: Identify negative run_id values and investigate their source. Check for future dates in osa_oos_date and yearmo for validity.
snowflake query: 
SELECT *
FROM SDL_JNJ_OSA_OOS_REPORT
WHERE run_id < 0
   OR osa_oos_date > CURRENT_TIMESTAMP()
   OR TRY_TO_DATE(yearmo, 'YYYYMM') > CURRENT_DATE();
========================================================================================================================================

table_name: SDL_MDS_VN_CUSTOMER_SALES_ORGANIZATION
solution: Detect anomalies such as negative IDs, mismatched statuses, and invalid entries. Consider implementing data validation rules and constraints to prevent such issues in the future.
snowflake query: 
SELECT * 
FROM SDL_MDS_VN_CUSTOMER_SALES_ORGANIZATION 
WHERE id < 0 
   OR status NOT IN ('Active', 'Inactive', 'Pending') 
   OR validationstatus = 'Invalid';
========================================================================================================================================

sql
table_name: SDL_POP6_SG_PLANNED_VISITS

solution: The 'run_id' column has negative values which are likely erroneous. Ensure 'run_id' values are non-negative as they might represent unique identifiers or sequence numbers. Validate or replace negative 'run_id' values with appropriate positive numbers or NULL if such values are not valid.

snowflake_query: 
SELECT * 
FROM SDL_POP6_SG_PLANNED_VISITS 
WHERE run_id < 0;

solution: The 'pop_name' and 'user_full_name' columns have identical data, which might indicate redundancy. Confirm whether both columns are necessary or if one can be removed to optimize storage and queries.

snowflake_query: 
SELECT * 
FROM SDL_POP6_SG_PLANNED_VISITS 
WHERE pop_name != user_full_name;

solution: Ensure 'planned_visit_date' and 'crtd_dttm' timestamps are logical. 'planned_visit_date' should not be in the past relative to 'crtd_dttm', if 'planned_visit_date' represents future events.

snowflake_query: 
SELECT * 
FROM SDL_POP6_SG_PLANNED_VISITS 
WHERE planned_visit_date < DATE(crtd_dttm);
========================================================================================================================================

table_name: MS_MASTERSURVEY
solution: Address negative and anomalous fetched sequences, null values, duplicate survey IDs, duplicate load keys, and missing descriptions.
snowflake_query: 
SELECT
    *
FROM
    MS_MASTERSURVEY
WHERE
    FETCHEDSEQUENCE < 0 OR
    LOAD_KEY IS NULL OR
    MASTERSURVEYID IS NULL OR
    MASTERSURVEYDESCRIPTION IS NULL OR
    MASTERSURVEYID IN (
        SELECT MASTERSURVEYID
        FROM MS_MASTERSURVEY
        GROUP BY MASTERSURVEYID
        HAVING COUNT(*) > 1
    ) OR
    LOAD_KEY IN (
        SELECT LOAD_KEY
        FROM MS_MASTERSURVEY
        GROUP BY LOAD_KEY
        HAVING COUNT(*) > 1
    );


This solution and query efficiently detect anomalies such as negative fetched sequences, null values in critical fields, duplicate survey IDs, duplicate load keys, and missing descriptions.
========================================================================================================================================

table_name: SDL_MATERIAL_PKA_MARA_EXTRACT
solution: Check for missing or inconsistent data in TEXT fields. Ensure data completeness and consistency by validating key fields such as MATERIAL, DESCRIPTION, MATERIAL_TYPE, etc.
snowflake query: 
SELECT 
    MATERIAL, 
    DESCRIPTION, 
    MATERIAL_TYPE, 
    CREATED_ON, 
    MANUFACTURER, 
    MANUFACTURING_SOURCE, 
    BH_MEGA_BRAND, 
    BH_MEGA_BRAND_DESC, 
    BH_BRAND, 
    BH_BRAND_DESC, 
    BH_BASE_PRODUCT, 
    BH_BASE_PRODUCT_DESC, 
    BH_VARIANT, 
    BH_VARIANT_DESC, 
    BH_PUT_UP, 
    BH_PUT_UP_DESC, 
    FRANCHISE, 
    FRANCHISE_DESCRIPTION, 
    BRAND, 
    BRAND_DESCRIPTION, 
    SUBBRAND, 
    SUBBRANDDESC, 
    VARIANT, 
    VARIANTDESC, 
    SUBVARIANT, 
    SUBVARIANTDESC, 
    FLAVOR, 
    FLAVORDESC, 
    INGREDIENT, 
    INGREDIENTDESC, 
    APPLICATION, 
    APPLICATIONDESC, 
    STRENGTH, 
    STRENGTHDESC, 
    SHAPE, 
    SHAPEDESC, 
    SPF, 
    SPFDESC, 
    COVER, 
    COVERDESC, 
    FORM, 
    FORMDESC, 
    SIZE, 
    SIZEDESC, 
    CHARACTER, 
    CHARATERDESC, 
    PACKAGE, 
    PACKAGEDESC, 
    ATTRIBUTE13, 
    ATTRIBUTE13DESC, 
    ATTRIBUTE14, 
    ATTRIBUTE14DESC, 
    SKUIDENTIFICATION, 
    SKUIDDESC, 
    ONETIMEREL, 
    ONETIMERELDESC, 
    PRODUCTKEY, 
    PRODUCTDESC, 
    ROOTCODE, 
    ROOTCODEDES, 
    WITH_2018_2019_NTS 
FROM SDL_MATERIAL_PKA_MARA_EXTRACT
WHERE 
    MATERIAL IS NULL 
    OR DESCRIPTION IS NULL 
    OR MATERIAL_TYPE IS NULL 
    OR CREATED_ON IS NULL 
    OR MANUFACTURER IS NULL 
    OR MANUFACTURING_SOURCE IS NULL 
    OR BH_MEGA_BRAND IS NULL 
    OR BH_MEGA_BRAND_DESC IS NULL 
    OR BH_BRAND IS NULL 
    OR BH_BRAND_DESC IS NULL 
    OR BH_BASE_PRODUCT IS NULL 
    OR BH_BASE_PRODUCT_DESC IS NULL 
    OR BH_VARIANT IS NULL 
    OR BH_VARIANT_DESC IS NULL 
    OR BH_PUT_UP IS NULL 
    OR BH_PUT_UP_DESC IS NULL 
    OR FRANCHISE IS NULL 
    OR FRANCHISE_DESCRIPTION IS NULL 
    OR BRAND IS NULL 
    OR BRAND_DESCRIPTION IS NULL 
    OR SUBBRAND IS NULL 
    OR SUBBRANDDESC IS NULL 
    OR VARIANT IS NULL 
    OR VARIANTDESC IS NULL 
    OR SUBVARIANT IS NULL 
    OR SUBVARIANTDESC IS NULL 
    OR FLAVOR IS NULL 
    OR FLAVORDESC IS NULL 
    OR INGREDIENT IS NULL 
    OR INGREDIENTDESC IS NULL 
    OR APPLICATION IS NULL 
    OR APPLICATIONDESC IS NULL 
    OR STRENGTH IS NULL 
    OR STRENGTHDESC IS NULL 
    OR SHAPE IS NULL 
    OR SHAPEDESC IS NULL 
    OR SPF IS NULL 
    OR SPFDESC IS NULL 
    OR COVER IS NULL 
    OR COVERDESC IS NULL 
    OR FORM IS NULL 
    OR FORMDESC IS NULL 
    OR SIZE IS NULL 
    OR SIZEDESC IS NULL 
    OR CHARACTER IS NULL 
    OR CHARATERDESC IS NULL 
    OR PACKAGE IS NULL 
    OR PACKAGEDESC IS NULL 
    OR ATTRIBUTE13 IS NULL 
    OR ATTRIBUTE13DESC IS NULL 
    OR ATTRIBUTE14 IS NULL 
    OR ATTRIBUTE14DESC IS NULL 
    OR SKUIDENTIFICATION IS NULL 
    OR SKUIDDESC IS NULL 
    OR ONETIMEREL IS NULL 
    OR ONETIMERELDESC IS NULL 
    OR PRODUCTKEY IS NULL 
    OR PRODUCTDESC IS NULL 
    OR ROOTCODE IS NULL 
    OR ROOTCODEDES IS NULL 
    OR WITH_2018_2019_NTS IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_ECOM_NTS
solution: Identify missing or null values, inconsistencies in data types, and outliers in numerical fields.
snowflake_query: 
SELECT 
    id, 
    muid, 
    versionname, 
    versionnumber, 
    version_id, 
    versionflag, 
    name, 
    code, 
    changetrackingmask, 
    year, 
    month, 
    market, 
    gfo, 
    need_state, 
    brand, 
    customer_name, 
    crncy_cd, 
    nts_lcy, 
    enterdatetime, 
    enterusername, 
    enterversionnumber, 
    lastchgdatetime, 
    lastchgusername, 
    lastchgversionnumber, 
    validationstatus 
FROM SDL_MDS_PACIFIC_ECOM_NTS
WHERE 
    id IS NULL OR
    muid IS NULL OR
    versionname IS NULL OR
    versionnumber IS NULL OR
    version_id IS NULL OR
    versionflag IS NULL OR
    name IS NULL OR
    code IS NULL OR
    changetrackingmask IS NULL OR
    year IS NULL OR
    month IS NULL OR
    market IS NULL OR
    gfo IS NULL OR
    need_state IS NULL OR
    brand IS NULL OR
    customer_name IS NULL OR
    crncy_cd IS NULL OR
    nts_lcy IS NULL OR
    enterdatetime IS NULL OR
    enterusername IS NULL OR
    enterversionnumber IS NULL OR
    lastchgdatetime IS NULL OR
    lastchgusername IS NULL OR
    lastchgversionnumber IS NULL OR
    validationstatus IS NULL OR
    versionnumber < 0 OR
    changetrackingmask < 0 OR
    nts_lcy < 0 OR
    year < 0 OR
    month < 1 OR month > 12


This query checks for null values and some basic numerical anomalies such as negative numbers where they don't make sense or invalid month numbers. Adjust the conditions based on specific data quality rules relevant to your dataset.
========================================================================================================================================

table_name : SDL_MDS_PH_POS_PRODUCT
solution : Check for negative or zero values in 'id' and 'cust_item_prc', and ensure 'computed_price_per_unit' matches with 'jj_price_per_unit'. Validate unique constraints for 'barcode' fields and check 'validationstatus' for consistency.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_MDS_PH_POS_PRODUCT 
WHERE 
    id <= 0 
    OR cust_item_prc <= 0 
    OR computed_price_per_unit != jj_price_per_unit 
    OR validationstatus != 'Valid' 
    OR (barcode IN (SELECT barcode FROM SDL_MDS_PH_POS_PRODUCT GROUP BY barcode HAVING COUNT(*) > 1))
    OR (jnj_matl_cse_barcode IN (SELECT jnj_matl_cse_barcode FROM SDL_MDS_PH_POS_PRODUCT GROUP BY jnj_matl_cse_barcode HAVING COUNT(*) > 1))
    OR (jnj_matl_pc_barcode IN (SELECT jnj_matl_pc_barcode FROM SDL_MDS_PH_POS_PRODUCT GROUP BY jnj_matl_pc_barcode HAVING COUNT(*) > 1))
    OR (jnj_matl_shipper_barcode IN (SELECT jnj_matl_shipper_barcode FROM SDL_MDS_PH_POS_PRODUCT GROUP BY jnj_matl_shipper_barcode HAVING COUNT(*) > 1))
    OR (jnj_matl_consumer_barcode IN (SELECT jnj_matl_consumer_barcode FROM SDL_MDS_PH_POS_PRODUCT GROUP BY jnj_matl_consumer_barcode HAVING COUNT(*) > 1));
========================================================================================================================================

table_name: SDL_MARKET_SHARE_QSD
solution: The metadata indicates potential inconsistency in column naming conventions and data completeness issues. Columns like 'country/cluster', 'country (geo)', 'special region' might have overlapping data. Additionally, the presence of empty sample data suggests missing values.
snowflake query: 
SELECT 
  COUNT(*) AS total_rows,
  SUM(CASE WHEN "country/cluster" IS NULL THEN 1 ELSE 0 END) AS null_country_cluster,
  SUM(CASE WHEN "country (geo)" IS NULL THEN 1 ELSE 0 END) AS null_country_geo,
  SUM(CASE WHEN "special region" IS NULL THEN 1 ELSE 0 END) AS null_special_region,
  SUM(CASE WHEN "VALUE" IS NULL THEN 1 ELSE 0 END) AS null_value
FROM SDL_MARKET_SHARE_QSD;
========================================================================================================================================

table_name: SDL_MDS_MY_PS_MSL
solution: Identify and correct invalid 'valid_to' dates, ensure 'validationstatus' aligns with actual data validity, and verify EAN codes for accuracy.
snowflake query: 
SELECT 
  id, muid, versionname, versionnumber, version_id, versionflag, name, code, changetrackingmask, ean, 
  product_name, enterdatetime, enterusername, enterversionnumber, lastchgdatetime, lastchgusername, 
  lastchgversionnumber, validationstatus, valid_from, valid_to
FROM 
  SDL_MDS_MY_PS_MSL
WHERE 
  valid_to < valid_from OR
  validationstatus NOT IN ('valid', 'pending', 'invalid') OR
  LENGTH(ean) <> 13 OR
  validationstatus = 'valid' AND valid_to < CURRENT_TIMESTAMP;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_ECOM_PRODUCT
solution: Detect negative and null values in key fields, and ensure UPCs are unique and non-zero.
snowflake_query: 
SELECT 
  id, muid, versionname, versionnumber, version_id, versionflag, name, code, 
  changetrackingmask, dataset, cust_attr_1, cust_attr_2, upc, sku_name, 
  prod_attr_1, prod_attr_2, prod_attr_3, enterdatetime, enterusername, 
  enterversionnumber, lastchgdatetime, lastchgusername, lastchgversionnumber, 
  validationstatus
FROM 
  SDL_MDS_PACIFIC_ECOM_PRODUCT
WHERE 
  versionnumber < 0 
  OR enterversionnumber < 0 
  OR changetrackingmask < 0 
  OR versionname IS NULL 
  OR name IS NULL 
  OR upc = '0' 
  OR upc IS NULL 
  OR EXISTS (
    SELECT 1 
    FROM SDL_MDS_PACIFIC_ECOM_PRODUCT AS sub 
    WHERE sub.upc = SDL_MDS_PACIFIC_ECOM_PRODUCT.upc 
    GROUP BY sub.upc 
    HAVING COUNT(*) > 1
  );
========================================================================================================================================

table_name: SDL_MY_DAILY_SELLOUT_STOCK_FACT
solution: Identify negative values in 'qty', 'qty_on_ord', 'qty_committed', 'available_qty_pc', 'qty_on_ord_pc', 'qty_committed_pc', 'unit_prc', and 'total_val'. Negative values in these columns could indicate data entry errors or returns that need to be verified.
snowflake query: 
SELECT * 
FROM SDL_MY_DAILY_SELLOUT_STOCK_FACT
WHERE CAST(qty AS INTEGER) < 0 
   OR CAST(qty_on_ord AS INTEGER) < 0 
   OR CAST(qty_committed AS INTEGER) < 0 
   OR CAST(available_qty_pc AS INTEGER) < 0 
   OR CAST(qty_on_ord_pc AS INTEGER) < 0 
   OR CAST(qty_committed_pc AS INTEGER) < 0 
   OR CAST(unit_prc AS INTEGER) < 0 
   OR CAST(total_val AS INTEGER) < 0;
========================================================================================================================================

table_name: SDL_CSL_SALESMANMASTER
solution: Detect and address null values in `SMNAME` and `SMEMAIL`, negative values in `SMMKTCREDIT`, unusually high `SMCREDITDAYS`, and mismatched `SMID` and `SYNCID`.
snowflake query: 
SELECT *
FROM SDL_CSL_SALESMANMASTER
WHERE SMNAME IS NULL
   OR SMEMAIL IS NULL
   OR SMMKTCREDIT < 0
   OR SMID != SYNCID
   OR SMOTHERDETAILS IS NULL
   OR SMDAILYALLOWANCE IS NULL
   OR SMMONTHLYSALARY IS NULL
   OR STATUS IS NULL
   OR SMCREDITDAYS > 1000;
========================================================================================================================================

table_name: SDL_POP6_SG_PRODUCTS
solution: The data contains negative values in fields where such values are not expected (e.g., `unit_price`, `largest_uom_quantity`, etc.). Implement validation checks during data ingestion to prevent negative values in these fields, and review existing data to correct anomalies.
snowflake query: 
SELECT * FROM SDL_POP6_SG_PRODUCTS  
WHERE status < 0
   OR unit_price < 0
   OR display_order < 0
   OR largest_uom_quantity < 0
   OR middle_uom_quantity < 0
   OR smallest_uom_quantity < 0
   OR run_id < 0;
========================================================================================================================================

table_name : SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
solution : Identify negative run_id values and ensure they are correctly processed. Consider verifying the data source or implementing a data validation step during ETL to prevent negative values if not intended.
snowflake query : 
SELECT * 
FROM SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
WHERE RUN_ID < 0;

solution : Check for any potential data integrity issues with TIMESTAMP_NTZ in crtd_dttm, especially future dates or unexpected time frames.
snowflake query : 
SELECT * 
FROM SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
WHERE CRTD_DTTM > CURRENT_TIMESTAMP;

solution : Verify the uniqueness and proper relationship of field_id, product_attribute_id, and related identifiers to maintain data consistency.
snowflake query : 
SELECT field_id, COUNT(*) 
FROM SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
GROUP BY field_id 
HAVING COUNT(*) > 1;

solution : Ensure product_attribute and product_attribute_value correspond correctly to product_attribute_id and product_attribute_value_id, respectively, to maintain accurate mapping.
snowflake query : 
SELECT product_attribute_id, product_attribute, COUNT(*)
FROM SDL_POP6_SG_PRODUCT_ATTRIBUTE_AUDITS
GROUP BY product_attribute_id, product_attribute
HAVING COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_CSL_RETAILERHIERARCHY
solution: Identify and correct negative values in 'turnover' and 'run_id'. Ensure 'createddt' and 'crt_dttm' are future-proof and consistent.
snowflake query:
SELECT * 
FROM SDL_CSL_RETAILERHIERARCHY
WHERE turnover < 0 
   OR run_id < 0
   OR createddt > CURRENT_TIMESTAMP 
   OR crt_dttm > CURRENT_TIMESTAMP;
========================================================================================================================================

table_name : SDL_ID_POS_DIAMOND_SELLOUT
solution : Detect negative sales and quantities, future dates in yearmonth, and inconsistencies in branch names.
snowflake query : 
SELECT *
FROM SDL_ID_POS_DIAMOND_SELLOUT
WHERE SALES < 0
   OR QTY < 0
   OR YEARMONTH > CURRENT_DATE::TEXT
   OR NOT BRANCH IN ('San Antonio', 'Charlotte', 'Indianapolis', 'Raleigh', 'Tampa');
========================================================================================================================================

sql
table_name: SDL_KR_COUPANG_SEARCH_KEYWORD_BY_CATEGORY
solution: Detect anomalies such as negative rankings, inconsistent YEARMO formats, and invalid product flags. Recommend data validation checks, and updates or corrections for identified anomalies.
snowflake query: 
SELECT 
    *,
    CASE 
        WHEN TRY_TO_NUMBER(ranking) < 0 THEN 'Negative RANKING'
        WHEN TRY_TO_NUMBER(product_ranking) < 0 THEN 'Negative PRODUCT_RANKING'
        WHEN NOT REGEXP_LIKE(yearmo, '^[0-9]{6}$') THEN 'Invalid YEARMO format'
        WHEN NOT jnj_product_flag IN ('Y', 'N') THEN 'Invalid JNJ_PRODUCT_FLAG'
        ELSE 'No Anomaly'
    END AS anomaly_type
FROM SDL_KR_COUPANG_SEARCH_KEYWORD_BY_CATEGORY
WHERE 
    TRY_TO_NUMBER(ranking) < 0 OR
    TRY_TO_NUMBER(product_ranking) < 0 OR
    NOT REGEXP_LIKE(yearmo, '^[0-9]{6}$') OR
    NOT jnj_product_flag IN ('Y', 'N');


This query helps identify anomalies such as negative rankings, incorrect YEARMO formats, and invalid product flags within the specified table. The solution involves implementing data validation and correction processes for these identified issues to ensure data accuracy and consistency.
========================================================================================================================================

table_name: SDL_MDS_SG_PS_WEIGHTS
solution: Detect potential anomalies like duplicate 'MUID', negative 'VERSION_ID', and ensure 'VALIDATIONSTATUS' is valid. Address these issues by removing duplicates, ensuring version IDs are positive, and checking validation status.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_MDS_SG_PS_WEIGHTS
WHERE 
    MUID IN (
        SELECT MUID 
        FROM SDL_MDS_SG_PS_WEIGHTS 
        GROUP BY MUID 
        HAVING COUNT(*) > 1
    )
    OR VERSION_ID < 0
    OR VALIDATIONSTATUS != 'valid';
========================================================================================================================================

table_name : SDL_MY_DAILY_SELLOUT_SALES_FACT
solution : Identify and address discrepancies in discount calculations and negative subtotals.
snowflake query : 
SELECT *
FROM SDL_MY_DAILY_SELLOUT_SALES_FACT
WHERE 
  discount < 0 OR
  subtotal_1 < 0 OR
  subtotal_2 < 0 OR
  discount > subtotal_1 OR
  discount > subtotal_2;
========================================================================================================================================

table_name: SDL_API_DSTR
solution: The table contains several anomalies such as negative values in columns where they shouldn't be, incorrect data types for numerical fields, and potential missing or null values in key columns. These need addressing to ensure data integrity.

snowflake query: 
SELECT *
FROM SDL_API_DSTR
WHERE 
  CAST(month_03 AS FLOAT) < 0 
  OR CAST(month_04 AS FLOAT) < 0 
  OR CAST(mth_total_invoiced_qty AS FLOAT) < 0 
  OR CAST(soh_qty AS FLOAT) < 0
  OR TRY_CAST(cost_price AS FLOAT) IS NULL
  OR product_ean IS NULL
  OR vendor IS NULL;
========================================================================================================================================

table_name: SDL_DNR_CUSTOMER_DIM
solution: Handle NULL values in 'custname' by updating with default or derived values. Ensure consistent data types for 'grcust' and 'cust_id' as they should be numeric or standardized.
snowflake_query: 
SELECT 
    CUST_ID, 
    CUSTNAME, 
    CUSTADD, 
    CUSTCITY, 
    PSTLZ, 
    GRCUST
FROM 
    SDL_DNR_CUSTOMER_DIM
WHERE 
    CUSTNAME IS NULL
    OR TRY_TO_NUMBER(GRCUST) IS NULL
    OR TRY_TO_NUMBER(CUST_ID) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_CIW_ADJUSTMENT
solution: Identify potential data anomalies such as missing or inconsistent values, duplicates, and validate data integrity. Address issues by cleaning the data, ensuring unique identifiers, and maintaining data consistency across columns.
snowflake query: 
-- Detect missing or inconsistent values
SELECT 
    ID, 
    MUID, 
    VERSIONNAME, 
    VERSIONNUMBER, 
    VERSION_ID, 
    VERSIONFLAG, 
    NAME, 
    CODE, 
    CHANGETRACKINGMASK, 
    CUSTOMER_ID, 
    PROD_MJR_CD, 
    SAP_ACCNT, 
    AMT_OBJ_CRNCY, 
    LOCAL_CCY, 
    ENTERDATETIME, 
    ENTERUSERNAME, 
    ENTERVERSIONNUMBER, 
    LASTCHGDATETIME, 
    LASTCHGUSERNAME, 
    LASTCHGVERSIONNUMBER, 
    VALIDATIONSTATUS
FROM 
    SDL_MDS_PACIFIC_CIW_ADJUSTMENT
WHERE 
    ID IS NULL OR 
    MUID IS NULL OR 
    VERSIONNAME IS NULL OR 
    VERSIONNUMBER IS NULL OR 
    VERSION_ID IS NULL OR 
    VERSIONFLAG IS NULL OR 
    NAME IS NULL OR 
    CODE IS NULL OR 
    CHANGETRACKINGMASK IS NULL OR 
    CUSTOMER_ID IS NULL OR 
    PROD_MJR_CD IS NULL OR 
    SAP_ACCNT IS NULL OR 
    AMT_OBJ_CRNCY IS NULL OR 
    LOCAL_CCY IS NULL OR 
    ENTERDATETIME IS NULL OR 
    ENTERUSERNAME IS NULL OR 
    ENTERVERSIONNUMBER IS NULL OR 
    LASTCHGDATETIME IS NULL OR 
    LASTCHGUSERNAME IS NULL OR 
    LASTCHGVERSIONNUMBER IS NULL OR 
    VALIDATIONSTATUS IS NULL
UNION ALL
-- Detect duplicates
SELECT 
    ID, 
    MUID, 
    VERSIONNAME, 
    VERSIONNUMBER, 
    VERSION_ID, 
    VERSIONFLAG, 
    NAME, 
    CODE, 
    CHANGETRACKINGMASK, 
    CUSTOMER_ID, 
    PROD_MJR_CD, 
    SAP_ACCNT, 
    AMT_OBJ_CRNCY, 
    LOCAL_CCY, 
    ENTERDATETIME, 
    ENTERUSERNAME, 
    ENTERVERSIONNUMBER, 
    LASTCHGDATETIME, 
    LASTCHGUSERNAME, 
    LASTCHGVERSIONNUMBER, 
    VALIDATIONSTATUS
FROM 
    SDL_MDS_PACIFIC_CIW_ADJUSTMENT
GROUP BY 
    ID, 
    MUID, 
    VERSIONNAME, 
    VERSIONNUMBER, 
    VERSION_ID, 
    VERSIONFLAG, 
    NAME, 
    CODE, 
    CHANGETRACKINGMASK, 
    CUSTOMER_ID, 
    PROD_MJR_CD, 
    SAP_ACCNT, 
    AMT_OBJ_CRNCY, 
    LOCAL_CCY, 
    ENTERDATETIME, 
    ENTERUSERNAME, 
    ENTERVERSIONNUMBER, 
    LASTCHGDATETIME, 
    LASTCHGUSERNAME, 
    LASTCHGVERSIONNUMBER, 
    VALIDATIONSTATUS
HAVING 
    COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_MY_DAILY_SELLOUT_SALES_FACT_MDS_SYNC
solution: Identify and address discrepancies in data types, particularly numeric fields stored as TEXT. Validate and clean data to ensure correct data types and consistency in values, especially for amounts and quantities.
snowflake query: 
SELECT 
    distributor_id, 
    sales_order_number, 
    sales_order_date, 
    type, 
    customer_code, 
    distributor_wh_id, 
    sap_material_id, 
    product_code, 
    product_ean_code, 
    product_description, 
    TRY_CAST(gross_item_price AS NUMBER) AS gross_item_price, 
    TRY_CAST(quantity AS NUMBER) AS quantity, 
    uom, 
    TRY_CAST(quantity_in_pieces AS NUMBER) AS quantity_in_pieces, 
    TRY_CAST(quantity_after_conversion AS NUMBER) AS quantity_after_conversion, 
    TRY_CAST(sub_total_1 AS NUMBER) AS sub_total_1, 
    TRY_CAST(discount AS NUMBER) AS discount, 
    TRY_CAST(sub_total_2 AS NUMBER) AS sub_total_2, 
    TRY_CAST(bottom_line_discount AS NUMBER) AS bottom_line_discount, 
    TRY_CAST(total_amt_after_tax AS NUMBER) AS total_amt_after_tax, 
    TRY_CAST(total_amt_before_tax AS NUMBER) AS total_amt_before_tax, 
    sales_employee, 
    filename, 
    crt_dttm
FROM SDL_MY_DAILY_SELLOUT_SALES_FACT_MDS_SYNC
WHERE TRY_CAST(gross_item_price AS NUMBER) IS NULL 
    OR TRY_CAST(quantity AS NUMBER) IS NULL 
    OR TRY_CAST(quantity_in_pieces AS NUMBER) IS NULL 
    OR TRY_CAST(quantity_after_conversion AS NUMBER) IS NULL 
    OR TRY_CAST(sub_total_1 AS NUMBER) IS NULL 
    OR TRY_CAST(discount AS NUMBER) IS NULL 
    OR TRY_CAST(sub_total_2 AS NUMBER) IS NULL 
    OR TRY_CAST(bottom_line_discount AS NUMBER) IS NULL 
    OR TRY_CAST(total_amt_after_tax AS NUMBER) IS NULL 
    OR TRY_CAST(total_amt_before_tax AS NUMBER) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_CUST_ATTRB
solution: Identify and address missing or null entries in critical columns, ensure unique keys for IDs, and check for data type mismatches.
snowflake query: 
SELECT 
    'Missing or Null Values' AS Anomaly_Type,
    column_name,
    COUNT(*) AS Null_Count
FROM 
    SDL_MDS_PACIFIC_CUST_ATTRB
UNPIVOT(value FOR column_name IN (
    ID, MUID, VERSIONNAME, VERSIONNUMBER, VERSION_ID, VERSIONFLAG, NAME, CODE, 
    CHANGETRACKINGMASK, SLS_ORG_CODE, SLS_ORG_NAME, SLS_ORG_ID, CMP_ID_CODE, 
    CMP_ID_NAME, CMP_ID_ID, DSTR_CHNL_CODE, DSTR_CHNL_NAME, DSTR_CHNL_ID, 
    SLS_OFC_CODE, SLS_OFC_NAME, SLS_OFC_ID, SLS_GRP_CODE, SLS_GRP_NAME, 
    SLS_GRP_ID, FCST_CHNL_CODE, FCST_CHNL_NAME, FCST_CHNL_ID, 
    CUSTOMER_SEGMENTATION_LEVEL_1_CODE, CUSTOMER_SEGMENTATION_LEVEL_1_NAME, 
    CUSTOMER_SEGMENTATION_LEVEL_1_ID, CUSTOMER_SEGMENTATION_LEVEL_2_CODE, 
    CUSTOMER_SEGMENTATION_LEVEL_2_NAME, CUSTOMER_SEGMENTATION_LEVEL_2_ID, 
    ACTIVE_STATUS_CODE, ACTIVE_STATUS_NAME, ACTIVE_STATUS_ID, ENTERDATETIME, 
    ENTERUSERNAME, ENTERVERSIONNUMBER, LASTCHGDATETIME, LASTCHGUSERNAME, 
    LASTCHGVERSIONNUMBER, VALIDATIONSTATUS
)) 
WHERE value IS NULL
GROUP BY column_name
UNION ALL
SELECT 
    'Duplicate IDs' AS Anomaly_Type,
    'ID' AS column_name,
    COUNT(ID) - COUNT(DISTINCT ID) AS Duplicate_Count
FROM 
    SDL_MDS_PACIFIC_CUST_ATTRB
WHERE ID IS NOT NULL
HAVING COUNT(ID) - COUNT(DISTINCT ID) > 0
UNION ALL
SELECT 
    'Data Type Mismatch' AS Anomaly_Type,
    column_name,
    COUNT(*) AS Mismatch_Count
FROM 
    SDL_MDS_PACIFIC_CUST_ATTRB
UNPIVOT(value FOR column_name IN (
    CHANGETRACKINGMASK, CMP_ID_ID, SLS_GRP_ID, VERSIONNUMBER, 
    ACTIVE_STATUS_ID, LASTCHGVERSIONNUMBER, CUSTOMER_SEGMENTATION_LEVEL_1_ID, 
    VERSION_ID, FCST_CHNL_ID, SLS_OFC_ID, ID, SLS_ORG_ID, 
    CUSTOMER_SEGMENTATION_LEVEL_2_ID
)) 
WHERE TRY_CAST(value AS NUMBER) IS NULL AND value IS NOT NULL
GROUP BY column_name
HAVING COUNT(*) > 0;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_COGS_MASTER
solution: Identify and handle negative COGS values, verify and correct data entry errors, and ensure consistent version tracking.
snowflake query: 
SELECT *
FROM SDL_MDS_PACIFIC_COGS_MASTER
WHERE nz_cogs_per_unit < 0 
   OR au_cogs_per_unit < 0 
   OR ENTERDATETIME > LASTCHGDATETIME 
   OR versionflag NOT IN ('Active', 'Inactive')
   OR validationstatus NOT IN ('Valid', 'Invalid')
   OR jj_year != sku_year;


This query is designed to identify anomalies such as negative costs, timestamps suggesting inconsistent data entry, invalid version flags and validation statuses, and mismatched year fields.
========================================================================================================================================

table_name: SDL_MDS_SG_PS_TARGETS
solution: Detect anomalies such as negative values in 'value' column, inconsistent 'versionflag' with 'validationstatus', and timestamps that are unexpectedly identical. Consider data validation rules and constraints to prevent such issues in the future.
snowflake query: 
    SELECT * 
    FROM SDL_MDS_SG_PS_TARGETS
    WHERE value < 0 
       OR (versionflag = 'inactive' AND validationstatus = 'Valid')
       OR (lastchgdatetime = enterdatetime);
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_RANKING_MONTHLY
solution: Handle non-numeric and extreme values in the 'RANKING' column by filtering or converting them. Ensure 'CATEGORY_DEPTH3' has valid entries.
snowflake query: 
SELECT *
FROM SDL_KR_COUPANG_PRODUCT_RANKING_MONTHLY
WHERE TRY_TO_NUMBER(RANKING) IS NULL 
   OR TRY_TO_NUMBER(RANKING) < 0 
   OR CATEGORY_DEPTH3 IS NULL;
========================================================================================================================================

sql
table_name : SDL_POP6_SG_DISPLAYS
solution : 
1. Ensure START_DATE is earlier than END_DATE.
2. Check for negative values in DISPLAY_NUMBER and RUN_ID.
3. Validate uniqueness for key fields such as DISPLAY_PLAN_ID.
4. Validate if CRTD_DTTM is consistent and within expected range.
snowflake query : 
SELECT * FROM SDL_POP6_SG_DISPLAYS
WHERE START_DATE >= END_DATE
   OR DISPLAY_NUMBER < 0
   OR RUN_ID < 0
   OR DISPLAY_PLAN_ID IN (
       SELECT DISPLAY_PLAN_ID
       FROM SDL_POP6_SG_DISPLAYS
       GROUP BY DISPLAY_PLAN_ID
       HAVING COUNT(*) > 1)
   OR CRTD_DTTM NOT BETWEEN '2023-01-01' AND '2023-12-31';
========================================================================================================================================

table_name: SDL_KR_COUPANG_BRAND_RANKING
solution: 
- Handle missing data in the 'ranking' column.
- Ensure 'rank_change' values are consistently formatted.
- Validate 'yearmo' format and data consistency within the date range.
- Verify 'run_id' for duplicates or unexpected values.

snowflake query:
SELECT * FROM SDL_KR_COUPANG_BRAND_RANKING
WHERE ranking IS NULL 
   OR NOT rank_change REGEXP '^[+-]?[0-9]+$'
   OR NOT yearmo REGEXP '^\d{6}$'
   OR run_id IN (SELECT run_id FROM SDL_KR_COUPANG_BRAND_RANKING GROUP BY run_id HAVING COUNT(run_id) > 1);
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCTSALEREPORT
solution: Identify negative values in columns where they should not occur and address invalid data types.
snowflake query: 
SELECT *
FROM SDL_KR_COUPANG_PRODUCTSALEREPORT
WHERE sales_gmv < 0
   OR cost_of_purchase < 0
   OR units_sold < 0
   OR TRY_TO_NUMBER(shipping_sales_gmv) IS NULL
   OR TRY_TO_NUMBER(shipping_weight_percent) IS NULL
   OR TRY_TO_NUMBER(sns_cogs) IS NULL
   OR TRY_TO_NUMBER(sns_units_sold) IS NULL;
========================================================================================================================================

table_name: KPI2DATA_MAPPING
solution: Detect negative values in the 'VALUE' column and ensure 'END_DATE' is greater than 'START_DATE'. Correct negative values if invalid and adjust dates as needed.
snowflake query: 
SELECT 
    * 
FROM 
    KPI2DATA_MAPPING 
WHERE 
    CAST(VALUE AS INTEGER) < 0 
    OR END_DATE <= START_DATE;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_IVY_USER_MASTER
solution: Check for negative run_id values, ensure consistent location names, check for duplicate entries, and validate date formats.
snowflake query: 
SELECT 
  * 
FROM 
  SDL_DISTRIBUTOR_IVY_USER_MASTER 
WHERE 
  run_id < 0 
  OR sd_location != rbdm_location 
  OR md_location != bdr_location 
  OR sd_name = bdm_name 
  OR cdl_dttm IS NULL 
  OR TRY_TO_TIMESTAMP(cdl_dttm) IS NULL 
  OR ROW_NUMBER() OVER (PARTITION BY md_code, sd_code, rbdm_code, bdm_code, bdr_code, dis_code, rsm_code, sup_code, sr_code ORDER BY cdl_dttm) > 1;
========================================================================================================================================

table_name: SDL_MY_CIW_MAP
solution: Identify rows with missing values in critical columns such as 'ciw_buckt1', 'ciw_buckt2', 'acct_type', and 'acct_desc'. Ensure data integrity by updating these fields with appropriate values or by investigating data sources for accuracy.

snowflake query: 
SELECT * 
FROM SDL_MY_CIW_MAP 
WHERE ciw_buckt1 IS NULL 
   OR ciw_buckt2 IS NULL 
   OR acct_type IS NULL 
   OR acct_desc IS NULL;


This solution and query aim to detect rows in the `SDL_MY_CIW_MAP` table where there are missing values in important columns, which might suggest data quality issues. The query can be enhanced further based on specific business logic or requirements for handling missing data.
========================================================================================================================================

table_name: SDL_MDS_VN_PS_WEIGHTS
solution: Anomalies include negative weights and possibly inconsistent versioning. Ensure weights are non-negative, and verify versioning logic for consistency.
snowflake_query: 
SELECT *
FROM SDL_MDS_VN_PS_WEIGHTS
WHERE WEIGHT < 0
   OR LASTCHGVERSIONNUMBER <> VERSIONNUMBER
   OR ENTERVERSIONNUMBER <> VERSIONNUMBER;
========================================================================================================================================

table_name: SDL_DSTR_COLES_INV
solution: 
1. Check for duplicate records based on unique identifiers (like `vendor`, `order_item`, etc.). 
2. Validate data types and correct them if necessary (e.g., convert `closing_soh_nic`, `closing_soh_qty_ctns`, and similar columns to numeric types). 
3. Identify and handle missing or NULL values.
4. Look for inconsistencies in related columns (e.g., if `closing_soh_nic`, `closing_soh_qty_ctns`, etc., should have the same values).
5. Ensure data integrity in `dc_state_shrt_desc` and `dc_state_desc` to map correctly.

snowflake query: 
sql
-- Check for duplicate records
WITH duplicate_check AS (
  SELECT vendor, order_item, COUNT(*) AS record_count
  FROM SDL_DSTR_COLES_INV
  GROUP BY vendor, order_item
  HAVING COUNT(*) > 1
)
SELECT * FROM duplicate_check;

-- Validate and convert data types
SELECT 
  TRY_TO_NUMBER(closing_soh_nic) AS closing_soh_nic_numeric,
  TRY_TO_NUMBER(closing_soh_qty_ctns) AS closing_soh_qty_ctns_numeric,
  TRY_TO_NUMBER(closing_soh_qty_octns) AS closing_soh_qty_octns_numeric,
  TRY_TO_NUMBER(closing_soh_qty_unit) AS closing_soh_qty_unit_numeric
FROM SDL_DSTR_COLES_INV;

-- Identify missing or NULL values
SELECT
  *
FROM SDL_DSTR_COLES_INV
WHERE 
  vendor IS NULL OR
  order_item IS NULL OR
  dc_state_shrt_desc IS NULL OR
  dc_state_desc IS NULL;

-- Check for inconsistencies in related columns
SELECT 
  vendor, order_item, closing_soh_nic, closing_soh_qty_ctns, closing_soh_qty_octns, closing_soh_qty_unit
FROM SDL_DSTR_COLES_INV
WHERE 
  closing_soh_nic != closing_soh_qty_ctns OR
  closing_soh_nic != closing_soh_qty_octns OR
  closing_soh_nic != closing_soh_qty_unit;

-- Ensure data integrity in state descriptions
SELECT 
  dc_state_shrt_desc, dc_state_desc, COUNT(*) AS record_count
FROM SDL_DSTR_COLES_INV
GROUP BY dc_state_shrt_desc, dc_state_desc
HAVING COUNT(DISTINCT dc_state_desc) > 1;
========================================================================================================================================

table_name: SDL_DISTRIBUTOR_CUSTOMER_DIM_ADFTEMP
solution: Identify and handle missing values, ensure data consistency, and validate postal codes.
snowflake query: 
SELECT 
    key_outlet,
    cust_id,
    address,
    postal_code
FROM 
    SDL_DISTRIBUTOR_CUSTOMER_DIM_ADFTEMP
WHERE 
    address IS NULL 
    OR cust_id IS NULL 
    OR jj_sap_dstrbtr_id IS NULL 
    OR postal_code IS NULL 
    OR NOT postal_code ~ '^[0-9]{5}$'
    OR crtd_dttm <> updt_dttm;
========================================================================================================================================

table_name: SDL_MDS_VN_ECOM_TARGET
solution: Detect negative version numbers and inconsistent timestamps. Ensure all timestamps are properly ordered and validate version numbers.
snowflake query: 
SELECT 
    id, muid, versionname, versionnumber, version_id, versionflag, name, code, 
    changetrackingmask, platform, cycle, target, enterdatetime, enterusername, 
    enterversionnumber, lastchgdatetime, lastchgusername, lastchgversionnumber, validationstatus
FROM 
    SDL_MDS_VN_ECOM_TARGET
WHERE 
    versionnumber < 0 
    OR enterdatetime > lastchgdatetime 
    OR enterversionnumber != versionnumber 
    OR lastchgversionnumber != versionnumber;
========================================================================================================================================

table_name: MRCHR_MERCHANDISINGRESPONSE
solution: Detect anomalies in temporal data, such as start and end times, and any status inconsistencies. Verify and correct mismatches or logical errors in start and end times, and ensure status consistency.
snowflake query: 
SELECT 
    *,
    CASE 
        WHEN TO_TIMESTAMP(STARTDATE || ' ' || STARTTIME) > TO_TIMESTAMP(ENDDATE || ' ' || ENDTIME) THEN 'Start time is after end time'
        WHEN STATUS NOT IN ('Completed', 'Pending', 'Rejected') THEN 'Invalid status'
        WHEN CDL_DATETIME != AZUREDATETIME OR CDL_DATETIME != FETCHEDDATETIME THEN 'Datetime mismatch'
        ELSE 'No anomaly'
    END AS anomaly
FROM MRCHR_MERCHANDISINGRESPONSE;
========================================================================================================================================

table_name: SDL_MDS_VN_TOPDOOR_STORETYPE_MAPPING
solution: Detect rows where the changetrackingmask has negative values, and verify if these are expected or need correction. Additionally, check for any inconsistencies in active/inactive status versus version numbers and ensure proper validation status.
snowflake query: 
SELECT 
    *,
    CASE WHEN changetrackingmask < 0 THEN 'Negative changetrackingmask' END AS anomaly_changetrackingmask,
    CASE WHEN versionflag = 'active' AND validationstatus = 'Invalid' THEN 'Active with Invalid status' END AS anomaly_active_invalid_status,
    CASE WHEN versionflag = 'inactive' AND validationstatus = 'Valid' THEN 'Inactive with Valid status' END AS anomaly_inactive_valid_status
FROM 
    SDL_MDS_VN_TOPDOOR_STORETYPE_MAPPING
WHERE 
    changetrackingmask < 0 
    OR (versionflag = 'active' AND validationstatus = 'Invalid')
    OR (versionflag = 'inactive' AND validationstatus = 'Valid');
========================================================================================================================================

table_name : SDL_KR_COUPANG_PRODUCT_RANKING_WEEKLY
solution : Verify data types and consistency in data entries. Ensure columns are populated correctly and align with their types. Address missing values and incorrect types.
snowflake query : 
SELECT 
    COUNT(*) AS total_records,
    SUM(CASE WHEN FILE_NAME IS NULL OR FILE_NAME = '' THEN 1 ELSE 0 END) AS missing_file_name,
    SUM(CASE WHEN CATEGORY_DEPTH1 IS NULL OR CATEGORY_DEPTH1 = '' THEN 1 ELSE 0 END) AS missing_category_depth1,
    SUM(CASE WHEN CATEGORY_DEPTH2 IS NULL OR CATEGORY_DEPTH2 = '' THEN 1 ELSE 0 END) AS missing_category_depth2,
    SUM(CASE WHEN CATEGORY_DEPTH3 IS NULL OR CATEGORY_DEPTH3 = '' THEN 1 ELSE 0 END) AS missing_category_depth3,
    SUM(CASE WHEN COUPANG_SKU_ID IS NULL OR COUPANG_SKU_ID = '' THEN 1 ELSE 0 END) AS missing_coupang_sku_id,
    SUM(CASE WHEN COUPANG_SKU_NAME IS NULL OR COUPANG_SKU_NAME = '' THEN 1 ELSE 0 END) AS missing_coupang_sku_name,
    SUM(CASE WHEN RANKING IS NULL OR RANKING = '' THEN 1 ELSE 0 END) AS missing_ranking,
    SUM(CASE WHEN PRODUCT_RANKING_DATE IS NULL OR PRODUCT_RANKING_DATE = '' THEN 1 ELSE 0 END) AS missing_product_ranking_date,
    SUM(CASE WHEN YEARMO IS NULL OR YEARMO = '' THEN 1 ELSE 0 END) AS missing_yearmo,
    SUM(CASE WHEN DATA_GRANULARITY IS NULL OR DATA_GRANULARITY = '' THEN 1 ELSE 0 END) AS missing_data_granularity
FROM SDL_KR_COUPANG_PRODUCT_RANKING_WEEKLY
WHERE 
    TRY_CAST(RUN_ID AS NUMBER) IS NULL
    OR TRY_CAST(RANKING AS NUMBER) IS NULL;
========================================================================================================================================

table_name: SDL_MDS_VN_ALLCHANNEL_SISO_TARGET_SKU
solution: Check for null or empty values in critical columns and ensure data type consistency. Validate unique constraints where applicable.

snowflake query: 
SELECT 
    *
FROM 
    SDL_MDS_VN_ALLCHANNEL_SISO_TARGET_SKU
WHERE 
    ID IS NULL OR
    MUID IS NULL OR
    VERSIONNAME IS NULL OR
    VERSIONNUMBER IS NULL OR
    NAME IS NULL OR
    CODE IS NULL OR
    -- Add any other critical columns that should not be null 
    (CAST(DESCRIPTION AS TEXT) IS NULL) OR
    (CAST("dksh - mti" AS NUMBER) IS NULL) OR
    -- Check if data types meet the expected formats
    (CAST("dksh - ecom" AS NUMBER) IS NULL) OR
    (CAST(MTD AS NUMBER) IS NULL) OR
    -- Additional data type checks as needed
    (CAST(ENTERDATETIME AS TIMESTAMP_NTZ) IS NULL) OR
    (CAST(LASTCHGDATETIME AS TIMESTAMP_NTZ) IS NULL);



This query will help identify records with anomalies such as null values in critical columns and data type inconsistencies. Adjust the query to include any additional checks specific to your dataset requirements.
========================================================================================================================================

table_name: SDL_POP6_SG_PRODUCT_LISTS_PRODUCTS
solution: Detect anomalies in 'run_id', 'msl_ranking', and potential date issues. Address negative or unusually large 'run_id' values, non-numeric 'msl_ranking', and ensure date fields are valid and within expected range.
snowflake query: 
SELECT * 
FROM SDL_POP6_SG_PRODUCT_LISTS_PRODUCTS
WHERE 
    run_id < 0 
    OR run_id > 999999999999 
    OR TRY_TO_NUMBER(msl_ranking) IS NULL 
    OR prod_grp_date IS NULL 
    OR prod_grp_date > CURRENT_DATE()
    OR crtd_dttm IS NULL;
========================================================================================================================================

table_name: SDL_MDS_SG_STORE_MASTER
solution: Identify negative or unrealistic changetrackingmask values and ensure version consistency.
snowflake query: 
SELECT 
    id, 
    muid, 
    changetrackingmask,
    versionnumber,
    enterversionnumber,
    lastchgversionnumber 
FROM 
    SDL_MDS_SG_STORE_MASTER 
WHERE 
    changetrackingmask < 0 
    OR versionnumber <> enterversionnumber 
    OR versionnumber <> lastchgversionnumber;
========================================================================================================================================

table_name : SDL_ECOMMERCE_OFFTAKE_AMAZON

solution : 
1. Address negative or zero 'quantity' and 'mrp_offtakes_value' by verifying data integrity and correcting data at source.
2. Ensure 'quantity' aligns with expected business logic (e.g., cannot be negative).
3. Validate and cleanse the 'month' field to ensure it matches the 'load_date'.

snowflake query : 
SELECT 
    * 
FROM 
    SDL_ECOMMERCE_OFFTAKE_AMAZON
WHERE 
    quantity <= 0 
    OR mrp_offtakes_value <= 0 
    OR (month NOT IN ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'));
========================================================================================================================================

sql
table_name: SDL_KR_COUPANG_DAILY_BRAND_REVIEWS

solution: 
1. Review scores should be integers within a valid range (e.g., 1-5).
2. Ensure 'review_date' is a valid date and within an expected range.
3. Check for duplicate reviews based on a combination of 'review_date', 'brand', and 'coupang_sku_id'.
4. Validate 'yearmo' format and consistency with 'review_date'.
5. Ensure 'data_granularity' is consistent and correct.

snowflake query: 
SELECT
    review_date,
    brand,
    coupang_sku_id,
    review_score_star,
    yearmo,
    data_granularity
FROM SDL_KR_COUPANG_DAILY_BRAND_REVIEWS
WHERE 
    NOT TRY_TO_NUMBER(review_score_star) BETWEEN 1 AND 5 OR
    NOT TRY_TO_DATE(review_date, 'YYYY-MM-DD') IS NOT NULL OR
    NOT TRY_TO_DATE(review_date, 'YYYY-MM-DD') BETWEEN '2023-01-01' AND CURRENT_DATE() OR
    (yearmo <> TO_CHAR(TRY_TO_DATE(review_date, 'YYYY-MM-DD'), 'YYYYMM')) OR
    (data_granularity <> 'daily') OR
    (SELECT COUNT(*) FROM SDL_KR_COUPANG_DAILY_BRAND_REVIEWS t2 WHERE 
     t2.review_date = SDL_KR_COUPANG_DAILY_BRAND_REVIEWS.review_date AND 
     t2.brand = SDL_KR_COUPANG_DAILY_BRAND_REVIEWS.brand AND 
     t2.coupang_sku_id = SDL_KR_COUPANG_DAILY_BRAND_REVIEWS.coupang_sku_id) > 1;
========================================================================================================================================

table_name: SDL_LA_GT_VISIT
solution: 
1. Check for negative or unusually high 'count_survey' values.
2. Identify inconsistent 'time_survey_in' and 'time_survey_out' where out is before in.
3. Detect missing 'id_customer' and 'regioncode'.

snowflake query:
SELECT 
  ID_SALE, SALE_NAME, ID_CUSTOMER, CUSTOMER_NAME, COUNT_SURVEY, TIME_SURVEY_IN, TIME_SURVEY_OUT, REGIONCODE 
FROM 
  SDL_LA_GT_VISIT
WHERE 
  TRY_TO_NUMBER(COUNT_SURVEY) <= 0 
  OR TRY_TO_NUMBER(COUNT_SURVEY) > 1000
  OR TIME_SURVEY_OUT < TIME_SURVEY_IN
  OR ID_CUSTOMER IS NULL
  OR REGIONCODE IS NULL;
========================================================================================================================================

table_name: SDL_MDS_MY_PS_WEIGHTS
solution: Ensure weights are non-negative and validation status aligns with active version flags.
snowflake query: 
SELECT 
    ID, MUID, VERSIONNAME, VERSIONNUMBER, WEIGHT, VALIDATIONSTATUS, VERSIONFLAG
FROM 
    SDL_MDS_MY_PS_WEIGHTS
WHERE 
    WEIGHT < 0 
    OR (VALIDATIONSTATUS = 'Invalid' AND VERSIONFLAG = 'active');
========================================================================================================================================

table_name: SDL_MDS_APAC_DCL_CUSTOMERS
solution: Check for missing or null values, duplicate records, and unexpected data types. Implement constraints or update records as needed.
snowflake_query: 
SELECT * 
FROM SDL_MDS_APAC_DCL_CUSTOMERS
WHERE 
  ID IS NULL OR
  LOCATION_NAME IS NULL OR
  SALES_CHANNEL_ID IS NULL OR
  SALES_LOCATION_CODE IS NULL OR
  MUID IS NULL OR
  NAME IS NULL OR
  RETAILER_NAME_CODE IS NULL OR
  CTRY_KEY_ID IS NULL OR
  VERSIONFLAG IS NULL OR
  CODE IS NULL OR
  ENTERUSERNAME IS NULL OR
  REMARKS IS NULL OR
  VALIDATIONSTATUS IS NULL OR
  VERSIONNUMBER IS NULL OR
  ENTERDATETIME IS NULL OR
  SALES_CHANNEL_NAME IS NULL OR
  SALES_LOCATION_NAME IS NULL OR
  VERSION_ID IS NULL OR
  LASTCHGVERSIONNUMBER IS NULL OR
  SALES_LOCATION_ID IS NULL OR
  CUST_NUM IS NULL OR
  CTRY_KEY_CODE IS NULL OR
  CHANGETRACKINGMASK IS NULL OR
  RETAILER_NAME_ID IS NULL OR
  SALES_CHANNEL_CODE IS NULL OR
  ENTERVERSIONNUMBER IS NULL OR
  VERSIONNAME IS NULL OR
  CTRY_KEY_NAME IS NULL OR
  LASTCHGDATETIME IS NULL OR
  RETAILER_NAME_NAME IS NULL OR
  LASTCHGUSERNAME IS NULL
UNION ALL
SELECT ID, LOCATION_NAME, SALES_CHANNEL_ID, SALES_LOCATION_CODE, MUID, NAME, RETAILER_NAME_CODE, CTRY_KEY_ID, VERSIONFLAG, CODE, ENTERUSERNAME, REMARKS, VALIDATIONSTATUS, VERSIONNUMBER, ENTERDATETIME, SALES_CHANNEL_NAME, SALES_LOCATION_NAME, VERSION_ID, LASTCHGVERSIONNUMBER, SALES_LOCATION_ID, CUST_NUM, CTRY_KEY_CODE, CHANGETRACKINGMASK, RETAILER_NAME_ID, SALES_CHANNEL_CODE, ENTERVERSIONNUMBER, VERSIONNAME, CTRY_KEY_NAME, LASTCHGDATETIME, RETAILER_NAME_NAME, LASTCHGUSERNAME
FROM SDL_MDS_APAC_DCL_CUSTOMERS
GROUP BY ID, LOCATION_NAME, SALES_CHANNEL_ID, SALES_LOCATION_CODE, MUID, NAME, RETAILER_NAME_CODE, CTRY_KEY_ID, VERSIONFLAG, CODE, ENTERUSERNAME, REMARKS, VALIDATIONSTATUS, VERSIONNUMBER, ENTERDATETIME, SALES_CHANNEL_NAME, SALES_LOCATION_NAME, VERSION_ID, LASTCHGVERSIONNUMBER, SALES_LOCATION_ID, CUST_NUM, CTRY_KEY_CODE, CHANGETRACKINGMASK, RETAILER_NAME_ID, SALES_CHANNEL_CODE, ENTERVERSIONNUMBER, VERSIONNAME, CTRY_KEY_NAME, LASTCHGDATETIME, RETAILER_NAME_NAME, LASTCHGUSERNAME
HAVING COUNT(*) > 1;
========================================================================================================================================

table_name: SDL_JNJ_CONSUMERREACH_SFM
solution: Validate and correct data types, ensure valid date formats, and handle negative distribution values appropriately.
snowflake_query: 
SELECT 
    * 
FROM 
    SDL_JNJ_CONSUMERREACH_SFM
WHERE 
    TRY_TO_DATE(CDATE, 'YYYY-MM-DD') IS NULL 
    OR TRY_TO_NUMBER(DISTRIBUTION) < 0 
    OR TRY_TO_NUMBER(YEARMO) IS NULL;
========================================================================================================================================

table_name: SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT
solution: Identify missing data, duplicates, and outliers. Handle missing data by inserting default values or removing incomplete records. Remove duplicates. Investigate and address outliers.
snowflake query: 
WITH MissingData AS (
    SELECT *
    FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT
    WHERE SLS_TRGT_VAL IS NULL OR SLS_REP_CD IS NULL OR BRAND IS NULL OR SLS_REP_NM IS NULL OR JJ_MNTH_ID IS NULL
),
DuplicateData AS (
    SELECT SLS_REP_CD, JJ_MNTH_ID, COUNT(*) AS cnt
    FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT
    GROUP BY SLS_REP_CD, JJ_MNTH_ID
    HAVING cnt > 1
),
Outliers AS (
    SELECT *
    FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT
    WHERE SLS_TRGT_VAL > (SELECT AVG(SLS_TRGT_VAL) + 3 * STDDEV(SLS_TRGT_VAL) FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT)
       OR SLS_TRGT_VAL < (SELECT AVG(SLS_TRGT_VAL) - 3 * STDDEV(SLS_TRGT_VAL) FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT)
)
SELECT 'Missing Data' AS AnomalyType, * FROM MissingData
UNION ALL
SELECT 'Duplicate Data' AS AnomalyType, * FROM SDL_HK_WINGKEUNG_SALES_REP_SO_TGT_FACT
WHERE (SLS_REP_CD, JJ_MNTH_ID) IN (SELECT SLS_REP_CD, JJ_MNTH_ID FROM DuplicateData)
UNION ALL
SELECT 'Outliers' AS AnomalyType, * FROM Outliers;
========================================================================================================================================

table_name: SDL_MDS_LOG
solution: Identify and resolve logic errors in queries, ensure data integrity, and handle NULL values appropriately.
snowflake query: 
SELECT 
    JOB_NAME, 
    STATUS, 
    RESULT, 
    QUERY, 
    CRTD_DTTM 
FROM 
    SDL_MDS_LOG 
WHERE 
    STATUS = 'Failed' OR 
    RESULT LIKE '%error%' OR 
    QUERY LIKE '%NULL%' OR 
    QUERY LIKE '%> end_date%' OR 
    QUERY LIKE '%duplicate%' OR 
    QUERY LIKE '%year = 10000%' OR 
    QUERY LIKE '%weight < 0%';
========================================================================================================================================

table_name: SDL_ID_POS_CARREFOUR_SELLOUT
solution: Identify anomalies concerning negative sales quantities and sales amounts, duplicate entries, and missing essential fields.
snowflake_query: 
SELECT 
    run_id, 
    pos_cust, 
    yearmonth, 
    sales_qty, 
    net_sales, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_ID_POS_CARREFOUR_SELLOUT
GROUP BY 
    run_id, 
    pos_cust, 
    yearmonth, 
    sales_qty, 
    net_sales
HAVING 
    sales_qty < 0 OR 
    net_sales < 0 OR 
    duplicate_count > 1 OR
    pos_cust IS NULL OR 
    yearmonth IS NULL;
========================================================================================================================================

table_name : SDL_MDS_VN_ECOM_PRODUCT  
solution : Identify and address the anomalies in the data, such as invalid version numbers and duplicate records.  
snowflake query :  
SELECT *  
FROM SDL_MDS_VN_ECOM_PRODUCT  
WHERE versionnumber < 0 OR versionnumber > 99999  
   OR version_id < 0  
   OR (id, muid) IN (SELECT id, muid FROM SDL_MDS_VN_ECOM_PRODUCT GROUP BY id, muid HAVING COUNT(*) > 1);
========================================================================================================================================

sql
table_name: SDL_MDS_VN_DISTRIBUTOR_CUSTOMERS
solution: Address issues with negative or inconsistent IDs and mismatched version fields. Ensure data consistency and integrity by setting proper constraints and data validation rules.
snowflake_query: 
SELECT * FROM SDL_MDS_VN_DISTRIBUTOR_CUSTOMERS
WHERE id < 0
   OR muid IS NULL
   OR version_id < 0
   OR changetrackingmask IS NULL
   OR sub_channel_code IS NULL
   OR region_id IS NULL
   OR province_id < 0
   OR lastchgversionnumber IS NULL
   OR validationstatus IS NULL;
========================================================================================================================================

table_name: SDL_MDS_PH_ISE_PARENT
solution: Identify potential issues such as missing or inconsistent data, outliers, or other anomalies in the table to ensure data integrity and accuracy. Implement checks for null values, duplicates, and incorrect data types.

snowflake query: 
SELECT
    -- Check for NULL values in critical columns
    COUNT(*) AS null_count,
    'MUID' AS column_name
FROM
    SDL_MDS_PH_ISE_PARENT
WHERE
    MUID IS NULL

UNION ALL

SELECT
    COUNT(*) AS null_count,
    'VERSIONNAME' AS column_name
FROM
    SDL_MDS_PH_ISE_PARENT
WHERE
    VERSIONNAME IS NULL

UNION ALL

-- Check for duplicates based on a composite key (e.g., ID and VERSIONNUMBER)
SELECT
    ID,
    VERSIONNUMBER,
    COUNT(*) AS duplicate_count
FROM
    SDL_MDS_PH_ISE_PARENT
GROUP BY
    ID,
    VERSIONNUMBER
HAVING
    COUNT(*) > 1

UNION ALL

-- Check for incorrect data types or outliers if applicable
SELECT
    COUNT(*) AS invalid_soldtocode_id_count,
    'SOLDTOCODE_ID' AS column_name
FROM
    SDL_MDS_PH_ISE_PARENT
WHERE
    SOLDTOCODE_ID < 0  -- Assuming IDs should be non-negative

UNION ALL

-- Additional checks can be implemented as needed based on specific business rules or data quality criteria.
SELECT
    COUNT(*) AS validationstatus_count,
    'VALIDATIONSTATUS' AS column_name
FROM
    SDL_MDS_PH_ISE_PARENT
WHERE
    VALIDATIONSTATUS NOT IN ('VALID', 'INVALID'); -- Example of a business rule validation
========================================================================================================================================

Certainly. Here is the solution based on the provided table information:


table_name: SDL_HK_IMS_WINGKEUNG_INV
solution: Identify and handle negative values in the 'closing' and 'amount' columns, which may indicate data entry errors or specific business scenarios requiring review.
snowflake query: 
SELECT *
FROM SDL_HK_IMS_WINGKEUNG_INV
WHERE closing < 0 OR amount < 0;


This query will help identify rows where the 'closing' or 'amount' values are negative, allowing further investigation or correction based on business rules.
========================================================================================================================================

table_name: SDL_MDS_VN_GT_GTS_RATIO
solution: Identify and address anomalies in the 'percentage' column, which has unusually high values, and ensure the 'validationstatus' accurately reflects data integrity. Review 'from month' and 'to month' for logical consistency.
snowflake query: 
SELECT 
    id, 
    muid, 
    versionname, 
    versionnumber, 
    version_id, 
    versionflag, 
    name, 
    code, 
    changetrackingmask, 
    distributor, 
    "from month", 
    "to month", 
    percentage, 
    enterdatetime, 
    enterusername, 
    enterversionnumber, 
    lastchgdatetime, 
    lastchgusername, 
    lastchgversionnumber, 
    validationstatus
FROM 
    SDL_MDS_VN_GT_GTS_RATIO
WHERE 
    percentage > 100 OR
    "from month" > "to month" OR
    validationstatus = 'Invalid';
========================================================================================================================================

table_name: SDL_IRI_SCAN_SALES
solution: Detect negative values in `scan_sales`, `scan_units`, `numeric_distribution`, `weighted_distribution`, and `store_count_where_scanned`. Ensure values are within realistic ranges. Implement checks or validations to prevent invalid entries.

snowflake query: 
SELECT 
    IRI_MARKET,
    WK_END_DT,
    IRI_PROD_DESC,
    IRI_EAN,
    SCAN_SALES,
    SCAN_UNITS,
    NUMERIC_DISTRIBUTION,
    WEIGHTED_DISTRIBUTION,
    STORE_COUNT_WHERE_SCANNED,
    AC_NIELSENCODE,
    CRTD_DTTM,
    FILENAME
FROM 
    SDL_IRI_SCAN_SALES
WHERE 
    SCAN_SALES < 0
    OR SCAN_UNITS < 0
    OR NUMERIC_DISTRIBUTION < 0
    OR WEIGHTED_DISTRIBUTION < 0
    OR STORE_COUNT_WHERE_SCANNED < 0;
========================================================================================================================================

table_name: SDL_KR_COUPANG_PRODUCT_RANKING_DAILY
solution: 
  1. Ensure 'category_depth2' is not NULL when 'category_depth3' is populated.
  2. Ensure 'data_granularity' is consistent (e.g., 'Daily' should match with daily dates).
snowflake query: 
  SELECT * 
  FROM SDL_KR_COUPANG_PRODUCT_RANKING_DAILY 
  WHERE (category_depth2 IS NULL AND category_depth3 IS NOT NULL)
     OR (data_granularity = 'Daily' AND product_ranking_date NOT LIKE '____-__-__');
========================================================================================================================================

table_name: SDL_COMPETITIVE_BANNER_GROUP
solution: The 'unit' and 'dollar' columns should be numeric. Convert these columns to appropriate numeric types to avoid data type inconsistencies. Check for duplicate records and missing values to ensure data integrity.
snowflake query: 
-- Convert 'unit' and 'dollar' to numeric and check for anomalies
SELECT 
    *,
    TRY_TO_NUMBER(unit) AS unit_numeric,
    TRY_TO_NUMBER(dollar) AS dollar_numeric
FROM 
    SDL_COMPETITIVE_BANNER_GROUP
WHERE 
    TRY_TO_NUMBER(unit) IS NULL 
    OR TRY_TO_NUMBER(dollar) IS NULL
    OR (BANNER, SKU_NAME, APN, MARKET, BANNER_CLASSIFICATION, BRAND, TIME_PERIOD, DOLLAR, UNIT, FILE_NAME, MANUFACTURER) 
       IN (
           SELECT BANNER, SKU_NAME, APN, MARKET, BANNER_CLASSIFICATION, BRAND, TIME_PERIOD, DOLLAR, UNIT, FILE_NAME, MANUFACTURER
           FROM SDL_COMPETITIVE_BANNER_GROUP
           GROUP BY BANNER, SKU_NAME, APN, MARKET, BANNER_CLASSIFICATION, BRAND, TIME_PERIOD, DOLLAR, UNIT, FILE_NAME, MANUFACTURER
           HAVING COUNT(*) > 1
       );
========================================================================================================================================

table_name: SDL_MDS_APAC_DCL_PRODUCTS
solution: Detect anomalies such as duplicate entries, invalid country codes, incorrect SRP values, and mismatched version flags.
snowflake query: 
SELECT 
    id, 
    muid, 
    versionname, 
    versionnumber, 
    version_id, 
    name, 
    code, 
    country_code, 
    srp_usd, 
    versionflag,
    validationstatus
FROM SDL_MDS_APAC_DCL_PRODUCTS 
WHERE 
    (id, versionnumber) IN (
        SELECT id, versionnumber 
        FROM SDL_MDS_APAC_DCL_PRODUCTS 
        GROUP BY id, versionnumber 
        HAVING COUNT(*) > 1
    )
    OR country_code NOT IN ('CA', 'ZA', 'BD') 
    OR srp_usd <= 0 
    OR versionflag NOT IN ('release', 'alpha', 'beta') 
    OR validationstatus NOT IN ('Approved', 'Pending', 'Rejected');
========================================================================================================================================

table_name: SDL_LA_GT_ROUTE_DETAIL
solution: Identify and handle duplicate hashkey values which could indicate duplicate records. Ensure unique hashkey constraints or use a deduplication process.
snowflake query: 
SELECT HASHKEY, COUNT(*)
FROM SDL_LA_GT_ROUTE_DETAIL
GROUP BY HASHKEY
HAVING COUNT(*) > 1;

solution: Check for missing or null values in critical fields such as CUSTOMER_ID, ROUTE_ID, ROUTE_NO, etc., and ensure data integrity.
snowflake query: 
SELECT *
FROM SDL_LA_GT_ROUTE_DETAIL
WHERE CUSTOMER_ID IS NULL 
   OR ROUTE_ID IS NULL 
   OR ROUTE_NO IS NULL;

solution: Validate date fields and ensure consistency, especially CREATED_DATE should be before or equal to FILE_UPLOAD_DATE.
snowflake query: 
SELECT *
FROM SDL_LA_GT_ROUTE_DETAIL
WHERE CREATED_DATE > FILE_UPLOAD_DATE;
========================================================================================================================================

table_name : SDL_MDS_PH_NPI_PEG_ITEM
solution : Check for duplicate entries and inconsistent data by comparing similar columns such as VERSIONNUMBER and LASTCHGVERSIONNUMBER. Ensure timestamps are correctly formatted and in the expected range.
snowflake query : 
SELECT 
    ID, 
    MUID, 
    VERSIONNUMBER, 
    LASTCHGVERSIONNUMBER,
    CASE 
        WHEN VERSIONNUMBER != LASTCHGVERSIONNUMBER THEN 'Inconsistent Version Numbers'
        ELSE 'Consistent'
    END AS VERSION_CHECK,
    ENTERDATETIME, 
    LASTCHGDATETIME,
    CASE 
        WHEN ENTERDATETIME > CURRENT_TIMESTAMP() OR LASTCHGDATETIME > CURRENT_TIMESTAMP() THEN 'Future Timestamp Detected'
        ELSE 'Timestamp Valid'
    END AS TIMESTAMP_CHECK
FROM 
    SDL_MDS_PH_NPI_PEG_ITEM
GROUP BY 
    ID, 
    MUID, 
    VERSIONNUMBER, 
    LASTCHGVERSIONNUMBER, 
    ENTERDATETIME, 
    LASTCHGDATETIME
HAVING 
    COUNT(*) > 1 OR VERSION_CHECK = 'Inconsistent Version Numbers' OR TIMESTAMP_CHECK = 'Future Timestamp Detected';
========================================================================================================================================

table_name: SDL_MDS_MY_GT_OUTLETATTRIBUTES
solution: 
1. Ensure 'version_id' is always positive or consistent with 'versionnumber'.
2. Validate 'changetrackingmask' for negative values.
3. Check 'cust_year' for unrealistic future years like '9999'.
4. Ensure 'code' and 'customer_code' are not NULL.
5. Ensure 'validationstatus' aligns with the business process and correct invalid statuses.

snowflake query: 
SELECT * 
FROM SDL_MDS_MY_GT_OUTLETATTRIBUTES
WHERE version_id < 0
   OR changetrackingmask < 0
   OR cust_year = '9999'
   OR code IS NULL
   OR customer_code IS NULL
   OR validationstatus NOT IN ('Approved', 'Pending', 'Rejected');
========================================================================================================================================

table_name : SDL_MDS_VN_PS_STORE_TAGGING  
solution : Ensure unique entries for store_code, store_name, and code to avoid duplication. Validate status and validationstatus for consistency.  
snowflake query :  
SELECT  
    store_code,  
    COUNT(*) AS count  
FROM  
    SDL_MDS_VN_PS_STORE_TAGGING  
GROUP BY  
    store_code  
HAVING  
    COUNT(*) > 1;  

SELECT  
    store_name,  
    COUNT(*) AS count  
FROM  
    SDL_MDS_VN_PS_STORE_TAGGING  
GROUP BY  
    store_name  
HAVING  
    COUNT(*) > 1;  

SELECT  
    code,  
    COUNT(*) AS count  
FROM  
    SDL_MDS_VN_PS_STORE_TAGGING  
GROUP BY  
    code  
HAVING  
    COUNT(*) > 1;  

SELECT  
    *  
FROM  
    SDL_MDS_VN_PS_STORE_TAGGING  
WHERE  
    status NOT IN ('Active', 'Inactive', 'Unknown');  

SELECT  
    *  
FROM  
    SDL_MDS_VN_PS_STORE_TAGGING  
WHERE  
    validationstatus NOT IN ('Validated', 'Not Validated', 'Unknown');
========================================================================================================================================

table_name: SDL_CSL_DISTRIBUTORACTIVATION
solution: 
1. Check for records with NULL values in critical columns like `DISTCODE`, `ACTIVEFROMDATE`, `ACTIVESTATUS`.
2. Ensure `ACTIVATEDON` and `INACTIVATEDON` are not earlier than `ACTIVEFROMDATE` or `INACTIVEFROMDATE`.
3. Verify `ACTIVESTATUS` is consistent with dates (e.g., active records should not have an `INACTIVEFROMDATE`).
4. Validate `FILE_NAME` matches expected patterns or formats.

snowflake query: 
SELECT * 
FROM SDL_CSL_DISTRIBUTORACTIVATION
WHERE DISTCODE IS NULL 
   OR ACTIVEFROMDATE IS NULL 
   OR ACTIVESTATUS IS NULL 
   OR (ACTIVATEDON < ACTIVEFROMDATE)
   OR (INACTIVATEDON < INACTIVEFROMDATE)
   OR (ACTIVESTATUS = 1 AND INACTIVEFROMDATE IS NOT NULL)
   OR NOT REGEXP_LIKE(FILE_NAME, 'expected_pattern');
========================================================================================================================================

table_name: SDL_FPA_PROFIT_CENTER_MAPPING
solution: Identify columns with similar names but different purposes, and ensure consistent naming. Check for inconsistent data types and inappropriate data entries.
snowflake_query: 
SELECT 
    dimension, 
    rulegroupname, 
    rule_type, 
    rulename_sourcevalue, 
    rule_description, 
    rule_expression, 
    target_value, 
    logical_operator, 
    logical_operator_name, 
    logical_expression, 
    derivative_type_name, 
    execution_order
FROM 
    SDL_FPA_PROFIT_CENTER_MAPPING
WHERE 
    execution_order NOT LIKE 'Order%'
    OR rule_type NOT IN ('TypeD', 'TypeAA', 'TypeQQ')
    OR logical_operator NOT IN ('AND', 'OR', 'NOT');


This query checks for inconsistent entries by verifying the format and expected values for specific columns. Adjustments should be made to align data with business rules and naming conventions.
========================================================================================================================================

table_name: SDL_JNJ_MER_SHARE_OF_SHELF
solution: Detect anomalies in the YEARMO format and missing MERCHANDISER_NAME.
snowflake query: 
WITH anomalies AS (
    SELECT 
        *,
        CASE 
            WHEN LENGTH(YEARMO) <> 6 OR NOT REGEXP_LIKE(YEARMO, '^[0-9]{6}$') THEN 'Invalid YEARMO format'
            ELSE NULL 
        END AS yearmo_anomaly,
        CASE 
            WHEN MERCHANDISER_NAME IS NULL THEN 'Missing MERCHANDISER_NAME'
            ELSE NULL 
        END AS merchandiser_anomaly
    FROM SDL_JNJ_MER_SHARE_OF_SHELF
)
SELECT *
FROM anomalies
WHERE yearmo_anomaly IS NOT NULL OR merchandiser_anomaly IS NOT NULL;
========================================================================================================================================

table_name: SDL_ECOM_CPAS
solution: Identify and handle negative spending values as they are likely data entry errors.
snowflake query: 
SELECT * 
FROM SDL_ECOM_CPAS 
WHERE SPENDING < 0;
========================================================================================================================================

sql
table_name: SDL_LA_GT_ROUTE_HEADER_TEMP
solution: 
1. Check for routes where `routesale` is less than `saleunit`. 
2. Identify missing `description` and `filename`.
3. Flag inactive routes (`is_active` = 'no') for review.
snowflake query: 
SELECT *
FROM SDL_LA_GT_ROUTE_HEADER_TEMP
WHERE 
    TRY_TO_NUMERIC(routesale) < TRY_TO_NUMERIC(saleunit)
    OR description IS NULL
    OR filename IS NULL
    OR is_active = 'no';
========================================================================================================================================

table_name: SDL_ALL_DISTRIBUTOR_SELLIN_SALES_FACT
solution: Detect anomalies such as duplicated records, discrepancies in 'qty' and 'numerator', and unusual 'net_val' values. Ensure data integrity and consistency.
snowflake query:
SELECT 
    bill_doc, 
    COUNT(*) AS duplicate_count
FROM 
    SDL_ALL_DISTRIBUTOR_SELLIN_SALES_FACT
GROUP BY 
    bill_doc
HAVING 
    COUNT(*) > 1;

SELECT 
    bill_doc, 
    qty, 
    numerator
FROM 
    SDL_ALL_DISTRIBUTOR_SELLIN_SALES_FACT
WHERE 
    qty != numerator;

SELECT 
    bill_doc, 
    net_val
FROM 
    SDL_ALL_DISTRIBUTOR_SELLIN_SALES_FACT
WHERE 
    net_val < 0 OR net_val > 10000;  -- Assuming a threshold for unusual net values
========================================================================================================================================

sql
table_name: SDL_MY_DSTRBTRR_DIM
solution: Check for missing, duplicate, and inconsistent data entries.
snowflake query: 
WITH Anomalies AS (
    SELECT 
        CUST_ID, 
        COUNT(*) AS record_count,
        COUNT(DISTINCT CUST_ID) OVER() AS unique_customers,
        COUNT(DISTINCT LOCATION_GLN) OVER() AS unique_locations,
        COUNT(DISTINCT BUYER_GLN) OVER() AS unique_buyers,
        COUNT(*) FILTER (WHERE CUST_ID IS NULL OR CUST_NM IS NULL OR LVL1 IS NULL OR LVL2 IS NULL OR LVL3 IS NULL OR LVL4 IS NULL OR LVL5 IS NULL OR TRDNG_TERM_VAL IS NULL OR ABBREVATION IS NULL OR BUYER_GLN IS NULL OR LOCATION_GLN IS NULL OR CHNL_MANAGER IS NULL OR CDM IS NULL OR REGION IS NULL OR CDL_DTTM IS NULL OR FILE_NAME IS NULL) AS missing_values
    FROM 
        SDL_MY_DSTRBTRR_DIM
    GROUP BY 
        CUST_ID
)
SELECT 
    * 
FROM 
    Anomalies
WHERE 
    record_count > 1 OR 
    unique_customers < COUNT(*) OR 
    unique_locations < COUNT(*) OR 
    unique_buyers < COUNT(*) OR 
    missing_values > 0;
========================================================================================================================================

table_name: SDL_MDS_PACIFIC_PERENSO_CYCLE_DATES
solution: 
1. Ensure `start_date` is always before `end_date`.
2. Check for duplicate `muid` values.
3. Validate `versionnumber` and `enterversionnumber` consistency.
4. Ensure `validationstatus` is either 'Validated' or 'Pending'.

snowflake query: 
SELECT 
    id, 
    muid,
    start_date, 
    end_date, 
    validationstatus, 
    versionnumber, 
    enterversionnumber,
    COUNT(*) OVER (PARTITION BY muid) AS muid_count
FROM SDL_MDS_PACIFIC_PERENSO_CYCLE_DATES
WHERE 
    start_date >= end_date
    OR COUNT(*) OVER (PARTITION BY muid) > 1
    OR versionnumber <> enterversionnumber
    OR validationstatus NOT IN ('Validated', 'Pending');
========================================================================================================================================

table_name: SDL_HK_POS_SCORECARD_MANNINGS
solution: Identify records with negative sales values or quantities, and investigate reasons. Check for data entry errors or returns. Implement validation rules to prevent negative values.
snowflake query: 
SELECT * 
FROM SDL_HK_POS_SCORECARD_MANNINGS 
WHERE SALESQTY < 0 OR SALESVALUE < 0;
========================================================================================================================================

table_name: SDL_CSL_SCHEMEUTILIZATION
solution: 
1. Ensure all required fields are populated, as sample data indicates fields are empty.
2. Validate data types, especially where TEXT and NUMBER types might be incorrectly formatted or null.
3. Check for timestamp fields having valid dates.

snowflake query: 
SELECT 
    * 
FROM 
    SDL_CSL_SCHEMEUTILIZATION
WHERE 
    distcode IS NULL 
    OR schemecode IS NULL 
    OR schemedescription IS NULL 
    OR invoiceno IS NULL 
    OR rtrcode IS NULL 
    OR company IS NULL 
    OR schdate IS NULL 
    OR schemetype IS NULL 
    OR schemeutilizedamt IS NULL 
    OR schemefreeproduct IS NULL 
    OR schemeutilizedqty IS NULL 
    OR companyschemecode IS NULL 
    OR createddate IS NULL 
    OR migrationflag IS NULL 
    OR schememode IS NULL 
    OR syncid IS NULL 
    OR schlinecount IS NULL 
    OR schvaluetype IS NULL 
    OR slabid IS NULL 
    OR billedprdccode IS NULL 
    OR billedprdbatcode IS NULL 
    OR billedqty IS NULL 
    OR schdiscperc IS NULL 
    OR freeprdbatcode IS NULL 
    OR billedrate IS NULL 
    OR modifieddate IS NULL 
    OR servicecrnrefno IS NULL 
    OR rtrurccode IS NULL 
    OR run_id IS NULL 
    OR crt_dttm IS NULL 
    OR file_name IS NULL 
    OR TRY_CAST(schdiscperc AS NUMBER) IS NULL 
    OR TRY_CAST(billedqty AS NUMBER) IS NULL 
    OR TRY_CAST(schemeutilizedqty AS NUMBER) IS NULL 
    OR TRY_CAST(schemeutilizedamt AS NUMBER) IS NULL 
    OR TRY_CAST(billedrate AS NUMBER) IS NULL 
    OR schdate NOT BETWEEN '1900-01-01' AND CURRENT_DATE()
    OR createddate NOT BETWEEN '1900-01-01' AND CURRENT_DATE()
    OR modifieddate NOT BETWEEN '1900-01-01' AND CURRENT_DATE()
    OR crt_dttm NOT BETWEEN '1900-01-01' AND CURRENT_DATE();
========================================================================================================================================

table_name: SDL_POP6_SG_GENERAL_AUDITS
        solution: Address missing data, ensure referential integrity, and check for data type consistency.
        snowflake query: 
        sql
        WITH Anomalies AS (
            SELECT 
                visit_id, audit_form_id, audit_form, section_id, section, subsection_id, subsection, 
                field_id, field_code, field_label, field_type, dependent_on_field_id, response, file_name, run_id, crtd_dttm
            FROM SDL_POP6_SG_GENERAL_AUDITS
            WHERE 
                visit_id IS NULL OR
                audit_form_id IS NULL OR
                audit_form IS NULL OR
                section_id IS NULL OR
                section IS NULL OR
                subsection_id IS NULL OR
                subsection IS NULL OR
                field_id IS NULL OR
                field_code IS NULL OR
                field_label IS NULL OR
                field_type IS NULL OR
                dependent_on_field_id IS NULL OR
                response IS NULL OR
                file_name IS NULL OR
                run_id IS NULL OR
                crtd_dttm IS NULL OR
                TRY_CAST(run_id AS NUMBER) IS NULL
        )
        SELECT * FROM Anomalies;
========================================================================================================================================

table_name: SDL_CUSTOMERPL_STDCOST_2022
solution: Detect negative and zero values in 'QTY' and 'STDCOST' columns, as they may indicate data entry errors or special cases needing review.
snowflake query: 
SELECT *
FROM SDL_CUSTOMERPL_STDCOST_2022
WHERE QTY <= 0 OR STDCOST <= 0;
========================================================================================================================================

table_name : SDL_ID_MDS_LOG
solution : Ensure logical correctness in queries and validate status consistency. Implement error handling for failed jobs.
snowflake query : 
SELECT 
    JOB_NAME, 
    STATUS, 
    RESULT, 
    QUERY, 
    CRTD_DTTM 
FROM 
    SDL_ID_MDS_LOG
WHERE 
    STATUS IS NULL 
    OR STATUS = 'Failed' 
    OR QUERY LIKE '%9999%' 
    OR RESULT LIKE '%error%' 
    OR RESULT LIKE '%invalid%'
    OR (STATUS = 'Running' AND RESULT NOT LIKE '%running%');
========================================================================================================================================

table_name : SDL_ID_POS_DAILY_SAT_SELLOUT
solution : Detect negative sales values and inconsistent data types; ensure "value" is positive for sales and not zero for returns, and correct data types.
snowflake query : 
SELECT *
FROM SDL_ID_POS_DAILY_SAT_SELLOUT
WHERE 
    (type = 'Sale' AND value <= 0)
    OR (type = 'Return' AND value = 0)
    OR TRY_CAST(value AS NUMBER) IS NULL
    OR TRY_CAST(crtd_dttm AS TIMESTAMP_NTZ) IS NULL;
========================================================================================================================================

table_name: SDL_LA_GT_SCHEDULE
solution: 
1. Check for missing values in 'route_id' and ensure all routes are assigned.
2. Standardize 'approved' values to either 'YES' or 'NO'.
3. Ensure 'schedule_date' aligns with 'crt_dttm' to check for future-dated schedules.

snowflake_query: 
SELECT 
    employee_id, 
    route_id, 
    schedule_date, 
    approved, 
    crt_dttm
FROM 
    SDL_LA_GT_SCHEDULE
WHERE 
    route_id IS NULL 
    OR approved NOT IN ('YES', 'NO')
    OR schedule_date < TO_CHAR(crt_dttm, 'YYYY-MM-DD');
========================================================================================================================================

table_name: SDL_GCGH_GEO_HIER
solution: Check for missing or inconsistent data in 'MARKET' and 'COUNTRY_CODE_ISO2/ISO3'. Ensure proper data validation checks are in place during data ingestion. Consider using default values or flags for missing data.
snowflake query: 
SELECT * 
FROM SDL_GCGH_GEO_HIER 
WHERE MARKET IS NULL 
   OR COUNTRY_CODE_ISO2 IS NULL 
   OR COUNTRY_CODE_ISO3 IS NULL 
   OR LENGTH(COUNTRY_CODE_ISO2) != 2 
   OR LENGTH(COUNTRY_CODE_ISO3) != 3;
========================================================================================================================================

table_name: SDL_CSL_SALESINVOICEORDERS
solution: 
- Detect and address negative `run_id` values.
- Investigate `uploadflag` columns with `None` for missing data.
- Check for discrepancies between `orderdate`, `createddate`, and `crt_dttm`.

snowflake query:
SELECT 
  * 
FROM 
  SDL_CSL_SALESINVOICEORDERS
WHERE 
  run_id < 0 
  OR uploadflag IS NULL 
  OR orderdate <> createddate 
  OR createddate <> crt_dttm;
========================================================================================================================================

table_name: SDL_LA_GT_INVENTORY_FACT
solution: Detect negative or zero amounts, convert text fields to appropriate data types, and ensure all records have valid dates and non-negative quantities.
snowflake query: 
SELECT * FROM SDL_LA_GT_INVENTORY_FACT
WHERE 
    TRY_TO_NUMBER(amount) <= 0 
    OR TRY_TO_NUMBER(qty) < 0 
    OR TRY_TO_DATE(expirydate, 'YYYY-MM-DD') IS NULL
    OR TRY_TO_DATE(recdate, 'YYYY-MM-DD') IS NULL;
========================================================================================================================================

table_name: SDL_POP6_SG_PRODUCT_LISTS_ALLOCATION  
solution: Detect and handle negative values in the 'product_group_status' and 'run_id' columns, which might indicate data entry errors. Ensure data validation checks are in place to prevent such entries.  
snowflake query:  
SELECT *  
FROM SDL_POP6_SG_PRODUCT_LISTS_ALLOCATION  
WHERE product_group_status < 0  
   OR run_id < 0;  

table_name: SDL_POP6_SG_PRODUCT_LISTS_ALLOCATION  
solution: Identify rows where 'crtd_dttm' is earlier than 'prod_grp_date', as it might suggest data consistency issues. Implement logic to ensure accurate timestamp ordering.  
snowflake query:  
SELECT *  
FROM SDL_POP6_SG_PRODUCT_LISTS_ALLOCATION  
WHERE crtd_dttm < prod_grp_date;
========================================================================================================================================

table_name: SDL_KR_COUPANG_CUSTOMER_BRAND_TREND
solution: Ensure numeric fields are stored as numbers, not text. Check for rows where totals do not match the sum of their parts. Verify that sales amounts are consistent with user counts and average product sales prices.
snowflake query: 
SELECT 
    * 
FROM 
    SDL_KR_COUPANG_CUSTOMER_BRAND_TREND 
WHERE 
    TRY_CAST(new_user_count AS NUMBER) IS NULL 
    OR TRY_CAST(curr_user_count AS NUMBER) IS NULL 
    OR TRY_CAST(tot_user_count AS NUMBER) IS NULL 
    OR (tot_user_count != new_user_count + curr_user_count) 
    OR (new_user_sales_amt != new_user_count * new_user_avg_product_sales_price) 
    OR (curr_user_sales_amt != curr_user_count * curr_user_avg_product_sales_price) 
    OR (tot_user_avg_product_sales_price != (new_user_sales_amt + curr_user_sales_amt) / NULLIF(tot_user_count, 0));
========================================================================================================================================

Certainly! Based on the provided metadata and sample data, here are potential anomalies, solutions, and Snowflake queries:

1. **Negative or Unusual ID Values**: 
   - Table: `SDL_MDS_PH_ISE_SOS_TARGETS`
   - Solution: IDs should generally be positive and unique. Investigate entries with negative or duplicate IDs.
   - Snowflake Query: 
     sql
     SELECT id, COUNT(*)
     FROM SDL_MDS_PH_ISE_SOS_TARGETS
     WHERE id < 0 OR id IN (
       SELECT id
       FROM SDL_MDS_PH_ISE_SOS_TARGETS
       GROUP BY id
       HAVING COUNT(*) > 1
     )
     GROUP BY id;
     

2. **Future Calendar Years**:
   - Table: `SDL_MDS_PH_ISE_SOS_TARGETS`
   - Solution: Verify if future years are intentional or erroneous. Adjust data entry or business logic accordingly.
   - Snowflake Query: 
     sql
     SELECT *
     FROM SDL_MDS_PH_ISE_SOS_TARGETS
     WHERE CAST(cal_year AS INTEGER) > YEAR(CURRENT_DATE);
     

3. **Negative Target Values**:
   - Table: `SDL_MDS_PH_ISE_SOS_TARGETS`
   - Solution: Ensure negative targets are valid; otherwise, correct them.
   - Snowflake Query: 
     sql
     SELECT *
     FROM SDL_MDS_PH_ISE_SOS_TARGETS
     WHERE target < 0;
     

4. **Mismatched Timestamps**:
   - Table: `SDL_MDS_PH_ISE_SOS_TARGETS`
   - Solution: `lastchgdatetime` should logically be after `enterdatetime`. Verify and correct any discrepancies.
   - Snowflake Query:
     sql
     SELECT *
     FROM SDL_MDS_PH_ISE_SOS_TARGETS
     WHERE lastchgdatetime < enterdatetime;
     

These queries and solutions aim to detect potential anomalies efficiently within the given dataset.
========================================================================================================================================

table_name: SDL_ID_POS_GUARDIAN_STOCK
solution: Identify anomalies such as missing categories, zero stock-on-hand values, and validate yearmonth format. Suggest filling missing categories, verifying stock levels, and ensuring yearmonth is a valid date.
snowflake query: 
SELECT 
    ARTICLE, 
    ARTICLE_DESC, 
    CATEGORY, 
    SOH_STORES, 
    SOH_DC, 
    POS_CUST, 
    YEARMONTH, 
    RUN_ID, 
    CRTD_DTTM, 
    FILENAME 
FROM 
    SDL_ID_POS_GUARDIAN_STOCK
WHERE 
    CATEGORY IS NULL 
    OR SOH_STORES = 0 
    OR SOH_DC = 0 
    OR NOT TRY_TO_DATE(YEARMONTH || '01', 'YYYYMMDD') IS NOT NULL;
========================================================================================================================================

table_name: SDL_CCR_PRODUCT_MAPPING
solution: Detect anomalies such as null values in 'rule_expression', illogical 'execution_order', and invalid 'target_value'.
snowflake query: 
SELECT 
    dimension, 
    rulegroupname, 
    rule_type, 
    rulename_sourcevalue, 
    rule_description, 
    rule_expression, 
    target_value, 
    logical_operator, 
    execution_order 
FROM SDL_CCR_PRODUCT_MAPPING 
WHERE 
    rule_expression IS NULL 
    OR TRY_TO_NUMBER(execution_order) IS NULL 
    OR TRY_TO_NUMBER(target_value) IS NULL;
========================================================================================================================================

table_name : SDL_MY_AS_WATSONS_INVENTORY
solution : Inspect and correct invalid year and month values, address negative inventory quantities, and ensure inventory values are non-negative.
snowflake query : 
SELECT 
    * 
FROM 
    SDL_MY_AS_WATSONS_INVENTORY
WHERE 
    TRY_TO_NUMBER(YEAR) IS NULL OR CAST(YEAR AS NUMBER) < 1900 OR CAST(YEAR AS NUMBER) > 9999
    OR TRY_TO_NUMBER(MNTH_ID) IS NULL OR CAST(MNTH_ID AS NUMBER) < 1 OR CAST(MNTH_ID AS NUMBER) > 12
    OR TRY_TO_NUMBER(INV_QTY_PC) IS NULL OR CAST(INV_QTY_PC AS NUMBER) < 0
    OR TRY_TO_NUMBER(INV_VALUE) IS NULL OR CAST(INV_VALUE AS NUMBER) < 0;
========================================================================================================================================

```sql
table_name: SDL_MDS_PH_DISTRIBUTOR_PRODUCT
solution: 
1. Missing Data: Several columns have missing data, such as 'versionflag', 'distcode_code', 'promostartperiod', and 'enterusername'. 
   Solution: Implement data validation checks and ensure mandatory fields are filled before data insertion.
   
SQL Query:
SELECT * 
FROM SDL_MDS_PH_DISTRIBUTOR_PRODUCT
WHERE versionflag IS NULL 
   OR distcode_code IS NULL 
   OR promostartperiod IS NULL 
   OR enterusername IS NULL;

2. Invalid Date Ranges: The 'promoendperiod' is earlier than 'promostartperiod' for some records.
   Solution: Implement a constraint to ensure that 'promoendperiod' is always later than or equal to 'promostartperiod'.
   
SQL Query:
SELECT * 
FROM SDL_MDS_PH_DISTRIBUTOR_PRODUCT
WHERE promoendperiod < promostartperiod;

3. Duplicate Entries: Duplicate records might exist based on combinations of key identifiers.
   Solution: Identify and remove duplicates, and enforce uniqueness constraints on key columns.
   
SQL Query:
SELECT muid, COUNT(*)
FROM SDL_MDS_PH_DISTRIBUTOR_PRODUCT
GROUP BY muid
HAVING COUNT(*) > 1;

4. Invalid Validation Status: Records with 'validationstatus' as 'invalid' need review.
   Solution: Implement a process to review and correct invalid entries.
   
SQL Query:
SELECT * 
FROM SDL_MDS_PH_DISTRIBUTOR_PRODUCT
WHERE validationstatus = 'invalid';
```

Each solution addresses a specific anomaly and proposes a preventive measure alongside a Snowflake-compatible SQL query for detection.
table_name: SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
solution: 
1. Identify and handle duplicate records.
2. Identify and address negative target values.
3. Verify and correct future target years beyond a reasonable range.
4. Ensure the sum of weekly targets matches the target value.

SQL Queries:
1. Duplicate Records:
sql
SELECT DISTCODE, TARGETREFNO, COUNT(*) AS RECORD_COUNT
FROM SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
GROUP BY DISTCODE, TARGETREFNO
HAVING RECORD_COUNT > 1;


2. Negative Target Values:
sql
SELECT DISTINCT DISTCODE, TARGETREFNO, TARGETVALUE
FROM SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
WHERE TARGETVALUE < 0;


3. Future Target Years:
sql
SELECT DISTINCT DISTCODE, TARGETREFNO, TARGETYEAR
FROM SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
WHERE TARGETYEAR > YEAR(CURRENT_DATE) + 5;


4. Weekly Targets Sum Mismatch:
sql
SELECT DISTINCT DISTCODE, TARGETREFNO, TARGETVALUE, 
    (WEEK1 + WEEK2 + WEEK3 + WEEK4 + WEEK5) AS SUM_WEEKLY
FROM SDL_CSL_RDSSMWEEKLYTARGET_OUTPUT
WHERE TARGETVALUE != (WEEK1 + WEEK2 + WEEK3 + WEEK4 + WEEK5);
table_name: SDL_CSL_DAILYSALES_UNDELIVERED
solution: 
1. Missing Data Anomalies
   - Check for columns with missing values to identify records with incomplete data.
   - SQL Query:
     sql
     SELECT *
     FROM SDL_CSL_DAILYSALES_UNDELIVERED
     WHERE salinvno IS NULL
        OR salinvdate IS NULL
        OR salnetamt IS NULL
        OR prdcode IS NULL;
     
   - Recommendation: Ensure mandatory fields are filled during data entry or processing. Implement validation rules.

2. Data Type Anomalies
   - Check for incorrect data types, especially in numeric fields where text might have been entered.
   - SQL Query:
     sql
     SELECT *
     FROM SDL_CSL_DAILYSALES_UNDELIVERED
     WHERE TRY_TO_NUMBER(salgrossamt) IS NULL
        AND salgrossamt IS NOT NULL;
     
   - Recommendation: Validate data types during ETL processes to prevent type mismatches.

3. Date Anomalies
   - Identify records with invalid date sequences, such as delivery dates before invoice dates.
   - SQL Query:
     sql
     SELECT *
     FROM SDL_CSL_DAILYSALES_UNDELIVERED
     WHERE saldlvdate < salinvdate;
     
   - Recommendation: Implement date checks to ensure logical consistency of timestamps.

4. Duplicate Records
   - Detect potential duplicates based on unique fields like invoice number.
   - SQL Query:
     sql
     SELECT salinvno, COUNT(*)
     FROM SDL_CSL_DAILYSALES_UNDELIVERED
     GROUP BY salinvno
     HAVING COUNT(*) > 1;
     
   - Recommendation: Use unique constraints or deduplication processes to prevent duplicate entries.


These solutions and queries focus on detecting common data anomalies related to missing values, incorrect data types, invalid date sequences, and duplicate records. Each solution includes a recommendation to address the identified anomaly.
table_name: PRODBU_PRODUCTBUSINESSUNIT
solution: The sample data is empty, suggesting potential issues with data ingestion or extraction. First, verify data loading processes and ensure data is being inserted into the table. Check ETL jobs and data pipelines for errors. If the data is supposed to be populated and isn't due to issues in the data source or ETL, address those issues first. Once data is populated, use the following queries to detect anomalies.

SQL Queries:
-- Check for missing or null values in critical columns
SELECT 
    COUNT(*) AS total_rows,
    COUNT(CASE WHEN PRODUCTID IS NULL THEN 1 END) AS null_productid,
    COUNT(CASE WHEN BUSINESSUNITID IS NULL THEN 1 END) AS null_businessunitid,
    COUNT(CASE WHEN PRODUCTTYPE IS NULL THEN 1 END) AS null_producttype
FROM PRODBU_PRODUCTBUSINESSUNIT;

-- Check for duplicate records based on a unique constraint, assuming PRODUCTID should be unique
SELECT 
    PRODUCTID, 
    COUNT(*) AS duplicate_count
FROM PRODBU_PRODUCTBUSINESSUNIT
GROUP BY PRODUCTID
HAVING COUNT(*) > 1;

-- Check for inconsistent data in ISLISTED, ISORDERABLE, ISRETURNABLE which should be 'Yes' or 'No'
SELECT *
FROM PRODBU_PRODUCTBUSINESSUNIT
WHERE ISLISTED NOT IN ('Yes', 'No')
   OR ISORDERABLE NOT IN ('Yes', 'No')
   OR ISRETURNABLE NOT IN ('Yes', 'No');

-- Check for negative values in MAXIMUMORDERQUANTITY which should always be non-negative
SELECT *
FROM PRODBU_PRODUCTBUSINESSUNIT
WHERE MAXIMUMORDERQUANTITY < 0;


This approach focuses on identifying common data quality issues such as missing, duplicate, inconsistent, or logically incorrect data. Adjustments to data loading and validation processes should address these anomalies.
========================================================================================================================================

table_name: SDL_CSL_UDCDETAILS
solution:
1. Negative IDs: The `masterid` and `run_id` columns contain negative values, which might be considered invalid if IDs are expected to be positive.
   Solution: Verify the data source and ensure IDs are correctly entered. Consider altering the data type to enforce non-negative values if applicable.

2. NULL values: The `mastervaluename` column contains NULL values.
   Solution: Investigate why `mastervaluename` is missing and ensure data integrity. If NULLs are acceptable, confirm that downstream processes can handle them.

3. Upload Flag Inconsistency: Rows with the `uploadflag` set to 'N' might indicate incomplete or unsuccessful uploads.
   Solution: Investigate the process that sets the `uploadflag` and ensure it accurately reflects the data state or consider excluding these rows from further processing.

4. Duplicate Timestamps: Both `createddate` and `crt_dttm` have identical values, which may be redundant.
   Solution: Determine if both columns are necessary or if one can be removed to streamline the schema.

Snowflake SQL Query:
sql
-- Query to detect anomalies in SDL_CSL_UDCDETAILS
SELECT *
FROM SDL_CSL_UDCDETAILS
WHERE masterid < 0
   OR run_id < 0
   OR mastervaluename IS NULL
   OR uploadflag = 'N'
   OR createddate = crt_dttm;
========================================================================================================================================

